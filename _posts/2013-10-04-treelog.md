---
layout: post
title: Treelog

meta:
  nav: blog
  author: channingwalton
  pygments: true
---

Treelog
=======

[Treelog](https://github.com/lancewalton/treelog) is the result of a real problem that arose in a trading system that we were working on: 
> how can we accurately audit everything that happens to a trade?

The first (and tedious) answer is copius logging by writing to some kind of audit data type or simple logger.

There are a number of problems with this approach:

- writing logging around computations often complicates the code as values must be extracted, recorded and then applied
- the decoupled nature of logging from the computation can lead to inaccurate logs
- linear logs are very difficult to follow
- its not easy to control how much of a linear log to show a user if you do not know what is detail and what isn't

Treelog resolves these issues by making the log itself a tree, reflecting the computational tree it logs, and uses techniques described in the [Typeclassopedia](http://www.haskell.org/wikiupload/e/e9/Typeclassopedia.pdf): the Writer Monad, a Monad Transformer, and a cunning Monoid.

Note that this blog is a more technical descripion of how Treelog was written. For a quick introduction of use please refer to the [README](https://github.com/lancewalton/treelog).
I will also refer you to the excellent Scalaz tutorial at [http://eed3si9n.com/learning-scalaz/]() to study the details of Scalaz where appropriate.

Logging with Treelog
--------------------
Here is an example which illustrates how Treelog is used ([more examples](https://github.com/lancewalton/treelog#treelog-examples)):

```scala
val simple: DescribedComputation[Int] = 
  "Calculating sum" ~< {
    for {
      x ← 11 ~> ("x = " + _)
      y ← 2 ~> ("y = " + _)
      sum ← (x + y) ~> ("Sum is " + _)
    } yield sum
```

`DescribedComputation[Value]` is just a type alias for `EitherT[LogTreeWriter, String, Value]`. EitherT, a [Monad Transformer](http://eed3si9n.com/learning-scalaz/Monad+transformers.html), enables success and failure to be represented and will be covered below. 

The log and value can be retrieved with `result.run.written` and `result.run.value` respectively. The written tree will look like this:

```
Calculating sum
  x = 11
  y = 2
  Sum is 13
```

and the value will be `\/-(13)`, which is Scalaz's Right.

Tree Nodes
----------

The nodes of the tree contain a `LogTreeLabel`:
```scala
sealed trait LogTreeLabel[Annotation] {
  def annotations: Set[Annotation]
  def success(): Boolean
  …
}
case class DescribedLogTreeLabel[Annotation](description: String, success: Boolean, annotations: Set[Annotation] = Set[Annotation]()) extends LogTreeLabel[Annotation] { … }

case class UndescribedLogTreeLabel[Annotation](success: Boolean, annotations: Set[Annotation] = Set[Annotation]()) extends LogTreeLabel[Annotation] { … }
```

So the node is able to represent success of failure, has an optional description, and a set of annotations. Annotations allow extra information to be carried in a Node which may be useful when working with the audit later. For our trading system, that was a set of other trades that were effected by the process as a side effect of processing a trade.

In Treelog we distinguish between tree nodes that describe a computation, a `DescribedLogTreeLabel`, and an `UndescribedLogTreeLabel` which is a Tree with no description in the root. In the example above, the root node is a DescribedLogTreeLabel containing `Calculating sum`.

This is an important distinction that informs the way trees must be combined by our Treelog Monoid, which the Writer needs.

Syntactic Sugar
---------------
Treelog makes use of some syntactic sugar inspired by Tony Morris's [blog](http://blog.tmorris.net/posts/the-writer-monad-using-scala-example/) on Writer. In the example above, `~>` is a method on an implicitlt constructed class which takes a value, x: T, and returns a `DescribedComputation[T]` which is an EitherT whose value is `\/-(x)`, and written value is a leaf node containing the description.

There is support for Booleans, Options, Eithers and Traversables which you can learn about from the Treelog [readme](https://github.com/lancewalton/treelog/blob/master/README.md).

Writer and Monoid
-----------------

> Writer allows us to do computations while making sure that all the log values are combined into one log value that then gets attached to the result. [LYAH](http://learnyouahaskell.com/for-a-few-monads-more)

So Writers allow us to write a log embedded within a computation.

Here is a simple example using Scalaz, see the references for more detailed examples.

```scala
val r: Writer[String, Int] = 
  for {
    a ← 3.set("Got a 3.")
    b ← 5.set("Got a 5.")
  } yield a * b

println(r.written) // Got a 3.Got a 5.
println(r.value) // 15
```
The Writer uses a monoid for the written value (a String in this case) to combine the logs (concatenate for String).


> A Monoid is a type with an associative binary operation (append) and an identity value. 

For String, append is concatenation and identity is the empty String, for Lists its append and Nil, etc.

Back to Treelog
---------------

Treelog uses a Scalaz [Writer](http://eed3si9n.com/learning-scalaz/Writer.html), [Tree](http://eed3si9n.com/learning-scalaz/Tree.html) and a custom [Monoid](http://eed3si9n.com/learning-scalaz/Monoid.html) implementation to record logs.

The monoid has to provide two things: a `zero` value, and a binary operation that combines two trees in a meaningful way. The zero value for Treelog is just a constant used internally to the Monoid implementation and never leaks out since there is always at least one value being logged.

Combining trees is done as follows:

- A zero Tree with a tree is just the tree
- Two Undescribed Trees become a new Undescribed Tree with the children of the right Tree appended to the children of the left Tree
- An Undescribed Tree T1, and a Described Tree, T2, becomes an Undescribed Tree with *T2 appended to the children of T1*
- A Described Tree, T1, and an Undescribed Tree, T2, is an Undescribed Tree with *T1 prepended to the children of T2*
- Two Described Trees are combined by creating an Undescribed Tree with the two trees as children

Success and Failure - EitherT
-------------------

The purpose of Treelog is to audit a computation, return the log and result, and indicate whether the computation was successful or not. The Writer with the Monoid described above satisfies the first two requirements, but not the third. To add success and failure, the writer needs to be combined with Either. 

Fortunately, [Monad Transformers](http://debasishg.blogspot.co.uk/2011/07/monad-transformers-in-scala.html) allow monads to be combined in a useful way, in this case, we need EitherT!

I am going to be ritually sacrificed to the Gods of FP for what I am about to say, but I find it helps people coming from an OO background: think of a Monad Transformer as a decorator. It encapsulates a monad, provides extra behaviour, and through map and flatMap or for-comprehensions, allows you to work with the monad as if the transformer wasn't there.

EitherT is constructed with three types: `EitherT[M, A, B]` where M is the monad, A is the failure type and B is the success type. In Treelog, M is a Writer, A is a String and B is the type of the result.

Logtree includes the methods `def failure[Value](description: String): DescribedComputation[Value]` and `def success[Value](value: Value, description: String): DescribedComputation[Value]` to support failure and success. They ensure that the failure case is included in the tree and that the nodes in the tree now reflect that the computation has failed.

Here is an example from Treelog:

```scala
val leftEithers: DescribedComputation[Int] = 
  "Calculating left either sum" ~< {
    for {
      x ← 11.right[String] ~>? ("x = " + _)     // 'right' is scalaz syntactic sugar for creating an \/
      y ← "fubar".left[Int] ~>? ("y = " + _)
      sum ← (x + y) ~> (v ⇒ "Sum is " + v)
    } yield sum
  }

val leftEitherWriter: LogTreeWriter[\/[String, Int]] = leftEithers.run
println(leftEithers.run.written.shows)
```
To retrieve the underying monad, the Writer, back from EitherT we call `run` which returns the Writer containing scalaz's Either type `\/` (which is more useful than scala's bulit-in Either).

The written value is:
```
Failed: Calculating left either sum
  x = 11
  Failed: fubar

Failure: Calculating left either sum
```

So the written log indicates that the whole computation failed, and the result is -\/, the Left for a Scalaz Either, containing `Failure: Calculating left either sum`.


Further Reading
===============

- [Writer Monad](http://eed3si9n.com/learning-scalaz/Writer.html)
- [Monoids](http://eed3si9n.com/learning-scalaz/Monoid.html)
- [Monad Transformers in Scala](http://debasishg.blogspot.co.uk/2011/07/monad-transformers-in-scala.html)
- [Monad Transformers in the Wild](http://www.slideshare.net/StackMob/monad-transformers-in-the-wild)