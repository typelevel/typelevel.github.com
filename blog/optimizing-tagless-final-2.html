<!DOCTYPE html>
<html lang="en" data-bulma-theme="light">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="icon" href="../img/favicon.ico" sizes="32x32">
  <link rel="icon" href="../img/favicon.svg" type="image/svg+xml">
  <link rel="apple-touch-icon" href="../img/apple-touch-icon.png">

  <meta property="og:title" content="Optimizing Tagless Final – Part 2 – Monadic programs" />
  <meta property="og:image" content="../img/logo.png" />

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:500">

  

  <link rel="stylesheet" href="../main.css">
  <link rel="stylesheet" href="../css/code.css">
  <script src="../main.js"></script>

  <title>Optimizing Tagless Final – Part 2 – Monadic programs</title>
</head>

<body class="bulma-is-flex bulma-is-flex-direction-column">
  <nav class="bulma-navbar" role="navigation" aria-label="main navigation">
  <div class="bulma-navbar-brand">
    <a class="bulma-navbar-item" href="../">
      <img src="../img/logo.svg" />
    </a>

    <a role="button" class="bulma-navbar-burger" aria-label="menu" aria-expanded="false" data-target="navMenu"
      onClick="handleBurgerClick(this)">
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
    </a>
  </div>
  <div class="bulma-navbar-menu" id="navMenu">
    <div class="bulma-navbar-start">

    </div>
    <div class="bulma-navbar-end">
      <!-- <div class="bulma-navbar-item"><a class="bulma-button bulma-is-rounded bulma-is-primary bulma-has-text-light">Get Started</a></div> -->
      <!-- <div class="bulma-navbar-item"><a class="bulma-button bulma-is-text">Learn</a></div> -->
      <div class="bulma-navbar-item"><a class="bulma-button bulma-is-text" href="../projects/">Projects</a></div>
      <div class="bulma-navbar-item"><a class="bulma-button bulma-is-text" href="../community/">Community</a></div>
      <div class="bulma-navbar-item"><a class="bulma-button bulma-is-text" href="../foundation/">Foundation</a></div>
      <div class="bulma-navbar-item"><a class="bulma-button bulma-is-text" href="index.html">Blog</a></div>
      <div class="bulma-navbar-item">
        <a id="search-top-bar" class="bulma-button bulma-is-text" aria-label="Search" onclick="showSearchModal()">
          <span class="bulma-icon bulma-is-small bulma-is-size-6">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc. --><path fill="currentColor" d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376C296.3 401.1 253.9 416 208 416 93.1 416 0 322.9 0 208S93.1 0 208 0 416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"/></svg>
          </span>
        </a>
      </div>
    </div>
  </div>
</nav>

<!-- Search Modal -->
<div id="search-modal" class="bulma-modal bulma-is-justify-content-flex-start bulma-pt-6 bulma-pb-6">
  <div class="bulma-modal-background bulma-is-align-items-flex-start" onclick="hideSearchModal()"></div>
  <div class="bulma-modal-card">
    <header class="bulma-modal-card-head">
      <p class="bulma-control bulma-has-icons-left bulma-is-flex-grow-1">
        <input id="search-input" class="bulma-input bulma-is-medium bulma-is-primary" type="search" autocomplete="off" oninput="onSearchInput(event)">
        <span class="bulma-icon bulma-is-left bulma-has-text-primary">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc. --><path fill="currentColor" d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376C296.3 401.1 253.9 416 208 416 93.1 416 0 322.9 0 208S93.1 0 208 0 416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"/></svg>
        </span>
      </p>
    </header>
    <section id="search-results" class="bulma-modal-card-body">
    </section>
    <footer class="bulma-modal-card-foot bulma-is-justify-content-space-between">
      <span class="bulma-has-text-grey bulma-is-size-7">
        <kbd class="bulma-tag">/</kbd> to open search &nbsp;
        <kbd class="bulma-tag">Esc</kbd> to close
      </span>
    </footer>
  </div>
</div>

  <main class="bulma-is-flex-grow-1">
    
<section class="bulma-hero bulma-is-primary bulma-is-bold">
  <div class="bulma-hero-body bulma-container bulma-is-max-desktop">
    <p class="bulma-title bulma-has-text-light">Optimizing Tagless Final – Part 2 – Monadic programs</p>
    <p class="blog-post-byline bulma-has-text-light bulma-subtitle">
      by
      
        Luka Jacobowitz<span class="delimiter">,</span><span class="last-delimiter"> &</span>
      
      on June 27, 2018
    </p>
     
      <span class="bulma-tag">technical</span>
     
  </div>
</section>
<div class="bulma-section bulma-container bulma-is-max-desktop">
  <div class="blog-post bulma-content">
    <h1 id="optimizing-tagless-final-part-2-monadic-programs" class="title">Optimizing Tagless Final – Part 2 – Monadic programs</h1>
    <p>In our previous post on optimizing tagless final programs we learned how we could use the <a href="https://github.com/LukaJCB/sphynx">sphynx library</a> to derive some optimization schemes for your tagless final code. In case you missed it and want to read up on it, you can find it <a href="optimizing-final-tagless.html">right here</a> or you can watch my presentation on the topic <a href="https://www.youtube.com/watch?v=E9iRYNuTIYA">here</a>, but you should be able to follow this blog post without going through it all in detail.</p>
    
    <h2 id="optimizing-monadic-programs" class="section"><a class="anchor-link" href="#optimizing-monadic-programs"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc. --><path fill="currentColor" d="M419.5 96c-16.6 0-32.7 4.5-46.8 12.7-15.8-16-34.2-29.4-54.5-39.5 28.2-24 64.1-37.2 101.3-37.2 86.4 0 156.5 70 156.5 156.5 0 41.5-16.5 81.3-45.8 110.6l-71.1 71.1c-29.3 29.3-69.1 45.8-110.6 45.8-86.4 0-156.5-70-156.5-156.5 0-1.5 0-3 .1-4.5 .5-17.7 15.2-31.6 32.9-31.1s31.6 15.2 31.1 32.9c0 .9 0 1.8 0 2.6 0 51.1 41.4 92.5 92.5 92.5 24.5 0 48-9.7 65.4-27.1l71.1-71.1c17.3-17.3 27.1-40.9 27.1-65.4 0-51.1-41.4-92.5-92.5-92.5zM275.2 173.3c-1.9-.8-3.8-1.9-5.5-3.1-12.6-6.5-27-10.2-42.1-10.2-24.5 0-48 9.7-65.4 27.1L91.1 258.2c-17.3 17.3-27.1 40.9-27.1 65.4 0 51.1 41.4 92.5 92.5 92.5 16.5 0 32.6-4.4 46.7-12.6 15.8 16 34.2 29.4 54.6 39.5-28.2 23.9-64 37.2-101.3 37.2-86.4 0-156.5-70-156.5-156.5 0-41.5 16.5-81.3 45.8-110.6l71.1-71.1c29.3-29.3 69.1-45.8 110.6-45.8 86.6 0 156.5 70.6 156.5 156.9 0 1.3 0 2.6 0 3.9-.4 17.7-15.1 31.6-32.8 31.2s-31.6-15.1-31.2-32.8c0-.8 0-1.5 0-2.3 0-33.7-18-63.3-44.8-79.6z"/></svg></a>Optimizing monadic programs</h2>
    <p>One of the questions I&#39;ve been getting a lot, is if we can also do something like that for the monadic parts of our program.
    The answer is yes, we can, however it will have to be quite a bit different.</p>
    <p>I don&#39;t think the differences are quite obvious, so we&#39;ll go through them step by step.
    With applicative programs, we&#39;re optimizing a bunch of independent instructions.
    That means, we can look at all of them and extract information out of them statically (i.e. without running the interpreter).
    They can be seen as a sequence of instructions that we can fold down to a single monoid <code>M</code>, that holds the information that we need to optimize.
    We then used that monoid to recreate a new interpreter that can take this extra information into account.</p>
    <p>With monadic programs, we do not have such luxury.
    We can only step through each of our instructions one at a time, because every instruction depends on the results of the prior one.
    This means that we cannot extract any information beyond the very first instruction we have.
    That might seem like a deal breaker, but there&#39;s still a few things we can do.
    We could, for example, build up our monoid <code>M</code> dynamically, after each monadic instruction.
    Then, before invoking the next computation in the monadic sequence, we could take that monoid and recreate that next computation with that extra information.</p>
    <p>Now, that might sound super abstract to you, and I wouldn&#39;t disagree, so let&#39;s look at a quick example.
    Say, we&#39;re using the <code>KVStore</code> algebra again from last time:</p>
    <pre><code class="nohighlight"><span class="keyword">trait</span><span> </span><span class="type-name">KVStore</span><span>[</span><span class="type-name">F</span><span>[</span><span class="identifier">_</span><span>]] {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">get</span><span>(</span><span class="identifier">key</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">F</span><span>[</span><span class="type-name">Option</span><span>[</span><span class="type-name">String</span><span>]]
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">put</span><span>(</span><span class="identifier">key</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">value</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">F</span><span>[</span><span class="type-name">Unit</span><span>]
}</span></code></pre>
    <p>We could optimize programs with this algebra by caching the results of <code>get</code> and we could use that same cache to also cache key-value pairs we inserted using <code>put</code>.</p>
    <p>So given this example program:</p>
    <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">program</span><span>[</span><span class="type-name">F</span><span>[</span><span class="identifier">_</span><span>]: </span><span class="type-name">Monad</span><span>](</span><span class="identifier">key</span><span>: </span><span class="type-name">String</span><span>)(</span><span class="type-name">F</span><span>: </span><span class="type-name">KVStore</span><span>[</span><span class="type-name">F</span><span>]): </span><span class="type-name">F</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">String</span><span>]] = </span><span class="keyword">for</span><span> {
  </span><span class="identifier">_</span><span> &lt;- </span><span class="type-name">F</span><span>.</span><span class="identifier">put</span><span>(</span><span class="identifier">key</span><span>, </span><span class="string-literal">&quot;cat&quot;</span><span>)
  </span><span class="identifier">dog</span><span> &lt;- </span><span class="type-name">F</span><span>.</span><span class="identifier">get</span><span>(</span><span class="identifier">key</span><span>)
  </span><span class="identifier">cat</span><span> &lt;- </span><span class="type-name">F</span><span>.</span><span class="identifier">get</span><span>(</span><span class="identifier">dog</span><span>.</span><span class="identifier">getOrElse</span><span>(</span><span class="string-literal">&quot;dog&quot;</span><span>))
  </span><span class="identifier">cat2</span><span> &lt;- </span><span class="type-name">F</span><span>.</span><span class="identifier">get</span><span>(</span><span class="string-literal">&quot;cat&quot;</span><span>)
} </span><span class="keyword">yield</span><span> </span><span class="type-name">List</span><span>(</span><span class="identifier">dog</span><span>, </span><span class="identifier">cat</span><span>, </span><span class="identifier">cat2</span><span>).</span><span class="identifier">flatten</span></code></pre>
    <p>The naively interpreted program would be doing the following things:
    1. put the value &quot;cat&quot; into the store with the <code>key</code> passed by the user
    2. get the value &quot;cat&quot; back out of the store
    3. access the key-value store and maybe return a value associated with the key &quot;cat&quot;
    4. access the store again with the same &quot;cat&quot; key.</p>
    <p>Now if accessing the key-value store means going through a network layer this is of course highly inefficient.
    Ideally our fully optimized program should do the following things:
    1. put the value &quot;cat&quot; into the store with the <code>key</code> parameter passed by the user and cache it.
    2. access the cache to get the value &quot;cat&quot; associated with <code>key</code>
    3. access the key-value-store and maybe return a value associated with the key &quot;cat&quot;
    4. access the cache to return the previous result for the &quot;cat&quot; key.</p>
    <p>Cool, next, let&#39;s look at how we might get there.
    First the type of our cache, which for our case can just be a <code>Map[String, String]</code>, but generically could just be any monoid.</p>
    <p>Now what we want to do is transform any interpreter for <code>KVStore</code> programs into interpreters that
    1. Look in the cache before performing a <code>get</code> action with the actual interpreter
    2. Write to the cache after performing either a <code>get</code> or <code>put</code> action.</p>
    <p>So how can we get there? It seems like we want to thread a bunch of state through our program, that we want to both read and write to.
    If you&#39;re familiar with FP folklore you might recognize that that description fits almost exactly to the <code>State</code> monad.
    Furthermore, because we know that our <code>F[_]</code> is a monad, that means the <code>StateT</code> monad transformer over <code>F</code> will also be a monad.</p>
    <p>Okay with that said, let&#39;s try to develop function that turns any interpreter <code>KVStore[F]</code> into an interpreter into <code>StateT[F, M, A]</code>, so an <code>KVStore[StateT[F, M, ?]]</code>, where <code>M</code> is the monoid we use to accumulate our extracted information.
    We&#39;ll start with the <code>put</code> operation.
    For <code>put</code>, we&#39;ll want to call the interpreter to perform the action and then modify the state by adding the retrieved value into our cache.
    To make the code a bit more legible we&#39;ll also define a few type aliases.</p>
    <pre><code class="nohighlight"><span class="keyword">type</span><span> </span><span class="type-name">Cache</span><span> = </span><span class="type-name">Map</span><span>[</span><span class="type-name">String</span><span>, </span><span class="type-name">String</span><span>]
</span><span class="keyword">type</span><span> </span><span class="type-name">CachedAction</span><span>[</span><span class="type-name">A</span><span>] = </span><span class="type-name">StateT</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">Cache</span><span>, </span><span class="type-name">A</span><span>]

</span><span class="keyword">def</span><span> </span><span class="declaration-name">transform</span><span>(</span><span class="identifier">interp</span><span>: </span><span class="type-name">KVStore</span><span>[</span><span class="type-name">F</span><span>]): </span><span class="type-name">KVStore</span><span>[</span><span class="type-name">CachedAction</span><span>] = </span><span class="keyword">new</span><span> </span><span class="type-name">KVStore</span><span>[</span><span class="type-name">CachedAction</span><span>] {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">put</span><span>(</span><span class="identifier">key</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">v</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">CachedAction</span><span>[</span><span class="type-name">Unit</span><span>] =
    </span><span class="type-name">StateT</span><span>.</span><span class="identifier">liftF</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">Cache</span><span>, </span><span class="type-name">Unit</span><span>](</span><span class="identifier">interp</span><span>.</span><span class="identifier">put</span><span>(</span><span class="identifier">key</span><span>, </span><span class="identifier">v</span><span>)) *&gt; </span><span class="type-name">StateT</span><span>.</span><span class="identifier">modify</span><span>(</span><span class="identifier">_</span><span>.</span><span class="identifier">updated</span><span>(</span><span class="identifier">key</span><span>, </span><span class="identifier">v</span><span>))

  </span><span class="keyword">def</span><span> </span><span class="declaration-name">get</span><span>(</span><span class="identifier">key</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">CachedAction</span><span>[</span><span class="type-name">Option</span><span>[</span><span class="type-name">String</span><span>]] = ???
}</span></code></pre>
    <p>So far, so good, now let&#39;s have a look at what to do with the <code>get</code> function.
    It&#39;s a bit more complex, because we want to read from the cache, as well as write to it if the cache didn&#39;t include our key.
    What we have to do is, get our current state, then check if the key is included, if so, just return it, otherwise call the interpreter to perform the <code>get</code> action and then write that into the cache.</p>
    <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">get</span><span>(</span><span class="identifier">key</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">CachedAction</span><span>[</span><span class="type-name">Option</span><span>[</span><span class="type-name">String</span><span>]] = </span><span class="keyword">for</span><span> {
  </span><span class="identifier">cache</span><span> &lt;- </span><span class="type-name">StateT</span><span>.</span><span class="identifier">get</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">Cache</span><span>]
  </span><span class="identifier">result</span><span> &lt;- </span><span class="identifier">cache</span><span>.</span><span class="identifier">get</span><span>(</span><span class="identifier">key</span><span>) </span><span class="keyword">match</span><span> {
              </span><span class="keyword">case</span><span> </span><span class="identifier">s</span><span> @ </span><span class="type-name">Some</span><span>(</span><span class="identifier">_</span><span>) =&gt; </span><span class="identifier">s</span><span>.</span><span class="identifier">pure</span><span>[</span><span class="type-name">CachedAction</span><span>]
              </span><span class="keyword">case</span><span> </span><span class="type-name">None</span><span> =&gt; </span><span class="type-name">StateT</span><span>.</span><span class="identifier">liftF</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">Cache</span><span>, </span><span class="type-name">Option</span><span>[</span><span class="type-name">String</span><span>]](</span><span class="identifier">interp</span><span>.</span><span class="identifier">get</span><span>(</span><span class="identifier">key</span><span>))
                             .</span><span class="identifier">flatTap</span><span>(</span><span class="identifier">updateCache</span><span>(</span><span class="identifier">key</span><span>))
            }
} </span><span class="keyword">yield</span><span> </span><span class="identifier">result</span><span>

</span><span class="keyword">def</span><span> </span><span class="declaration-name">updateCache</span><span>(</span><span class="identifier">key</span><span>: </span><span class="type-name">String</span><span>)(</span><span class="identifier">ov</span><span>: </span><span class="type-name">Option</span><span>[</span><span class="type-name">String</span><span>]): </span><span class="type-name">CachedAction</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="identifier">ov</span><span> </span><span class="keyword">match</span><span> {
  </span><span class="keyword">case</span><span> </span><span class="type-name">Some</span><span>(</span><span class="identifier">v</span><span>) =&gt; </span><span class="type-name">StateT</span><span>.</span><span class="identifier">modify</span><span>(</span><span class="identifier">_</span><span>.</span><span class="identifier">updated</span><span>(</span><span class="identifier">key</span><span>, </span><span class="identifier">v</span><span>))
  </span><span class="keyword">case</span><span> </span><span class="type-name">None</span><span> =&gt; ().</span><span class="identifier">pure</span><span>[</span><span class="type-name">CachedAction</span><span>]
}</span></code></pre>
    <p>This is quite something, so let&#39;s try to walk through it step by step.
    First we get the cache using <code>StateT.get</code>, so far so good.
    Now, we check if the key is in the cache using <code>cache.get(key)</code>.
    The result of that is an <code>Option[String]</code>, which we can pattern match to see if it did include the key.
    If it did, then we can just return that <code>Option[String]</code> by lifting it into <code>CachedAction</code> using <code>pure</code>.
    If it wasn&#39;t in the cache, things are a bit more tricky.
    First, we lift the interpreter action into <code>CachedAction</code> using <code>StateT.liftF</code>, that gives us a <code>CachedAction[Option[String]]</code>, which is already the return type we need and we could return it right there, but we still need to update the cache.
    Because we already have the return type we need, we can use the <code>flatTap</code> combinator.
    Then inside the <code>updateCache</code> function, we take the result of our interpreter, which is again an <code>Option[String]</code>, and update the cache if the value is present.
    If it&#39;s empty, we don&#39;t want to do anything at all, so we just lift unit into <code>CachedAction</code>.</p>
    <p>In case you&#39;re wondering <code>flatTap</code> works just like <code>flatMap</code>, but will then <code>map</code> the result type back to the original one, making it a bit similar to a monadic version of the left shark (<code>&lt;*</code>) operator, making it very useful for these &quot;fire-and-forget&quot; operations.
    It&#39;s defined like this:</p>
    <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">flatTap</span><span>[</span><span class="type-name">F</span><span>[</span><span class="identifier">_</span><span>]: </span><span class="type-name">Monad</span><span>, </span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>](</span><span class="identifier">fa</span><span>: </span><span class="type-name">F</span><span>[</span><span class="type-name">A</span><span>])(</span><span class="identifier">f</span><span>: </span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">F</span><span>[</span><span class="type-name">B</span><span>]): </span><span class="type-name">F</span><span>[</span><span class="type-name">A</span><span>] =
  </span><span class="identifier">fa</span><span>.</span><span class="identifier">flatMap</span><span>(</span><span class="identifier">a</span><span> =&gt; </span><span class="identifier">f</span><span>(</span><span class="identifier">a</span><span>).</span><span class="identifier">map</span><span>(</span><span class="identifier">b</span><span> =&gt; </span><span class="identifier">a</span><span>))</span></code></pre>
    <p>And with that we now have a working function to turn any interpreter into an optimized interpreter.
    We can also generalize this fairly easily into a function that will do all of the wiring for us.
    To do so, we&#39;ll generalize away from <code>KVStore</code> and <code>Cache</code> and instead use generic <code>Alg[_[_]]</code> and <code>M</code> parameters:</p>
    <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">optimize</span><span>[</span><span class="type-name">Alg</span><span>[</span><span class="identifier">_</span><span>[</span><span class="identifier">_</span><span>]], </span><span class="type-name">F</span><span>[</span><span class="identifier">_</span><span>]: </span><span class="type-name">Monad</span><span>, </span><span class="type-name">M</span><span>: </span><span class="type-name">Monoid</span><span>, </span><span class="type-name">A</span><span>]
  (</span><span class="identifier">program</span><span>: </span><span class="type-name">MonadProgram</span><span>[</span><span class="type-name">Alg</span><span>, </span><span class="type-name">A</span><span>])
  (</span><span class="identifier">withState</span><span>: </span><span class="type-name">Alg</span><span>[</span><span class="type-name">F</span><span>] =&gt; </span><span class="type-name">Alg</span><span>[</span><span class="type-name">StateT</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">M</span><span>, ?]]): </span><span class="type-name">Alg</span><span>[</span><span class="type-name">F</span><span>] =&gt; </span><span class="type-name">F</span><span>[</span><span class="type-name">A</span><span>] = </span><span class="identifier">interpreter</span><span> =&gt;
    </span><span class="identifier">program</span><span>(</span><span class="identifier">withState</span><span>(</span><span class="identifier">interpreter</span><span>)).</span><span class="identifier">runEmptyA</span></code></pre>
    <p>Just like last time, we have to use a <code>MonadProgram</code> wrapper around <code>Alg[F] =&gt; F[A]</code>, because Scala lacks rank-N types which would allow us to define values that work over ALL type constructors <code>F[_]: Monad</code> (Fortunately however, this will very probably soon be fixed in dotty, PR <a href="https://github.com/lampepfl/dotty/pull/4672">here</a>).</p>
    <p>Now let&#39;s see if we can actually use it, by checking it with a test interpreter that will print whenever we retrieve or insert values into the <code>KVStore</code>.</p>
    <pre><code class="nohighlight"><span class="identifier">optimize</span><span>[</span><span class="type-name">KVStore</span><span>, </span><span class="type-name">IO</span><span>, </span><span class="type-name">Cache</span><span>, </span><span class="type-name">List</span><span>[</span><span class="type-name">String</span><span>]](</span><span class="identifier">program</span><span>(</span><span class="string-literal">&quot;mouse&quot;</span><span>))(</span><span class="identifier">transform</span><span>)
  .</span><span class="identifier">apply</span><span>(</span><span class="identifier">printInterpreter</span><span>)
  .</span><span class="identifier">unsafeRunSync</span><span>()

</span><span class="comment">// Put key: mouse, value: cat
// Get key: cat</span></code></pre>
    <p>It works and does exactly what we want! 
    Nice! We could end this blog post right here, but there&#39;s still a couple of things I&#39;d like to slightly alter.</p>
    
    <h3 id="refining-the-api" class="section"><a class="anchor-link" href="#refining-the-api"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc. --><path fill="currentColor" d="M419.5 96c-16.6 0-32.7 4.5-46.8 12.7-15.8-16-34.2-29.4-54.5-39.5 28.2-24 64.1-37.2 101.3-37.2 86.4 0 156.5 70 156.5 156.5 0 41.5-16.5 81.3-45.8 110.6l-71.1 71.1c-29.3 29.3-69.1 45.8-110.6 45.8-86.4 0-156.5-70-156.5-156.5 0-1.5 0-3 .1-4.5 .5-17.7 15.2-31.6 32.9-31.1s31.6 15.2 31.1 32.9c0 .9 0 1.8 0 2.6 0 51.1 41.4 92.5 92.5 92.5 24.5 0 48-9.7 65.4-27.1l71.1-71.1c17.3-17.3 27.1-40.9 27.1-65.4 0-51.1-41.4-92.5-92.5-92.5zM275.2 173.3c-1.9-.8-3.8-1.9-5.5-3.1-12.6-6.5-27-10.2-42.1-10.2-24.5 0-48 9.7-65.4 27.1L91.1 258.2c-17.3 17.3-27.1 40.9-27.1 65.4 0 51.1 41.4 92.5 92.5 92.5 16.5 0 32.6-4.4 46.7-12.6 15.8 16 34.2 29.4 54.6 39.5-28.2 23.9-64 37.2-101.3 37.2-86.4 0-156.5-70-156.5-156.5 0-41.5 16.5-81.3 45.8-110.6l71.1-71.1c29.3-29.3 69.1-45.8 110.6-45.8 86.6 0 156.5 70.6 156.5 156.9 0 1.3 0 2.6 0 3.9-.4 17.7-15.1 31.6-32.8 31.2s-31.6-15.1-31.2-32.8c0-.8 0-1.5 0-2.3 0-33.7-18-63.3-44.8-79.6z"/></svg></a>Refining the API</h3>
    <p>As you were able to tell the implementation of our transformation from the standard interpreter to the optimized interpreter is already quite complex and that is for a very very simple algebra that doesn&#39;t do a lot.
    Even then, I initially wrote an implementation that packs everything in a single <code>StateT</code> constructor to avoid the overhead of multiple calls to <code>flatMap</code>, but considered the version I showed here more easily understandable.
    For more involved algebras and more complex programs, all of this will become a lot more difficult to manage.
    In our last blog post we were able to clearly separate the extraction of our information from the rebuilding of our interpreter with that information.
    Let&#39;s have a look at if we can do the same thing here.</p>
    <p>First we&#39;ll want to define an extraction method.
    For applicative programs we used <code>Const[M, ?]</code>, however that cannot work here, as <code>Const</code> doesn&#39;t have a <code>Monad</code> instance and also, because for extraction with monadic programs, we need to actually take the result of the computation into account. 
    That means, that for every operation in our algebra, we want a way to turn it into our monoid <code>M</code>.
    With that said, it seems we want a function <code>A =&gt; M</code>, where <code>A</code> is the result type of the operations in our algebra.
    So what we can do here is define an algebra for <code>? =&gt; M</code>, in types an <code>Alg[? =&gt; M]</code>.</p>
    <p>Let&#39;s try to do define such an interpreter for our <code>KVStore</code> along with <code>Cache</code>/<code>Map[String, String</code>:</p>
    <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">extract</span><span>: </span><span class="type-name">KVStore</span><span>[? =&gt; </span><span class="type-name">Cache</span><span>] = </span><span class="keyword">new</span><span> </span><span class="type-name">KVStore</span><span>[? =&gt; </span><span class="type-name">Cache</span><span>] {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">get</span><span>(</span><span class="identifier">key</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">Option</span><span>[</span><span class="type-name">String</span><span>] =&gt; </span><span class="type-name">Cache</span><span> = {
    </span><span class="keyword">case</span><span> </span><span class="type-name">Some</span><span>(</span><span class="identifier">s</span><span>) =&gt; </span><span class="type-name">Map</span><span>(</span><span class="identifier">key</span><span> -&gt; </span><span class="identifier">s</span><span>)
    </span><span class="keyword">case</span><span> </span><span class="type-name">None</span><span> =&gt; </span><span class="type-name">Map</span><span>.</span><span class="identifier">empty</span><span>
  }

  </span><span class="keyword">def</span><span> </span><span class="declaration-name">put</span><span>(</span><span class="identifier">key</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">a</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">Unit</span><span> =&gt; </span><span class="type-name">Cache</span><span> =
    </span><span class="identifier">_</span><span> =&gt; </span><span class="type-name">Map</span><span>(</span><span class="identifier">key</span><span> -&gt; </span><span class="identifier">a</span><span>)
}</span></code></pre>
    <p>Just as before we want to extract the cache piece by piece with every monadic step.
    Whenever we get an <code>Option[String]</code> after using <code>get</code>, we can then turn that into a <code>Cache</code> if it&#39;s non-empty.
    The same goes for <code>put</code>, where we&#39;ll create a Map using the key-value pair.
    We now have a way to turn the results of our algebra operations into our information <code>M</code>, so far so good!</p>
    <p>Next, we&#39;ll need a way to rebuild our operations using that extracted information.
    For that, let&#39;s consider what that actually means.
    For applicative programs this meant a function that given a state <code>M</code> and an interpreter <code>Alg[F]</code>, gave a  reconstructed interpreter inside the <code>F</code> context <code>F[Alg[F]]</code>.
    So a function <code>(M, Alg[F]) =&gt; F[Alg[F]]</code>.</p>
    <p>For monadic programs, there&#39;s no need to precompute any values, as we&#39;re dealing with fully sequential computations that can potentially update the state after every evaluation.
    So we&#39;re left with a function <code>(M, Alg[F]) =&gt; Alg[F]</code>.
    Let&#39;s try building that for <code>KVStore</code>:</p>
    <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">rebuild</span><span>(</span><span class="identifier">m</span><span>: </span><span class="type-name">M</span><span>, </span><span class="identifier">interp</span><span>: </span><span class="type-name">KVStore</span><span>[</span><span class="type-name">F</span><span>]): </span><span class="type-name">KVStore</span><span>[</span><span class="type-name">F</span><span>] = </span><span class="keyword">new</span><span> </span><span class="type-name">KVStore</span><span>[</span><span class="type-name">F</span><span>] {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">get</span><span>(</span><span class="identifier">key</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">F</span><span>[</span><span class="type-name">Option</span><span>[</span><span class="type-name">String</span><span>]] = </span><span class="identifier">m</span><span>.</span><span class="identifier">get</span><span>(</span><span class="identifier">key</span><span>) </span><span class="keyword">match</span><span> {
    </span><span class="keyword">case</span><span> </span><span class="identifier">o</span><span> @ </span><span class="type-name">Some</span><span>(</span><span class="identifier">_</span><span>) =&gt; </span><span class="type-name">Monad</span><span>[</span><span class="type-name">F</span><span>].</span><span class="identifier">pure</span><span>(</span><span class="identifier">o</span><span>)
    </span><span class="keyword">case</span><span> </span><span class="type-name">None</span><span> =&gt; </span><span class="identifier">interp</span><span>.</span><span class="identifier">get</span><span>(</span><span class="identifier">key</span><span>)
  }

  </span><span class="keyword">def</span><span> </span><span class="declaration-name">put</span><span>(</span><span class="identifier">key</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">a</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">F</span><span>[</span><span class="type-name">Unit</span><span>] =
    </span><span class="identifier">m</span><span> =&gt; </span><span class="identifier">interp</span><span>.</span><span class="identifier">put</span><span>(</span><span class="identifier">key</span><span>, </span><span class="identifier">a</span><span>)
}</span></code></pre>
    <p>Easy enough!
    For <code>get</code> we look inside our cache and use the value if it&#39;s there, otherwise we call the original interpreter to do its job.
    For <code>put</code>, there&#39;s nothing to gain from having access to our extracted information and the only thing we can do is call the interpreter and let it do what needs to be done.</p>
    <p>Now we have a way to extract information and then also use that information, next up is finding a way to wire these two things together to get back to the behaviour we got using <code>StateT</code>.</p>
    <p>And as a matter of fact, we&#39;ll wire them back together using exactly <code>StateT</code>, as it&#39;s monad instance does do exactly what we want.</p>
    <p>Using our two functions <code>extract</code> and <code>rebuild</code> it&#39;s fairly easy to get back to <code>KVStore[StateT[F, Cache, ?]]</code>:</p>
    <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">transform</span><span>(</span><span class="identifier">interp</span><span>: </span><span class="type-name">KVStore</span><span>[</span><span class="type-name">F</span><span>]): </span><span class="type-name">KVStore</span><span>[</span><span class="type-name">StateT</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">Cache</span><span>, ?]] = </span><span class="keyword">new</span><span> </span><span class="type-name">KVStore</span><span>[</span><span class="type-name">StateT</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">Cache</span><span>, ?]] {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">put</span><span>(</span><span class="identifier">key</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">v</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">StateT</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">Cache</span><span>, </span><span class="type-name">Unit</span><span>] =
    </span><span class="type-name">StateT</span><span>(</span><span class="identifier">cache</span><span> =&gt; </span><span class="identifier">rebuild</span><span>(</span><span class="identifier">cache</span><span>, </span><span class="identifier">interp</span><span>).</span><span class="identifier">put</span><span>(</span><span class="identifier">key</span><span>, </span><span class="identifier">v</span><span>).</span><span class="identifier">map</span><span>(</span><span class="identifier">a</span><span> =&gt; 
      (</span><span class="identifier">cache</span><span> |+|&nbsp;</span><span class="identifier">extract</span><span>.</span><span class="identifier">put</span><span>(</span><span class="identifier">key</span><span>, </span><span class="identifier">v</span><span>)) -&gt; </span><span class="identifier">a</span><span>))

  </span><span class="keyword">def</span><span> </span><span class="declaration-name">get</span><span>(</span><span class="identifier">key</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">StateT</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">Cache</span><span>, </span><span class="type-name">Option</span><span>[</span><span class="type-name">String</span><span>]] =
    </span><span class="type-name">StateT</span><span>(</span><span class="identifier">cache</span><span> =&gt; </span><span class="identifier">rebuild</span><span>(</span><span class="identifier">cache</span><span>, </span><span class="identifier">interp</span><span>).</span><span class="identifier">get</span><span>(</span><span class="identifier">key</span><span>).</span><span class="identifier">map</span><span>(</span><span class="identifier">a</span><span> =&gt; 
      (</span><span class="identifier">cache</span><span> |+|&nbsp;</span><span class="identifier">extract</span><span>.</span><span class="identifier">get</span><span>(</span><span class="identifier">key</span><span>)) -&gt; </span><span class="identifier">a</span><span>))
}</span></code></pre>
    <p>This is fairly straightforward, we use rebuild with our cache and the interpreter to get a new interpreter that will run the operation.
    Then, we use the result, which is just an <code>F[Unit]</code>/<code>F[Option[String]]</code> respectively, and map it 
      using the extractor to get the newest <code>Cache</code> and using its <code>Monoid</code> instance to update the state and then we tuple it with the result, giving us an <code>F[(Cache, Unit)]</code> or <code>F[(Cache, Option[String])]</code>, which is exactly what the <code>StateT</code> constructor needs. </p>
    <p>This is great, but can we generalize this to any algebra and any monoid?</p>
    <p>The answer is yes, but it&#39;s not exactly easy.
    First let&#39;s look at the actual problem.
    We have two interpreters <code>extract</code> and <code>rebuild</code>, but we have no way to combine them, because <code>Alg</code>, is completely unconstrained and that means we can&#39;t call any functions on a generic <code>Alg[F]</code> at all.
    So, okay, we need to constrain our <code>Alg</code> parameter to be able to combine values of <code>Alg[F]</code> with values of <code>Alg[G]</code> in some way, but what kind of type class could that be?
    Are there even type classes that operate on the kind of <code>Alg</code>? </p>
    
    <h3 id="higher-kinded-things" class="section"><a class="anchor-link" href="#higher-kinded-things"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc. --><path fill="currentColor" d="M419.5 96c-16.6 0-32.7 4.5-46.8 12.7-15.8-16-34.2-29.4-54.5-39.5 28.2-24 64.1-37.2 101.3-37.2 86.4 0 156.5 70 156.5 156.5 0 41.5-16.5 81.3-45.8 110.6l-71.1 71.1c-29.3 29.3-69.1 45.8-110.6 45.8-86.4 0-156.5-70-156.5-156.5 0-1.5 0-3 .1-4.5 .5-17.7 15.2-31.6 32.9-31.1s31.6 15.2 31.1 32.9c0 .9 0 1.8 0 2.6 0 51.1 41.4 92.5 92.5 92.5 24.5 0 48-9.7 65.4-27.1l71.1-71.1c17.3-17.3 27.1-40.9 27.1-65.4 0-51.1-41.4-92.5-92.5-92.5zM275.2 173.3c-1.9-.8-3.8-1.9-5.5-3.1-12.6-6.5-27-10.2-42.1-10.2-24.5 0-48 9.7-65.4 27.1L91.1 258.2c-17.3 17.3-27.1 40.9-27.1 65.4 0 51.1 41.4 92.5 92.5 92.5 16.5 0 32.6-4.4 46.7-12.6 15.8 16 34.2 29.4 54.6 39.5-28.2 23.9-64 37.2-101.3 37.2-86.4 0-156.5-70-156.5-156.5 0-41.5 16.5-81.3 45.8-110.6l71.1-71.1c29.3-29.3 69.1-45.8 110.6-45.8 86.6 0 156.5 70.6 156.5 156.9 0 1.3 0 2.6 0 3.9-.4 17.7-15.1 31.6-32.8 31.2s-31.6-15.1-31.2-32.8c0-.8 0-1.5 0-2.3 0-33.7-18-63.3-44.8-79.6z"/></svg></a>Higher kinded things</h3>
    <p>There are, they&#39;re just hidden away in a small library called <code>Mainecoon</code>.
    That library gives us higher kinded versions of things like functors and contravariant functors, called <code>FunctorK</code> and <code>ContravariantK</code> respectively.</p>
    <p>Let&#39;s have a quick look at <code>FunctorK</code>:</p>
    <pre><code class="nohighlight"><span class="annotation">@typeclass</span><span>
</span><span class="keyword">trait</span><span> </span><span class="type-name">FunctorK</span><span>[</span><span class="type-name">A</span><span>[</span><span class="identifier">_</span><span>[</span><span class="identifier">_</span><span>]]] {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">mapK</span><span>[</span><span class="type-name">F</span><span>[</span><span class="identifier">_</span><span>], </span><span class="type-name">G</span><span>[</span><span class="identifier">_</span><span>]](</span><span class="identifier">af</span><span>: </span><span class="type-name">A</span><span>[</span><span class="type-name">F</span><span>])(</span><span class="identifier">f</span><span>: </span><span class="type-name">F</span><span> ~&gt; </span><span class="type-name">G</span><span>): </span><span class="type-name">A</span><span>[</span><span class="type-name">G</span><span>]
}</span></code></pre>
    <p>Instead of mapping over type constructors <code>F[_]</code>, we map over algebras <code>A[_[_]]</code> and insteading of using functions <code>A =&gt; B</code>, we use natural transformations <code>F ~&gt; G</code>.
    This is nice, but doesn&#39;t really get us that far. </p>
    <p>What we really need is the equivalent of the <code>Applicative</code>/<code>Apply</code> <code>map2</code> operation.
    <code>map2</code> looks like this:</p>
    <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">map2</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>, </span><span class="type-name">C</span><span>](</span><span class="identifier">fa</span><span>: </span><span class="type-name">F</span><span>[</span><span class="type-name">A</span><span>], </span><span class="identifier">fb</span><span>: </span><span class="type-name">F</span><span>[</span><span class="type-name">B</span><span>])(</span><span class="identifier">f</span><span>: (</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>) =&gt; </span><span class="type-name">C</span><span>): </span><span class="type-name">F</span><span>[</span><span class="type-name">C</span><span>]</span></code></pre>
    <p>And a higher kinded version would look like this:</p>
    <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">map2K</span><span>[</span><span class="type-name">F</span><span>[</span><span class="identifier">_</span><span>], </span><span class="type-name">G</span><span>[</span><span class="identifier">_</span><span>], </span><span class="type-name">H</span><span>[</span><span class="identifier">_</span><span>]](</span><span class="identifier">af</span><span>: </span><span class="type-name">A</span><span>[</span><span class="type-name">F</span><span>], </span><span class="identifier">ag</span><span>: </span><span class="type-name">A</span><span>[</span><span class="type-name">G</span><span>])(</span><span class="identifier">f</span><span>: </span><span class="type-name">Tuple2K</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">G</span><span>, ?] ~&gt; </span><span class="type-name">H</span><span>): </span><span class="type-name">A</span><span>[</span><span class="type-name">H</span><span>]</span></code></pre>
    <p>If you haven&#39;t guessed yet <code>Tuple2K</code> is just a higher kinded version of <code>Tuple2</code>:</p>
    <pre><code class="nohighlight"><span class="keyword">type</span><span> </span><span class="type-name">Tuple2K</span><span>[</span><span class="type-name">F</span><span>[</span><span class="identifier">_</span><span>], </span><span class="type-name">G</span><span>[</span><span class="identifier">_</span><span>], </span><span class="type-name">A</span><span>] = (</span><span class="type-name">F</span><span>[</span><span class="type-name">A</span><span>], </span><span class="type-name">G</span><span>[</span><span class="type-name">A</span><span>])</span></code></pre>
    <p>Unfortunately <code>Mainecoon</code> doesn&#39;t have an <code>ApplyK</code> type class that gives us this <code>map2K</code> operation, but it gives the next best thing! 
    A higher-kinded <code>Semigroupal</code>, which when combined with the higher kinded <code>Functor</code> gives us that higher kinded <code>Apply</code> type class.
    It&#39;s called <code>CartesianK</code> (because cats <code>Semigroupal</code> used to be called <code>Cartesian</code>, but is renamed to <code>SemigroupalK</code> in the next version) and looks like this:</p>
    <pre><code class="nohighlight"><span class="annotation">@typeclass</span><span> 
</span><span class="keyword">trait</span><span> </span><span class="type-name">CartesianK</span><span>[</span><span class="type-name">A</span><span>[</span><span class="identifier">_</span><span>[</span><span class="identifier">_</span><span>]]] {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">productK</span><span>[</span><span class="type-name">F</span><span>[</span><span class="identifier">_</span><span>], </span><span class="type-name">G</span><span>[</span><span class="identifier">_</span><span>]](</span><span class="identifier">af</span><span>: </span><span class="type-name">A</span><span>[</span><span class="type-name">F</span><span>], </span><span class="identifier">ag</span><span>: </span><span class="type-name">A</span><span>[</span><span class="type-name">G</span><span>]): </span><span class="type-name">A</span><span>[</span><span class="type-name">Tuple2K</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">G</span><span>, ?]]
}</span></code></pre>
    <p>Now just like you can define <code>map2</code> using <code>map</code> and <code>product</code> we can do the same for <code>map2K</code>:</p>
    <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">map2K</span><span>[</span><span class="type-name">F</span><span>[</span><span class="identifier">_</span><span>], </span><span class="type-name">G</span><span>[</span><span class="identifier">_</span><span>], </span><span class="type-name">H</span><span>[</span><span class="identifier">_</span><span>]](</span><span class="identifier">af</span><span>: </span><span class="type-name">A</span><span>[</span><span class="type-name">F</span><span>], </span><span class="identifier">ag</span><span>: </span><span class="type-name">A</span><span>[</span><span class="type-name">G</span><span>])(</span><span class="identifier">f</span><span>: </span><span class="type-name">Tuple2K</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">G</span><span>, ?] ~&gt; </span><span class="type-name">H</span><span>): </span><span class="type-name">A</span><span>[</span><span class="type-name">H</span><span>] =
  </span><span class="identifier">productK</span><span>(</span><span class="identifier">af</span><span>, </span><span class="identifier">ag</span><span>).</span><span class="identifier">mapK</span><span>(</span><span class="identifier">f</span><span>)</span></code></pre>
    
    <h3 id="putting-it-all-together" class="section"><a class="anchor-link" href="#putting-it-all-together"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc. --><path fill="currentColor" d="M419.5 96c-16.6 0-32.7 4.5-46.8 12.7-15.8-16-34.2-29.4-54.5-39.5 28.2-24 64.1-37.2 101.3-37.2 86.4 0 156.5 70 156.5 156.5 0 41.5-16.5 81.3-45.8 110.6l-71.1 71.1c-29.3 29.3-69.1 45.8-110.6 45.8-86.4 0-156.5-70-156.5-156.5 0-1.5 0-3 .1-4.5 .5-17.7 15.2-31.6 32.9-31.1s31.6 15.2 31.1 32.9c0 .9 0 1.8 0 2.6 0 51.1 41.4 92.5 92.5 92.5 24.5 0 48-9.7 65.4-27.1l71.1-71.1c17.3-17.3 27.1-40.9 27.1-65.4 0-51.1-41.4-92.5-92.5-92.5zM275.2 173.3c-1.9-.8-3.8-1.9-5.5-3.1-12.6-6.5-27-10.2-42.1-10.2-24.5 0-48 9.7-65.4 27.1L91.1 258.2c-17.3 17.3-27.1 40.9-27.1 65.4 0 51.1 41.4 92.5 92.5 92.5 16.5 0 32.6-4.4 46.7-12.6 15.8 16 34.2 29.4 54.6 39.5-28.2 23.9-64 37.2-101.3 37.2-86.4 0-156.5-70-156.5-156.5 0-41.5 16.5-81.3 45.8-110.6l71.1-71.1c29.3-29.3 69.1-45.8 110.6-45.8 86.6 0 156.5 70.6 156.5 156.9 0 1.3 0 2.6 0 3.9-.4 17.7-15.1 31.6-32.8 31.2s-31.6-15.1-31.2-32.8c0-.8 0-1.5 0-2.3 0-33.7-18-63.3-44.8-79.6z"/></svg></a>Putting it all together</h3>
    <p>Okay, after that quick detour, let&#39;s have a look at how can make use of these type classes.</p>
    <p>If we look at what we have and how we&#39;d like to use the <code>map2K</code> function, we can infer the rest that we need quite easily.</p>
    <p>We have an <code>Alg[F]</code> and a <code>Alg[? =&gt; M]</code>, and we want an <code>Alg[StateT[F, M, ?]]</code>, so given those two as the inputs to <code>map2K</code>, all that seems to be missing is the natural transformation <code>Tuple2K[F, ? =&gt; M, ?] ~&gt; StateT[F, M, ?]</code>.
    Nice! As so often, the types guide us and show us the way.</p>
    <p>Well let&#39;s try to define just that:</p>
    <pre><code class="nohighlight"><span class="keyword">new</span><span> (</span><span class="type-name">Tuple2K</span><span>[</span><span class="type-name">F</span><span>, ? =&gt; </span><span class="type-name">M</span><span>, ?] ~&gt; </span><span class="type-name">StateT</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">M</span><span>, ?]) {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">fa</span><span>: </span><span class="type-name">Tuple2K</span><span>[</span><span class="type-name">F</span><span>, ? =&gt; </span><span class="type-name">M</span><span>, ?]): </span><span class="type-name">StateT</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">M</span><span>, </span><span class="type-name">A</span><span>] =
    </span><span class="type-name">StateT</span><span>(</span><span class="identifier">m</span><span> =&gt; </span><span class="type-name">F</span><span>.</span><span class="identifier">map</span><span>(</span><span class="identifier">fa</span><span>.</span><span class="identifier">first</span><span>)(</span><span class="identifier">a</span><span> =&gt; </span><span class="type-name">M</span><span>.</span><span class="identifier">combine</span><span>(</span><span class="identifier">fa</span><span>.</span><span class="identifier">second</span><span>(</span><span class="identifier">a</span><span>), </span><span class="identifier">m</span><span>) -&gt; </span><span class="identifier">a</span><span>))
}</span></code></pre>
    <p>This looks good, but actually has a problem, to get an <code>Alg[F]</code> from <code>rebuild</code> we give it an <code>M</code> and an interpreter <code>Alg[F]</code>. 
    The interpreter isn&#39;t really a problem, but the <code>M</code> can prove problematic as we need to give it to the <code>rebuild</code> function after each monadic step to always receive the latest state.
    If we look at our natural transformation above, that function will never receive the newest state.
    So what can we do about this?
    Well, we could be a bit more honest about our types:</p>
    <pre><code class="nohighlight"><span class="keyword">type</span><span> </span><span class="type-name">FunctionM</span><span>[</span><span class="type-name">A</span><span>] = </span><span class="type-name">M</span><span> =&gt; </span><span class="type-name">F</span><span>[</span><span class="type-name">A</span><span>]
</span><span class="keyword">def</span><span> </span><span class="declaration-name">rebuild</span><span>(</span><span class="identifier">interp</span><span>: </span><span class="type-name">Alg</span><span>[</span><span class="type-name">F</span><span>]): </span><span class="type-name">Alg</span><span>[</span><span class="type-name">FunctionM</span><span>]</span></code></pre>
    <p>Hey, now we&#39;re getting there. This works, but if we look into some of the data types provided by <code>Cats</code> we can acutally see that this is just <code>Kleisli</code> or <code>ReaderT</code>, so our <code>rebuild</code> should actually look like this:</p>
    <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">rebuild</span><span>(</span><span class="identifier">interp</span><span>: </span><span class="type-name">Alg</span><span>[</span><span class="type-name">F</span><span>]): </span><span class="type-name">Alg</span><span>[</span><span class="type-name">Kleisli</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">M</span><span>, ?]]</span></code></pre>
    <p>And now, we can easily implement a correct version of that natural transformation from earlier:</p>
    <pre><code class="nohighlight"><span class="keyword">new</span><span> (</span><span class="type-name">Tuple2K</span><span>[</span><span class="type-name">Kleisli</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">M</span><span>, ?], ? =&gt; </span><span class="type-name">M</span><span>, ?] ~&gt; </span><span class="type-name">StateT</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">M</span><span>, ?]) {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">fa</span><span>: </span><span class="type-name">Tuple2K</span><span>[</span><span class="type-name">Kleisli</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">M</span><span>, </span><span class="type-name">A</span><span>], ? =&gt; </span><span class="type-name">M</span><span>, ?]): </span><span class="type-name">StateT</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">M</span><span>, </span><span class="type-name">A</span><span>] =
    </span><span class="type-name">StateT</span><span>(</span><span class="identifier">m</span><span> =&gt; </span><span class="type-name">F</span><span>.</span><span class="identifier">map</span><span>(</span><span class="identifier">fa</span><span>.</span><span class="identifier">first</span><span>.</span><span class="identifier">run</span><span>(</span><span class="identifier">m</span><span>))(</span><span class="identifier">a</span><span> =&gt; (</span><span class="identifier">fa</span><span>.</span><span class="identifier">second</span><span>(</span><span class="identifier">a</span><span>) |+| </span><span class="identifier">m</span><span>) -&gt; </span><span class="identifier">a</span><span>))
}</span></code></pre>
    <p>Cool, then let us also adjust the rebuild function we created for <code>KVStore</code>:</p>
    <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">rebuild</span><span>(</span><span class="identifier">interp</span><span>: </span><span class="type-name">KVStore</span><span>[</span><span class="type-name">F</span><span>]): </span><span class="type-name">KVStore</span><span>[</span><span class="type-name">Kleisli</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">M</span><span>, ?]] = </span><span class="keyword">new</span><span> </span><span class="type-name">KVStore</span><span>[</span><span class="type-name">Kleisli</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">M</span><span>, ?]] {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">get</span><span>(</span><span class="identifier">key</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">Kleisli</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">Cache</span><span>, </span><span class="type-name">Option</span><span>[</span><span class="type-name">String</span><span>]] = </span><span class="type-name">Kleisli</span><span>(</span><span class="identifier">m</span><span> =&gt; </span><span class="identifier">m</span><span>.</span><span class="identifier">get</span><span>(</span><span class="identifier">key</span><span>) </span><span class="keyword">match</span><span> {
    </span><span class="keyword">case</span><span> </span><span class="identifier">o</span><span> @ </span><span class="type-name">Some</span><span>(</span><span class="identifier">_</span><span>) =&gt; </span><span class="type-name">Monad</span><span>[</span><span class="type-name">F</span><span>].</span><span class="identifier">pure</span><span>(</span><span class="identifier">o</span><span>)
    </span><span class="keyword">case</span><span> </span><span class="type-name">None</span><span> =&gt; </span><span class="identifier">interp</span><span>.</span><span class="identifier">get</span><span>(</span><span class="identifier">key</span><span>)
  })

  </span><span class="keyword">def</span><span> </span><span class="declaration-name">put</span><span>(</span><span class="identifier">key</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">a</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">Kleisli</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">Cache</span><span>, </span><span class="type-name">Unit</span><span>] =
    </span><span class="type-name">Kleisli</span><span>(</span><span class="identifier">m</span><span> =&gt; </span><span class="identifier">interp</span><span>.</span><span class="identifier">put</span><span>(</span><span class="identifier">key</span><span>, </span><span class="identifier">a</span><span>))
}</span></code></pre>
    <p>It&#39;s stayed pretty much the same, we just needed to wrap the whole thing in a <code>Kleisli</code> and we&#39;re good!</p>
    <p>Now we can go ahead and define the full function signature:</p>
    <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">optimize</span><span>[</span><span class="type-name">Alg</span><span>[</span><span class="identifier">_</span><span>[</span><span class="identifier">_</span><span>]]: </span><span class="type-name">FunctorK</span><span>: </span><span class="type-name">CartesianK</span><span>, </span><span class="type-name">F</span><span>[</span><span class="identifier">_</span><span>]: </span><span class="type-name">Monad</span><span>, </span><span class="type-name">M</span><span>: </span><span class="type-name">Monoid</span><span>, </span><span class="type-name">A</span><span>]
  (</span><span class="identifier">program</span><span>: </span><span class="type-name">MonadProgram</span><span>[</span><span class="type-name">Alg</span><span>, </span><span class="type-name">A</span><span>])
  (</span><span class="identifier">extract</span><span>: </span><span class="type-name">Alg</span><span>[? =&gt; </span><span class="type-name">M</span><span>])
  (</span><span class="identifier">rebuild</span><span>: </span><span class="type-name">Alg</span><span>[</span><span class="type-name">F</span><span>] =&gt; </span><span class="type-name">Alg</span><span>[</span><span class="type-name">Kleisli</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">M</span><span>, ?]]): </span><span class="type-name">Alg</span><span>[</span><span class="type-name">F</span><span>] =&gt; </span><span class="type-name">F</span><span>[</span><span class="type-name">A</span><span>] = { </span><span class="identifier">interpreter</span><span> =&gt;
  
    </span><span class="keyword">val</span><span> </span><span class="identifier">tupleToState</span><span> = </span><span class="keyword">new</span><span> (</span><span class="type-name">Tuple2K</span><span>[</span><span class="type-name">Kleisli</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">M</span><span>, ?], ? =&gt; </span><span class="type-name">M</span><span>, ?] ~&gt; </span><span class="type-name">StateT</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">M</span><span>, ?]) {
      </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">fa</span><span>: </span><span class="type-name">Tuple2K</span><span>[</span><span class="type-name">Kleisli</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">M</span><span>, </span><span class="type-name">A</span><span>], ? =&gt; </span><span class="type-name">M</span><span>, </span><span class="type-name">A</span><span>]): </span><span class="type-name">StateT</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">M</span><span>, </span><span class="type-name">A</span><span>] =
        </span><span class="type-name">StateT</span><span>(</span><span class="identifier">m</span><span> =&gt; </span><span class="type-name">F</span><span>.</span><span class="identifier">map</span><span>(</span><span class="identifier">fa</span><span>.</span><span class="identifier">first</span><span>.</span><span class="identifier">run</span><span>(</span><span class="identifier">m</span><span>))(</span><span class="identifier">a</span><span> =&gt; (</span><span class="identifier">fa</span><span>.</span><span class="identifier">second</span><span>(</span><span class="identifier">a</span><span>) |+| </span><span class="identifier">m</span><span>) -&gt; </span><span class="identifier">a</span><span>))
    }

    </span><span class="keyword">val</span><span> </span><span class="identifier">withState</span><span>: </span><span class="type-name">Alg</span><span>[</span><span class="type-name">StateT</span><span>[</span><span class="type-name">F</span><span>, </span><span class="type-name">M</span><span>, ?]] =
      </span><span class="identifier">map2K</span><span>(</span><span class="identifier">extract</span><span>(</span><span class="identifier">interpreter</span><span>), </span><span class="identifier">rebuild</span><span>))(</span><span class="identifier">tupleToState</span><span>)

    </span><span class="identifier">program</span><span>(</span><span class="identifier">withState</span><span>).</span><span class="identifier">runEmptyA</span><span>
  
  }</span></code></pre>
    <p>That is all, we&#39;ve got a fully polymorphic function that can optimize monadic programs.</p>
    <p>Let&#39;s use it!</p>
    <pre><code class="nohighlight"><span class="identifier">optimize</span><span>(</span><span class="identifier">program</span><span>)(</span><span class="identifier">extract</span><span>)(</span><span class="identifier">rebuild</span><span>)
  .</span><span class="identifier">apply</span><span>(</span><span class="identifier">printInterpreter</span><span>)
  .</span><span class="identifier">unsafeRunSync</span><span>()</span></code></pre>
    <p>Now, when we run this, it should be exactly the same result as when we ran it earlier using the direct <code>StateT</code> interpreter, but the resulting code is much cleaner.
    However, it does have the drawback that you&#39;ll now need additional constraints for every algebra to use this function.
    That said though, one of the cool features of <code>Mainecoon</code> is that it comes with auto-derivation.
    Meaning we can just add an annotation to any of our algebras and it will automatically derive the <code>FunctorK</code> and <code>CartesianK</code> instances.</p>
    <p>In fact, that is exactly how I defined those two instances for the <code>KVStore</code> algebra:</p>
    <pre><code class="nohighlight"><span class="annotation">@autoFunctorK</span><span>
</span><span class="annotation">@autoCartesianK</span><span>
</span><span class="keyword">trait</span><span> </span><span class="type-name">KVStore</span><span>[</span><span class="type-name">F</span><span>[</span><span class="identifier">_</span><span>]] { ... }</span></code></pre>
    <p>This makes it fairly easy to use these extra type classes and helpts mitigate the drawbacks I mentioned.</p>
    
    <h3 id="conclusions" class="section"><a class="anchor-link" href="#conclusions"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc. --><path fill="currentColor" d="M419.5 96c-16.6 0-32.7 4.5-46.8 12.7-15.8-16-34.2-29.4-54.5-39.5 28.2-24 64.1-37.2 101.3-37.2 86.4 0 156.5 70 156.5 156.5 0 41.5-16.5 81.3-45.8 110.6l-71.1 71.1c-29.3 29.3-69.1 45.8-110.6 45.8-86.4 0-156.5-70-156.5-156.5 0-1.5 0-3 .1-4.5 .5-17.7 15.2-31.6 32.9-31.1s31.6 15.2 31.1 32.9c0 .9 0 1.8 0 2.6 0 51.1 41.4 92.5 92.5 92.5 24.5 0 48-9.7 65.4-27.1l71.1-71.1c17.3-17.3 27.1-40.9 27.1-65.4 0-51.1-41.4-92.5-92.5-92.5zM275.2 173.3c-1.9-.8-3.8-1.9-5.5-3.1-12.6-6.5-27-10.2-42.1-10.2-24.5 0-48 9.7-65.4 27.1L91.1 258.2c-17.3 17.3-27.1 40.9-27.1 65.4 0 51.1 41.4 92.5 92.5 92.5 16.5 0 32.6-4.4 46.7-12.6 15.8 16 34.2 29.4 54.6 39.5-28.2 23.9-64 37.2-101.3 37.2-86.4 0-156.5-70-156.5-156.5 0-41.5 16.5-81.3 45.8-110.6l71.1-71.1c29.3-29.3 69.1-45.8 110.6-45.8 86.6 0 156.5 70.6 156.5 156.9 0 1.3 0 2.6 0 3.9-.4 17.7-15.1 31.6-32.8 31.2s-31.6-15.1-31.2-32.8c0-.8 0-1.5 0-2.3 0-33.7-18-63.3-44.8-79.6z"/></svg></a>Conclusions</h3>
    <p>Today we&#39;ve seen a way to make optimizing monadic tagless final programs easier and intuitive, all the code is taken from the sphynx library and can be found <a href="https://github.com/LukaJCB/sphynx">right here</a>, but might still be subject to change, because designing a good API is hard.</p>
    <p>What do you think about this optimization scheme? Maybe you just prefer using <code>StateT</code> and being done with it, or maybe you like to use a typeclass based approach like the one we used last time?</p>
    <p>Would love to hear from you all in the comments!</p>
  </div>
</div>
<div class="bulma-section bulma-container bulma-is-max-desktop">
  <div class="bulma-columns">
    
    <div class="bulma-column">
      <article class="bulma-media">
  
  <figure class="bulma-media-left">
    <p class="bulma-image bulma-is-64x64">
      <img class="bulma-is-rounded" src="https://github.com/LukaJCB.png" />
    </p>
  </figure>
  
  <div class="bulma-media-content">
    <div class="bulma-content">
      <p>
        <strong>Luka Jacobowitz</strong> 
        
        
        <br />
        Luka is a functional programmer in love with finding great abstractions to engineering problems. He’s also a maintainer of several typelevel projects and seeks to make learning of pure functional programming as easy as possible.
        
        
        
      </p>
    </div>
    <nav class="bulma-level bulma-is-align-items-start">
      <div class="bulma-level-left bulma-is-flex-direction-row">
        
        
        
        <a class="bulma-level-item" href="http://github.com/LukaJCB">
          <span class="bulma-icon bulma-is-small"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc. --><path fill="currentColor" d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3 .3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5 .3-6.2 2.3zm44.2-1.7c-2.9 .7-4.9 2.6-4.6 4.9 .3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM252.8 8c-138.7 0-244.8 105.3-244.8 244 0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1 100-33.2 167.8-128.1 167.8-239 0-138.7-112.5-244-251.2-244zM105.2 352.9c-1.3 1-1 3.3 .7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3 .3 2.9 2.3 3.9 1.6 1 3.6 .7 4.3-.7 .7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3 .7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3 .7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
        </a>
        
        
        
        
      </div>
    </nav>
  </div>
</article>

    </div>
    
  </div>
</div>


  </main>
  <footer class="bulma-footer">
  <div class="bulma-columns">
    <div class="bulma-column bulma-is-half">
      Copyright 2026 Typelevel Foundation and <a href="https://github.com/typelevel/typelevel.github.com/graphs/contributors">contributors</a>.
      Licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> unless <a href="../colophon.html#license">noted otherwise</a>.
    </div>
    <div class="bulma-column">
      <ul>
        <li><a href="../projects/">Project Index</a></li>
        <li><a href="../community/meetups.html">Meetup Calendar</a></li>
        <li><a href="../foundation/people.html">Leadership</a></li>
      </ul>
    </div>
    <div class="bulma-column">
      <ul>
        <li><a href="../code-of-conduct/">Code of Conduct</a></li>
        <li><a href="../security.html">Security Policy</a></li>
        <li><a href="../colophon.html">Colophon</a></li>
      </ul>
    </div>
  </div>
  <div class="bulma-has-text-centered">
    <div>Find us on ...</div>
    <div class="bulma-is-size-3">
      <a class="bulma-icon bulma-is-large bulma-has-text-current" href="https://github.com/typelevel">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc. --><path fill="currentColor" d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3 .3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5 .3-6.2 2.3zm44.2-1.7c-2.9 .7-4.9 2.6-4.6 4.9 .3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM252.8 8c-138.7 0-244.8 105.3-244.8 244 0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1 100-33.2 167.8-128.1 167.8-239 0-138.7-112.5-244-251.2-244zM105.2 352.9c-1.3 1-1 3.3 .7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3 .3 2.9 2.3 3.9 1.6 1 3.6 .7 4.3-.7 .7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3 .7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3 .7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
      </a>
      <a class="bulma-icon bulma-is-large bulma-has-text-current" href="https://discord.gg/typelevel-632277896739946517">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc. --><path fill="currentColor" d="M492.5 69.8c-.2-.3-.4-.6-.8-.7-38.1-17.5-78.4-30-119.7-37.1-.4-.1-.8 0-1.1 .1s-.6 .4-.8 .8c-5.5 9.9-10.5 20.2-14.9 30.6-44.6-6.8-89.9-6.8-134.4 0-4.5-10.5-9.5-20.7-15.1-30.6-.2-.3-.5-.6-.8-.8s-.7-.2-1.1-.2c-41.3 7.1-81.6 19.6-119.7 37.1-.3 .1-.6 .4-.8 .7-76.2 113.8-97.1 224.9-86.9 334.5 0 .3 .1 .5 .2 .8s.3 .4 .5 .6c44.4 32.9 94 58 146.8 74.2 .4 .1 .8 .1 1.1 0s.7-.4 .9-.7c11.3-15.4 21.4-31.8 30-48.8 .1-.2 .2-.5 .2-.8s0-.5-.1-.8-.2-.5-.4-.6-.4-.3-.7-.4c-15.8-6.1-31.2-13.4-45.9-21.9-.3-.2-.5-.4-.7-.6s-.3-.6-.3-.9 0-.6 .2-.9 .3-.5 .6-.7c3.1-2.3 6.2-4.7 9.1-7.1 .3-.2 .6-.4 .9-.4s.7 0 1 .1c96.2 43.9 200.4 43.9 295.5 0 .3-.1 .7-.2 1-.2s.7 .2 .9 .4c2.9 2.4 6 4.9 9.1 7.2 .2 .2 .4 .4 .6 .7s.2 .6 .2 .9-.1 .6-.3 .9-.4 .5-.6 .6c-14.7 8.6-30 15.9-45.9 21.8-.2 .1-.5 .2-.7 .4s-.3 .4-.4 .7-.1 .5-.1 .8 .1 .5 .2 .8c8.8 17 18.8 33.3 30 48.8 .2 .3 .6 .6 .9 .7s.8 .1 1.1 0c52.9-16.2 102.6-41.3 147.1-74.2 .2-.2 .4-.4 .5-.6s.2-.5 .2-.8c12.3-126.8-20.5-236.9-86.9-334.5zm-302 267.7c-29 0-52.8-26.6-52.8-59.2s23.4-59.2 52.8-59.2c29.7 0 53.3 26.8 52.8 59.2 0 32.7-23.4 59.2-52.8 59.2zm195.4 0c-29 0-52.8-26.6-52.8-59.2s23.4-59.2 52.8-59.2c29.7 0 53.3 26.8 52.8 59.2 0 32.7-23.2 59.2-52.8 59.2z"/></svg>
      </a>
      <a class="bulma-icon bulma-is-large bulma-has-text-current" href="https://bsky.app/profile/typelevel.org">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc. --><path fill="currentColor" d="M407.8 294.7c-3.3-.4-6.7-.8-10-1.3 3.4 .4 6.7 .9 10 1.3zM288 227.1C261.9 176.4 190.9 81.9 124.9 35.3 61.6-9.4 37.5-1.7 21.6 5.5 3.3 13.8 0 41.9 0 58.4S9.1 194 15 213.9c19.5 65.7 89.1 87.9 153.2 80.7 3.3-.5 6.6-.9 10-1.4-3.3 .5-6.6 1-10 1.4-93.9 14-177.3 48.2-67.9 169.9 120.3 124.6 164.8-26.7 187.7-103.4 22.9 76.7 49.2 222.5 185.6 103.4 102.4-103.4 28.1-156-65.8-169.9-3.3-.4-6.7-.8-10-1.3 3.4 .4 6.7 .9 10 1.3 64.1 7.1 133.6-15.1 153.2-80.7 5.9-19.9 15-138.9 15-155.5s-3.3-44.7-21.6-52.9c-15.8-7.1-40-14.9-103.2 29.8-66.1 46.6-137.1 141.1-163.2 191.8z"/></svg>
      </a>
      <a class="bulma-icon bulma-is-large bulma-has-text-current" href="https://fosstodon.org/@typelevel">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc. --><path fill="currentColor" d="M433 179.1c0-97.2-63.7-125.7-63.7-125.7-62.5-28.7-228.6-28.4-290.5 0 0 0-63.7 28.5-63.7 125.7 0 115.7-6.6 259.4 105.6 289.1 40.5 10.7 75.3 13 103.3 11.4 50.8-2.8 79.3-18.1 79.3-18.1l-1.7-36.9s-36.3 11.4-77.1 10.1c-40.4-1.4-83-4.4-89.6-54-.6-4.6-.9-9.3-.9-13.9 85.6 20.9 158.7 9.1 178.7 6.7 56.1-6.7 105-41.3 111.2-72.9 9.8-49.8 9-121.5 9-121.5zM357.9 304.3l-46.6 0 0-114.2c0-49.7-64-51.6-64 6.9l0 62.5-46.3 0 0-62.5c0-58.5-64-56.6-64-6.9l0 114.2-46.7 0c0-122.1-5.2-147.9 18.4-175 25.9-28.9 79.8-30.8 103.8 6.1l11.6 19.5 11.6-19.5c24.1-37.1 78.1-34.8 103.8-6.1 23.7 27.3 18.4 53 18.4 175l0 0z"/></svg>
      </a>
      <a class="bulma-icon bulma-is-large bulma-has-text-current" href="https://www.youtube.com/@typelevel">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc. --><path fill="currentColor" d="M549.7 124.1C543.5 100.4 524.9 81.8 501.4 75.5 458.9 64 288.1 64 288.1 64S117.3 64 74.7 75.5C51.2 81.8 32.7 100.4 26.4 124.1 15 167 15 256.4 15 256.4s0 89.4 11.4 132.3c6.3 23.6 24.8 41.5 48.3 47.8 42.6 11.5 213.4 11.5 213.4 11.5s170.8 0 213.4-11.5c23.5-6.3 42-24.2 48.3-47.8 11.4-42.9 11.4-132.3 11.4-132.3s0-89.4-11.4-132.3zM232.2 337.6l0-162.4 142.7 81.2-142.7 81.2z"/></svg>
      </a>
      <a class="bulma-icon bulma-is-large bulma-has-text-current"
        href="https://linkedin.com/company/typelevel-foundation">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc. --><path fill="currentColor" d="M416 32L31.9 32C14.3 32 0 46.5 0 64.3L0 447.7C0 465.5 14.3 480 31.9 480L416 480c17.6 0 32-14.5 32-32.3l0-383.4C448 46.5 433.6 32 416 32zM135.4 416l-66.4 0 0-213.8 66.5 0 0 213.8-.1 0zM102.2 96a38.5 38.5 0 1 1 0 77 38.5 38.5 0 1 1 0-77zM384.3 416l-66.4 0 0-104c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9l0 105.8-66.4 0 0-213.8 63.7 0 0 29.2 .9 0c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9l0 117.2z"/></svg>
      </a>
      <a class="bulma-icon bulma-is-large bulma-has-text-current"
        href="feed.rss">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc. --><path fill="currentColor" d="M64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32zM96 136c0-13.3 10.7-24 24-24 137 0 248 111 248 248 0 13.3-10.7 24-24 24s-24-10.7-24-24c0-110.5-89.5-200-200-200-13.3 0-24-10.7-24-24zm0 96c0-13.3 10.7-24 24-24 83.9 0 152 68.1 152 152 0 13.3-10.7 24-24 24s-24-10.7-24-24c0-57.4-46.6-104-104-104-13.3 0-24-10.7-24-24zm0 120a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z"/></svg>
      </a>
    </div>
  </div>
</footer>

</body>

</html>

