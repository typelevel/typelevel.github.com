<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Typelevel.scala</title>
    <description>Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.</description>    
    <link>https://typelevel.org</link>
    <copyright>CC BY 3.0</copyright>
    
      <item>
        <title>Chain – Replacing the List Monoid</title>
        
          <dc:creator>lukajcb</dc:creator>
                
        <description><![CDATA[<p><code class="highlighter-rouge">List</code> is a great data type, it is very simple and easy to understand.
It has very low overhead for the most important functions such as <code class="highlighter-rouge">fold</code> and <code class="highlighter-rouge">map</code> and also supports prepending a single element in constant time.</p>

<p>Traversing a data structure with something like <code class="highlighter-rouge">Writer[List[Log], A]</code> or <code class="highlighter-rouge">ValidatedNel[Error, A]</code> is  powerful and allows us to precisely specify what kind of iteration we want to do while remaining succint.
However, in terms of efficiency it’s a whole different story unfortunately.
That is because both of these traversals make use of the <code class="highlighter-rouge">List</code> monoid (or the <code class="highlighter-rouge">NonEmptyList</code> semigroup), which by the nature of <code class="highlighter-rouge">List</code> is very inefficient.
If you use <code class="highlighter-rouge">traverse</code> with a data structure with <code class="highlighter-rouge">n</code> elements and <code class="highlighter-rouge">Writer</code> or <code class="highlighter-rouge">Validated</code> as the <code class="highlighter-rouge">Applicative</code> type, you will end up with a runtime of <code class="highlighter-rouge">O(n^2)</code>.
This is because, with <code class="highlighter-rouge">List</code>, appending a single element requires iterating over the entire data structure and therefore takes linear time.</p>

<p>So <code class="highlighter-rouge">List</code> isn’t all that great for this use case, so let’s use <code class="highlighter-rouge">Vector</code> or <code class="highlighter-rouge">NonEmptyVector</code> instead, right?</p>

<p>Well, <code class="highlighter-rouge">Vector</code> has its own problems and in this case it’s unfortunately not that much faster than <code class="highlighter-rouge">List</code> at all. You can check <a href="http://www.lihaoyi.com/post/BenchmarkingScalaCollections.html#vectors-are-ok">this blog post</a> by Li Haoyi for some deeper insight into <code class="highlighter-rouge">Vector</code>’s issues.</p>

<p>Because of this, it’s now time to welcome a new data structure to Cats.
Meet <code class="highlighter-rouge">Chain</code> and its non-empty counterpart, <code class="highlighter-rouge">NonEmptyChain</code>.</p>

<p>Available in the newest Cats 1.3.1 release, <code class="highlighter-rouge">Chain</code> evolved from what used to be <code class="highlighter-rouge">fs2.Catenable</code> and Erik Osheim’s <a href="https://github.com/non/chain">Chain</a> library.
Similar to <code class="highlighter-rouge">List</code>, it is also a very simple data structure, but unlike <code class="highlighter-rouge">List</code> it supports both constant O(1) time <code class="highlighter-rouge">append</code> and <code class="highlighter-rouge">prepend</code>.
This makes its <code class="highlighter-rouge">Monoid</code> instance super performant and a much better fit for usage with <code class="highlighter-rouge">Validated</code>,<code class="highlighter-rouge">Writer</code>, <code class="highlighter-rouge">Ior</code> or <code class="highlighter-rouge">Const</code>.</p>

<p>To utilize this, we’ve added a bunch of <code class="highlighter-rouge">NonEmptyChain</code> shorthands in Cats 1.3 that mirror those that used <code class="highlighter-rouge">NonEmptyList</code> in earlier versions. These include type aliases like <code class="highlighter-rouge">ValidatedNec</code> or <code class="highlighter-rouge">IorNec</code> as well as helper functions like <code class="highlighter-rouge">groupByNec</code> or <code class="highlighter-rouge">Validated.invalidNec</code>.
We hope that these make it easy for you to upgrade to the more efficient data structure and enjoy those benefits as soon as possible.</p>

<p>To get a good idea of the performance improvements, here are some benchmarks that test monoidal append (higher score is better):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[info] Benchmark                                  Mode  Cnt   Score   Error  Units
[info] CollectionMonoidBench.accumulateChain     thrpt   20  51.911 ± 7.453  ops/s
[info] CollectionMonoidBench.accumulateList      thrpt   20   6.973 ± 0.781  ops/s
[info] CollectionMonoidBench.accumulateVector    thrpt   20   6.304 ± 0.129  ops/s
</code></pre></div></div>

<p>As you can see accumulating things with <code class="highlighter-rouge">Chain</code> is more than 7 times faster than <code class="highlighter-rouge">List</code> and over 8 times faster than <code class="highlighter-rouge">Vector</code>.
So appending is a lot more performant than the standard library collections, but what about operations like <code class="highlighter-rouge">map</code> or <code class="highlighter-rouge">fold</code>?
Fortunately we’ve also benchmarked these (again, higher score is better):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[info] Benchmark                           Mode  Cnt          Score         Error  Units
[info] ChainBench.foldLeftLargeChain      thrpt   20        117.267 ±       1.815  ops/s
[info] ChainBench.foldLeftLargeList       thrpt   20        135.954 ±       3.340  ops/s
[info] ChainBench.foldLeftLargeVector     thrpt   20         61.613 ±       1.326  ops/s
[info]
[info] ChainBench.mapLargeChain           thrpt   20         59.379 ±       0.866  ops/s
[info] ChainBench.mapLargeList            thrpt   20         66.729 ±       7.165  ops/s
[info] ChainBench.mapLargeVector          thrpt   20         61.374 ±       2.004  ops/s
</code></pre></div></div>

<p>While not as dominant, <code class="highlighter-rouge">Chain</code> holds its ground fairly well.
It won’t have the random access performance of something like <code class="highlighter-rouge">Vector</code>, but in a lot of other cases, <code class="highlighter-rouge">Chain</code> seems to outperform it quite handily.
So if you don’t perform a lot of random access on your data structure, then you should be fine using <code class="highlighter-rouge">Chain</code> extensively instead.</p>

<p>So next time you write any code that uses <code class="highlighter-rouge">List</code> or <code class="highlighter-rouge">Vector</code> as a <code class="highlighter-rouge">Monoid</code>, be sure to use <code class="highlighter-rouge">Chain</code> instead!</p>

<p>The whole code for <code class="highlighter-rouge">Chain</code> and <code class="highlighter-rouge">NonEmptyChain</code> can be found <a href="https://github.com/typelevel/cats/blob/v1.3.0/core/src/main/scala/cats/data/Chain.scala">here</a> and <a href="https://github.com/typelevel/cats/blob/v1.3.0/core/src/main/scala/cats/data/NonEmptyChain.scala">here</a>.
You can also check out the benchmarks <a href="https://github.com/typelevel/cats/blob/v1.3.0/bench/src/main/scala/cats/bench">here</a>.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Tue, 04 Sep 2018 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2018/09/04/chain-replacing-the-list-monoid.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/09/04/chain-replacing-the-list-monoid.html</guid>
      </item>
    
      <item>
        <title>Http4s error handling with Cats Meow MTL</title>
        
          <dc:creator>gvolpe</dc:creator>
                
        <description><![CDATA[<p>As a longtime <code class="highlighter-rouge">http4s</code> user I keep on learning new things and I’m always trying to come up with the best practices for writing http applications. This time I want to talk about my latest achievements in error handling within the context of an http application where it basically means mapping each business error to the appropiate <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">http response</a>.</p>

<p>So let’s get started by putting up an example of an http application with three different endpoints that interacts with a <code class="highlighter-rouge">UserAlgebra</code> that may or may not fail with some specific errors.</p>

<p>If you are one of those who don’t like to read and prefer to jump straight into the code please find it <a href="https://gist.github.com/gvolpe/3fa32dd1b6abce2a5466efbf0eca9e94">here</a> :)</p>

<h3 id="user-algebra">User Algebra</h3>

<p>We have a simple <code class="highlighter-rouge">UserAlgebra</code> that let us perform some actions such as finding and persisting users.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">User</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UserUpdateAge</span><span class="o">(</span><span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="k">trait</span> <span class="nc">UserAlgebra</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">find</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span>
  <span class="k">def</span> <span class="n">save</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">updateAge</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And also an ADT of the possible errors that may arise. I’ll explain later in this post why it extends <code class="highlighter-rouge">Exception</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">UserError</span> <span class="k">extends</span> <span class="nc">Exception</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UserAlreadyExists</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">UserError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UserNotFound</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">UserError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">InvalidUserAge</span><span class="o">(</span><span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">UserError</span>
</code></pre></div></div>

<h3 id="user-interpreter">User Interpreter</h3>

<p>And here we have a simple interpreter for our <code class="highlighter-rouge">UserAlgebra</code> for demonstration purposes so you can have an idea on how the logic would look like. In a real-life project an interpreter will more likely connect to a database instead of using an in-memory representaion based on <code class="highlighter-rouge">Ref</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.Sync</span>
<span class="k">import</span> <span class="nn">cats.effect.concurrent.Ref</span>
<span class="k">import</span> <span class="nn">cats.syntax.all._</span>

<span class="k">object</span> <span class="nc">UserInterpreter</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">create</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">UserAlgebra</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nc">Ref</span><span class="o">.</span><span class="n">of</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">User</span><span class="o">]](</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span> <span class="n">state</span> <span class="k">=&gt;</span>
      <span class="k">new</span> <span class="nc">UserAlgebra</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">private</span> <span class="k">def</span> <span class="n">validateAge</span><span class="o">(</span><span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">age</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">F</span><span class="o">.</span><span class="n">raiseError</span><span class="o">(</span><span class="nc">InvalidUserAge</span><span class="o">(</span><span class="n">age</span><span class="o">))</span> <span class="k">else</span> <span class="n">F</span><span class="o">.</span><span class="n">unit</span>

        <span class="k">override</span> <span class="k">def</span> <span class="n">find</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span>
          <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">username</span><span class="o">))</span>

        <span class="k">override</span> <span class="k">def</span> <span class="n">save</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
          <span class="n">validateAge</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">age</span><span class="o">)</span> <span class="o">*&gt;</span>
            <span class="n">find</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">username</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span>
              <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
                <span class="n">F</span><span class="o">.</span><span class="n">raiseError</span><span class="o">(</span><span class="nc">UserAlreadyExists</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">username</span><span class="o">))</span>
              <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span>
                <span class="n">state</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">updated</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">username</span><span class="o">,</span> <span class="n">user</span><span class="o">))</span>
            <span class="o">}</span>

        <span class="k">override</span> <span class="k">def</span> <span class="n">updateAge</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
          <span class="n">validateAge</span><span class="o">(</span><span class="n">age</span><span class="o">)</span> <span class="o">*&gt;</span>
            <span class="n">find</span><span class="o">(</span><span class="n">username</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span>
              <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">user</span><span class="o">)</span> <span class="k">=&gt;</span>
                <span class="n">state</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">updated</span><span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="n">user</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">age</span> <span class="k">=</span> <span class="n">age</span><span class="o">)))</span>
              <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span>
                <span class="n">F</span><span class="o">.</span><span class="n">raiseError</span><span class="o">(</span><span class="nc">UserNotFound</span><span class="o">(</span><span class="n">username</span><span class="o">))</span>
            <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h3 id="http-routes">Http Routes</h3>

<p>The following implementation of <code class="highlighter-rouge">UserRoutes</code> applies the tagless final encoding and the concept of “abstracting over the effect type” where we do not commit to a particular effect until the edge of our application.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">io.circe.generic.auto._</span>
<span class="k">import</span> <span class="nn">io.circe.syntax._</span>
<span class="k">import</span> <span class="nn">org.http4s._</span>
<span class="k">import</span> <span class="nn">org.http4s.circe._</span>
<span class="k">import</span> <span class="nn">org.http4s.circe.CirceEntityDecoder._</span>
<span class="k">import</span> <span class="nn">org.http4s.dsl.Http4sDsl</span>

<span class="k">class</span> <span class="nc">UserRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">userAlgebra</span><span class="k">:</span> <span class="kt">UserAlgebra</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Http4sDsl</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">val</span> <span class="n">routes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HttpRoutes</span><span class="o">.</span><span class="n">of</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">case</span> <span class="nc">GET</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="o">/</span> <span class="n">username</span> <span class="k">=&gt;</span>
      <span class="n">userAlgebra</span><span class="o">.</span><span class="n">find</span><span class="o">(</span><span class="n">username</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">user</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Ok</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">asJson</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">NotFound</span><span class="o">(</span><span class="n">username</span><span class="o">.</span><span class="n">asJson</span><span class="o">)</span>
      <span class="o">}</span>

    <span class="k">case</span> <span class="n">req</span> <span class="k">@</span> <span class="nc">POST</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="k">=&gt;</span>
      <span class="n">req</span><span class="o">.</span><span class="n">as</span><span class="o">[</span><span class="kt">User</span><span class="o">].</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">user</span> <span class="k">=&gt;</span>
        <span class="n">userAlgebra</span><span class="o">.</span><span class="n">save</span><span class="o">(</span><span class="n">user</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">Created</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">username</span><span class="o">.</span><span class="n">asJson</span><span class="o">)</span>
      <span class="o">}</span>

    <span class="k">case</span> <span class="n">req</span> <span class="k">@</span> <span class="nc">PUT</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="o">/</span> <span class="n">username</span> <span class="k">=&gt;</span>
      <span class="n">req</span><span class="o">.</span><span class="n">as</span><span class="o">[</span><span class="kt">UserUpdateAge</span><span class="o">].</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">userUpdate</span> <span class="k">=&gt;</span>
        <span class="n">userAlgebra</span><span class="o">.</span><span class="n">updateAge</span><span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="n">userUpdate</span><span class="o">.</span><span class="n">age</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">Ok</span><span class="o">(</span><span class="n">username</span><span class="o">)</span>
      <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>Now this particular implementation is missing a very important part: error handling. If we use the <code class="highlighter-rouge">UserAlgebra</code>’s interpreter previously defined we will clearly miss the three errors defined by the <code class="highlighter-rouge">UserError</code> ADT.</p>

<p><strong><em>NOTE: If you are not familiar with these concepts make sure you check out <a href="https://youtu.be/pGfj_l-h3M8?t=887">my talk at Scala Matsuri</a> early this year where I also talk about error handling in http applications using the Http4s library.</em></strong></p>

<h3 id="http-error-handling">Http Error Handling</h3>

<p>Okay let’s just go ahead and add some error handling to our http route by taking advantange of the <code class="highlighter-rouge">MonadError</code> instance defined by our constraint <code class="highlighter-rouge">Sync[F]</code> and making use of the syntax provided by <code class="highlighter-rouge">cats</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UserRoutesAlt</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">userAlgebra</span><span class="k">:</span> <span class="kt">UserAlgebra</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Http4sDsl</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">val</span> <span class="n">routes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HttpRoutes</span><span class="o">.</span><span class="n">of</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">case</span> <span class="nc">GET</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="o">/</span> <span class="n">username</span> <span class="k">=&gt;</span>
      <span class="n">userAlgebra</span><span class="o">.</span><span class="n">find</span><span class="o">(</span><span class="n">username</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">user</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Ok</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">asJson</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">NotFound</span><span class="o">(</span><span class="n">username</span><span class="o">.</span><span class="n">asJson</span><span class="o">)</span>
      <span class="o">}</span>

    <span class="k">case</span> <span class="n">req</span> <span class="k">@</span> <span class="nc">POST</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="k">=&gt;</span>
      <span class="n">req</span><span class="o">.</span><span class="n">as</span><span class="o">[</span><span class="kt">User</span><span class="o">].</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">user</span> <span class="k">=&gt;</span>
        <span class="n">userAlgebra</span><span class="o">.</span><span class="n">save</span><span class="o">(</span><span class="n">user</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">Created</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">username</span><span class="o">.</span><span class="n">asJson</span><span class="o">)</span>
      <span class="o">}.</span><span class="n">handleErrorWith</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">UserAlreadyExists</span><span class="o">(</span><span class="n">username</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Conflict</span><span class="o">(</span><span class="n">username</span><span class="o">.</span><span class="n">asJson</span><span class="o">)</span>
      <span class="o">}</span>

    <span class="k">case</span> <span class="n">req</span> <span class="k">@</span> <span class="nc">PUT</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="o">/</span> <span class="n">username</span> <span class="k">=&gt;</span>
      <span class="n">req</span><span class="o">.</span><span class="n">as</span><span class="o">[</span><span class="kt">UserUpdateAge</span><span class="o">].</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">userUpdate</span> <span class="k">=&gt;</span>
        <span class="n">userAlgebra</span><span class="o">.</span><span class="n">updateAge</span><span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="n">userUpdate</span><span class="o">.</span><span class="n">age</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">Ok</span><span class="o">(</span><span class="n">username</span><span class="o">.</span><span class="n">asJson</span><span class="o">)</span>
      <span class="o">}.</span><span class="n">handleErrorWith</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">InvalidUserAge</span><span class="o">(</span><span class="n">age</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">BadRequest</span><span class="o">(</span><span class="n">s</span><span class="s">"Invalid age $age"</span><span class="o">.</span><span class="n">asJson</span><span class="o">)</span>
      <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>Now we can say this implementation is quite elegant! We are handling and mapping business errors to the according http response and our code compiles without any warning whatsoever. But wait… We are not handling the <code class="highlighter-rouge">UserNotFound</code> error and the compiler didn’t tell us about it! That’s not cool and we as functional programmers believe in types because we can know what a function might do just by looking at the types but here it seems we hit the wall.</p>

<p>The problem is that our constraint of type <code class="highlighter-rouge">Sync</code> from <code class="highlighter-rouge">cats-effect</code> has a <code class="highlighter-rouge">MonadError</code> instance with its type error fixed as <code class="highlighter-rouge">Throwable</code>. So the compiler can’t help us here since this type is too generic. And we can’t add a constraint for <code class="highlighter-rouge">MonadError[F, UserError]</code> because we would get an “ambigous implicits” error with two instances of <code class="highlighter-rouge">MonadError</code> in scope.</p>

<p>So, what can we do about it?</p>

<h3 id="next-level-mtl-optics">Next level MTL: Optics</h3>

<p>I heard sometime ago about Classy Optics (Lenses, Prisms, etc) when I was learning Haskell and watched <a href="https://www.youtube.com/watch?v=GZPup5Iuaqw">this amazing talk</a> by George Wilson but I never got to use this concept in Scala until now!</p>

<p>Well first, let me give you a quick definition of <code class="highlighter-rouge">Lens</code>es and <code class="highlighter-rouge">Prism</code>s. In a few words we can define:</p>

<ul>
  <li><code class="highlighter-rouge">Lens</code>es as getters and setters that compose making the accessing of nested data structure’s fields quite easy.</li>
  <li><code class="highlighter-rouge">Prism</code>s as first-class pattern matching that let us access branches of an ADT and that also compose.</li>
</ul>

<p>And <code class="highlighter-rouge">Classy Optics</code> as the idea of “associate with each type a typeclass full of optics for that type”.</p>

<p><strong><em>So what am I talking about and how can these concepts help us solving the http error handling problem?</em></strong></p>

<p>Remember that I defined the <code class="highlighter-rouge">UserError</code> ADT by extending <code class="highlighter-rouge">Exception</code>?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">UserError</span> <span class="k">extends</span> <span class="nc">Exception</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UserAlreadyExists</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">UserError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UserNotFound</span><span class="o">(</span><span class="n">username</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">UserError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">InvalidUserAge</span><span class="o">(</span><span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">UserError</span>
</code></pre></div></div>

<p>Well there’s a reason! By making <code class="highlighter-rouge">UserError</code> a subtype of <code class="highlighter-rouge">Exception</code> (and by default of <code class="highlighter-rouge">Throwable</code>) we can take advantage of <code class="highlighter-rouge">Prisms</code> by going back and forth in the types. See what I’m going yet?</p>

<p><code class="highlighter-rouge">UserRoute</code> has a <code class="highlighter-rouge">Sync[F]</code> constraint, meaning that we have available a <code class="highlighter-rouge">MonadError[F, Throwable]</code> instance, but we would like to have <code class="highlighter-rouge">MonadError[F, UserError]</code> instead to leverage the Scala compiler. The caveat is that the error types need to be of the same family so we can derive a <code class="highlighter-rouge">Prism</code> that can navigate the errors types in one direction or another. But how do we derive it?</p>

<h4 id="cats-meow-mtl">Cats Meow MTL</h4>

<p>Fortunately our friend <a href="https://twitter.com/oleg_pyzhcov">Oleg Pyzhcov</a> has created this great library named <a href="https://github.com/oleg-py/meow-mtl">meow-mtl</a> that makes heavy use of <a href="https://github.com/milessabin/shapeless">Shapeless</a> in order to derive <code class="highlighter-rouge">Lenses</code> and <code class="highlighter-rouge">Prisms</code> and it provides instances for some <code class="highlighter-rouge">cats-effect</code> compatible datatypes.</p>

<p>And two of the supported typeclasses are <code class="highlighter-rouge">ApplicativeError</code> and <code class="highlighter-rouge">MonadError</code> as long as the error type is a subtype of <code class="highlighter-rouge">Throwable</code> to make it compatible with <code class="highlighter-rouge">cats-effect</code>. So we can do something like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.MonadError</span>
<span class="k">import</span> <span class="nn">cats.effect.IO</span>
<span class="k">import</span> <span class="nn">com.olegpy.meow.hierarchy._</span> <span class="c1">// All you need is this import!
</span><span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">CustomError</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Throwable</span>

<span class="k">def</span> <span class="n">customHandle</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fallback</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">CustomError</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">f</span><span class="o">.</span><span class="n">handleErrorWith</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">fallback</span><span class="o">)</span>

<span class="k">val</span> <span class="n">io</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="nc">Random</span><span class="o">.</span><span class="n">nextInt</span><span class="o">(</span><span class="mi">2</span><span class="o">)).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="k">case</span> <span class="mi">1</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">.</span><span class="n">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"boom"</span><span class="o">))</span> <span class="o">}</span>
<span class="n">customHandle</span><span class="o">(</span><span class="n">io</span><span class="o">,</span> <span class="nc">IO</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="mi">123</span><span class="o">))</span>
</code></pre></div></div>

<h4 id="generalizing-http-error-handling">Generalizing Http Error Handling</h4>

<p>Now back to our use case. We can’t have a <code class="highlighter-rouge">MonadError[F, UserError]</code> constraint because there’s already a <code class="highlighter-rouge">MonadError[F, Throwable]</code> in scope given our <code class="highlighter-rouge">Sync[F]</code> constraint. But it turns out we can make this work if we also abstract over the error handling by introducing an <code class="highlighter-rouge">HttpErrorHandler</code> algebra where the error type is a subtype of <code class="highlighter-rouge">Throwable</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">HttpErrorHandler</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">handle</span><span class="o">(</span><span class="n">routes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">HttpErrorHandler</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">HttpErrorHandler</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">])</span> <span class="k">=</span> <span class="n">ev</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">UserRoutes</code> can now have an additional constraint of type <code class="highlighter-rouge">HttpErrorHandler[F, UserError]</code> so we clearly know what kind of errors we are dealing with and can have the Scala compiler on our side.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UserRoutesMTL</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Sync</span><span class="o">](</span><span class="n">userAlgebra</span><span class="k">:</span> <span class="kt">UserAlgebra</span><span class="o">[</span><span class="kt">F</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">H</span><span class="k">:</span> <span class="kt">HttpErrorHandler</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserError</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Http4sDsl</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">val</span> <span class="n">httpRoutes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HttpRoutes</span><span class="o">.</span><span class="n">of</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">case</span> <span class="nc">GET</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="o">/</span> <span class="n">username</span> <span class="k">=&gt;</span>
      <span class="n">userAlgebra</span><span class="o">.</span><span class="n">find</span><span class="o">(</span><span class="n">username</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">user</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Ok</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">asJson</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">NotFound</span><span class="o">(</span><span class="n">username</span><span class="o">.</span><span class="n">asJson</span><span class="o">)</span>
      <span class="o">}</span>

    <span class="k">case</span> <span class="n">req</span> <span class="k">@</span> <span class="nc">POST</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="k">=&gt;</span>
      <span class="n">req</span><span class="o">.</span><span class="n">as</span><span class="o">[</span><span class="kt">User</span><span class="o">].</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">user</span> <span class="k">=&gt;</span>
        <span class="n">userAlgebra</span><span class="o">.</span><span class="n">save</span><span class="o">(</span><span class="n">user</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">Created</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">username</span><span class="o">.</span><span class="n">asJson</span><span class="o">)</span>
      <span class="o">}</span>

    <span class="k">case</span> <span class="n">req</span> <span class="k">@</span> <span class="nc">PUT</span> <span class="o">-&gt;</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="o">/</span> <span class="n">username</span> <span class="k">=&gt;</span>
      <span class="n">req</span><span class="o">.</span><span class="n">as</span><span class="o">[</span><span class="kt">UserUpdateAge</span><span class="o">].</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">userUpdate</span> <span class="k">=&gt;</span>
        <span class="n">userAlgebra</span><span class="o">.</span><span class="n">updateAge</span><span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="n">userUpdate</span><span class="o">.</span><span class="n">age</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="nc">Created</span><span class="o">(</span><span class="n">username</span><span class="o">.</span><span class="n">asJson</span><span class="o">)</span>
      <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">val</span> <span class="n">routes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="n">H</span><span class="o">.</span><span class="n">handle</span><span class="o">(</span><span class="n">httpRoutes</span><span class="o">)</span>

<span class="o">}</span>
</code></pre></div></div>

<p>We are basically delegating the error handling (AKA mapping business errors to appropiate http responses) to a specific algebra.</p>

<p>We also need an implementation for this algebra in order to handle errors of type <code class="highlighter-rouge">UserError</code> but first we can introduce a <code class="highlighter-rouge">RoutesHttpErrorHandler</code> object that encapsulates the repetitive task of handling errors given an <code class="highlighter-rouge">HttpRoutes[F]</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.ApplicativeError</span>
<span class="k">import</span> <span class="nn">cats.data.</span><span class="o">{</span><span class="nc">Kleisli</span><span class="o">,</span> <span class="nc">OptionT</span><span class="o">}</span>

<span class="k">object</span> <span class="nc">RoutesHttpErrorHandler</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span><span class="o">](</span><span class="n">routes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">])(</span><span class="n">handler</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">Response</span><span class="o">[</span><span class="kt">F</span><span class="o">]])(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">ApplicativeError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Kleisli</span> <span class="o">{</span> <span class="n">req</span><span class="k">:</span> <span class="kt">Request</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span>
      <span class="nc">OptionT</span> <span class="o">{</span>
        <span class="n">routes</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">req</span><span class="o">).</span><span class="n">value</span><span class="o">.</span><span class="n">handleErrorWith</span> <span class="o">{</span> <span class="n">e</span> <span class="k">=&gt;</span> <span class="n">handler</span><span class="o">(</span><span class="n">e</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="nc">Option</span><span class="o">(</span><span class="k">_</span><span class="o">))</span> <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And our implementation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UserHttpErrorHandler</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">M</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserError</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">HttpErrorHandler</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserError</span><span class="o">]</span> <span class="k">with</span> <span class="nc">Http4sDsl</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">handler</span><span class="k">:</span> <span class="kt">UserError</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">Response</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">InvalidUserAge</span><span class="o">(</span><span class="n">age</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">BadRequest</span><span class="o">(</span><span class="n">s</span><span class="s">"Invalid age $age"</span><span class="o">.</span><span class="n">asJson</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">UserAlreadyExists</span><span class="o">(</span><span class="n">username</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Conflict</span><span class="o">(</span><span class="n">username</span><span class="o">.</span><span class="n">asJson</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">UserNotFound</span><span class="o">(</span><span class="n">username</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">NotFound</span><span class="o">(</span><span class="n">username</span><span class="o">.</span><span class="n">asJson</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">handle</span><span class="o">(</span><span class="n">routes</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">HttpRoutes</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">RoutesHttpErrorHandler</span><span class="o">(</span><span class="n">routes</span><span class="o">)(</span><span class="n">handler</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>If we forget to handle some errors the compiler will shout at us <strong><em>“match may not be exhaustive!”</em></strong> That’s fantastic :)</p>

<h4 id="wiring-all-the-components">Wiring all the components</h4>

<p>And the last part will be the wiring of all these components where we need to include the <code class="highlighter-rouge">meow-mtl</code> import to figure out the derivation of the instances we need in order to make this work. It’ll look something like this if using <code class="highlighter-rouge">cats.effect.IO</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">com.olegpy.meow.hierarchy._</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">userHttpErrorHandler</span><span class="k">:</span> <span class="kt">HttpErrorHandler</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">UserError</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">UserHttpErrorHandler</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span>

<span class="nc">UserInterpreter</span><span class="o">.</span><span class="n">create</span><span class="o">[</span><span class="kt">IO</span><span class="o">].</span><span class="n">flatMap</span> <span class="o">{</span> <span class="nc">UserAlgebra</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">routes</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">UserRoutesMTL</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="nc">UserAlgebra</span><span class="o">)</span>
  <span class="nc">IO</span><span class="o">.</span><span class="n">unit</span> <span class="c1">// pretend this is the rest of your program
</span><span class="o">}</span>
</code></pre></div></div>

<h3 id="final-thoughts">Final thoughts</h3>

<p>This is such an exciting time to be writing pure functional programming in Scala! The Typelevel ecosystem is getting richer and more mature, having an amazing set of libraries to solve business problems in an elegant and purely functional way.</p>

<p>I hope you have enjoyed this post and please do let me know if you know of better ways to solve this problem in the comments!</p>

<p>And last but not least I would like to thank all the friendly folks I hang out with in the <code class="highlighter-rouge">cats-effect</code>, <code class="highlighter-rouge">cats</code>, <code class="highlighter-rouge">fs2</code> and <code class="highlighter-rouge">http4s</code> Gitter channels for all the time and effort they put (<em>for free</em>) into making this community an amazing space.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sat, 25 Aug 2018 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2018/08/25/http4s-error-handling-mtl.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/08/25/http4s-error-handling-mtl.html</guid>
      </item>
    
      <item>
        <title>Refactoring with Monads</title>
        
          <dc:creator>mtomko</dc:creator>
                
        <description><![CDATA[<p>I was recently cleaning up some Scala code I’d written a few months
ago when I realized I had been structuring code in a very confusing
way for a very long time. At work, we’ve been trying to untangle the
knots of code that get written by different authors at different
times, as requirements inevitably evolve. We all know that code should
be made up of short, easily digestible functions but we don’t always
get guidance on how to achieve that. In the presence of error handling
and nested data structures, the problem gets even harder.</p>

<p>The goal of this blog post is to describe a concrete strategy for
structuring code so that the overall flow of control is clear to the
reader, even months later; and so the smaller pieces are both
digestible and testable. I’ll start by giving an example function,
operating on some nested data types. Then I’ll explore some ways to
break it into smaller pieces. The key insight is that we can use
computational effects in the form of
<a href="https://typelevel.org/cats/typeclasses/monad.html">monads</a> (more
specifically,
<a href="https://typelevel.org/cats/api/cats/MonadError.html">MonadError</a>) to
wrap smaller pieces and ultimately, compose them into an
understandable sequence of computations.</p>

<h3 id="example-domain-reading-a-catalog">Example domain: reading a catalog</h3>

<p>Let’s not worry about <code class="highlighter-rouge">MonadError</code> yet, but instead look at some
example code. Consider a situation where you need to translate data
from one domain model to another one with different restrictions, and
controlled vocabularies. This can happen in a number of places in a
program, for instance reading a database or an HTTP request to
construct a domain object.</p>

<p>Suppose we need to read an object from a relational database.
Unfortunately, rows in the table may represent objects of a variety of
types so we have to read the row and build up the object graph
accordingly. This is the boundary between the weakly typed wilderness
and the strongly typed world within our program.</p>

<p>Say our database table represents a library catalog, which might have
print books and ebooks. We’d like to look up a book by ID and get back
a nicely typed record.</p>

<p>Here’s a simple table</p>

<table>
  <thead>
    <tr>
      <th>id</th>
      <th>title</th>
      <th>author</th>
      <th>format</th>
      <th>download_type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>45</td>
      <td>Programming In Haskell</td>
      <td>Hutton, Graham</td>
      <td>print</td>
      <td>null</td>
    </tr>
    <tr>
      <td>46</td>
      <td>Programming In Haskell</td>
      <td>Hutton, Graham</td>
      <td>ebook</td>
      <td>epub</td>
    </tr>
    <tr>
      <td>49</td>
      <td>Programming In Haskell</td>
      <td>Hutton, Graham</td>
      <td>ebook</td>
      <td>pdf</td>
    </tr>
  </tbody>
</table>

<p>We can define a simple domain model:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Format</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Print</span> <span class="k">extends</span> <span class="nc">Format</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Digital</span> <span class="k">extends</span> <span class="nc">Format</span>
<span class="k">object</span> <span class="nc">Format</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">fromString</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">Format</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">DownloadType</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Epub</span> <span class="k">extends</span> <span class="nc">DownloadType</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Pdf</span> <span class="k">extends</span> <span class="nc">DownloadType</span>
<span class="k">object</span> <span class="nc">DownloadType</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">fromString</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">DownloadType</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Book</span> <span class="k">extends</span> <span class="nc">Product</span> <span class="k">with</span> <span class="nc">Serializable</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">id</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">def</span> <span class="n">title</span><span class="k">:</span> <span class="kt">String</span>
  <span class="k">def</span> <span class="n">author</span><span class="k">:</span> <span class="kt">String</span>
  <span class="k">def</span> <span class="n">format</span><span class="k">:</span> <span class="kt">Format</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">PrintBook</span><span class="o">(</span>
    <span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
    <span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">author</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Book</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">val</span> <span class="n">format</span><span class="k">:</span> <span class="kt">Format</span> <span class="o">=</span> <span class="nc">Print</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">EBook</span><span class="o">(</span>
    <span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
    <span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">author</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">downloadType</span><span class="k">:</span> <span class="kt">DownloadType</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Book</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">val</span> <span class="n">format</span><span class="k">:</span> <span class="kt">Format</span> <span class="o">=</span> <span class="nc">Digital</span>
<span class="o">}</span>

</code></pre></div></div>

<p>We want to be able to define a method such as:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">findBookById</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">Book</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<h3 id="monolithic-function">Monolithic function</h3>
<p>One trivial definition of <code class="highlighter-rouge">findBookById</code> might be:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Failure</span><span class="o">,</span> <span class="nc">Success</span><span class="o">,</span> <span class="nc">Try</span><span class="o">}</span>

<span class="k">def</span> <span class="n">findBookById</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">Book</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="c1">// unsafeQueryUnique returns a `Try[Row]`
</span>  <span class="nc">DB</span><span class="o">.</span><span class="n">unsafeQueryUnique</span><span class="o">(</span><span class="n">sql</span><span class="s">"""select * from catalog where id = $id"""</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">row</span> <span class="k">=&gt;</span>
    <span class="c1">// pick out the properties every book possesses
</span>    <span class="k">val</span> <span class="n">id</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="s">"id"</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">title</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"title"</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">author</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"author"</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">formatStr</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"format"</span><span class="o">)</span>

    <span class="c1">// now start to determine the types - get the format first
</span>    <span class="nc">Format</span><span class="o">.</span><span class="n">fromString</span><span class="o">(</span><span class="n">formatStr</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Print</span> <span class="k">=&gt;</span>
        <span class="c1">// for print books, we can construct the book and return immediately
</span>        <span class="nc">Success</span><span class="o">(</span><span class="nc">PrintBook</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">title</span><span class="o">,</span> <span class="n">author</span><span class="o">))</span>
      <span class="k">case</span> <span class="nc">Digital</span> <span class="k">=&gt;</span>
        <span class="c1">// for digital books we need to handle the download type
</span>        <span class="n">row</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="s">"download_type"</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
          <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span>
            <span class="nc">Failure</span><span class="o">(</span><span class="k">new</span> <span class="nc">AssertionError</span><span class="o">(</span><span class="n">s</span><span class="s">"download type not provided for digital book $id"</span><span class="o">))</span>
          <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">downloadStr</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="nc">DownloadType</span><span class="o">.</span><span class="n">fromString</span><span class="o">(</span><span class="n">downloadStr</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">dt</span> <span class="k">=&gt;</span>
              <span class="nc">Success</span><span class="o">(</span><span class="nc">EBook</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">title</span><span class="o">,</span> <span class="n">author</span><span class="o">,</span> <span class="n">dt</span><span class="o">))</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Depending on your perspective, that is arguably a long function. If
you think it is not so long, pretend that the table has a number of
other fields that must also be conditionally parsed to construct a
<code class="highlighter-rouge">Book</code>.</p>

<h3 id="tail-refactoring">Tail refactoring</h3>
<p>One possible approach is a a strategy I’m going to call
“tail-refactoring”, for lack of a better description. Basically, each
function does a little work or some error checking, and then calls the
next appropriate function in the chain.</p>

<p>You can imagine what kind of code will result. The functions are
smaller, but it’s hard to describe what each function does, and
functions occasionally have to carry along additional parameters that
they will ignore except to pass deeper into the call chain. Let’s take
a look at an example refactoring:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Failure</span><span class="o">,</span> <span class="nc">Success</span><span class="o">,</span> <span class="nc">Try</span><span class="o">}</span>

<span class="k">def</span> <span class="n">extractEBook</span><span class="o">(</span>
    <span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
    <span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">author</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">downloadTypeStrOpt</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">EBook</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">downloadTypeStrOpt</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">Failure</span><span class="o">(</span><span class="k">new</span> <span class="nc">AssertionError</span><span class="o">())</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">downloadTypeStr</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nc">DownloadType</span><span class="o">.</span><span class="n">fromString</span><span class="o">(</span><span class="n">downloadTypeStr</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">dt</span> <span class="k">=&gt;</span>
        <span class="nc">Success</span><span class="o">(</span><span class="nc">EBook</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">title</span><span class="o">,</span> <span class="n">author</span><span class="o">,</span> <span class="n">dt</span><span class="o">))</span>
      <span class="o">}</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="n">extractBook</span><span class="o">(</span>
    <span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
    <span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">author</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">formatStr</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">downloadTypeStrOpt</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">Book</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Format</span><span class="o">.</span><span class="n">fromString</span><span class="o">(</span><span class="n">formatStr</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Print</span> <span class="k">=&gt;</span>
      <span class="nc">Success</span><span class="o">(</span><span class="nc">PrintBook</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">title</span><span class="o">,</span> <span class="n">author</span><span class="o">))</span>
    <span class="k">case</span> <span class="nc">Digital</span> <span class="k">=&gt;</span>
      <span class="n">extractEBook</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">title</span><span class="o">,</span> <span class="n">author</span><span class="o">,</span> <span class="n">downloadTypeStrOpt</span><span class="o">)</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="n">findBookById</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">Book</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">DB</span><span class="o">.</span><span class="n">unsafeQueryUnique</span><span class="o">(</span><span class="n">sql</span><span class="s">"""select * from catalog where id = $id"""</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">row</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">id</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="s">"id"</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">title</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"title"</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">author</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"author"</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">formatStr</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"format"</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">downloadTypeStr</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="s">"download_type"</span><span class="o">)</span>
    <span class="n">extractBook</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">title</span><span class="o">,</span> <span class="n">author</span><span class="o">,</span> <span class="n">formatStr</span><span class="o">,</span> <span class="n">downloadTypeStr</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>As you can see, this form has more manageably-sized functions,
although they are still a little long. You can also see that the flow
of control is distributed through all three functions, which means
understanding the logic enough to modify or test it requires
understanding all three functions both individually and as a whole. To
follow the logic, we must trace the functions like a recursive descent
parser.</p>

<h3 id="refactoring-with-monads">Refactoring with Monads</h3>
<p>Without throwing exceptions and catching them at the top, it’s going
to be hard to do substantially better than the “tail-refactoring”
approach, unless we start to make use of the fact that we’re working
with <code class="highlighter-rouge">Try</code>, a data type that supports <code class="highlighter-rouge">flatMap</code>. More precisely, <code class="highlighter-rouge">Try</code>
has a monad instance - recall that monads let us model computational
effects that take place in sequence.</p>

<p>Let’s try to factor out smaller functions, each returning <code class="highlighter-rouge">Try</code>, and
then use a for-comprehension to specify the sequence of operations:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Failure</span><span class="o">,</span> <span class="nc">Success</span><span class="o">,</span> <span class="nc">Try</span><span class="o">}</span>

<span class="k">def</span> <span class="n">parseDownloadType</span><span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">DownloadType</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">o</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="nc">DownloadType</span><span class="o">.</span><span class="n">fromString</span><span class="o">)</span>
    <span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="k">new</span> <span class="nc">AssertionError</span><span class="o">(</span><span class="n">s</span><span class="s">"download type not provided for digital book $id"</span><span class="o">)))</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">findBookById</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">Book</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">row</span> <span class="k">&lt;-</span> <span class="nc">DB</span><span class="o">.</span><span class="n">unsafeQueryUnique</span><span class="o">(</span><span class="n">sql</span><span class="s">"""select * from catalog where id = $id"""</span><span class="o">)</span>
    <span class="n">format</span> <span class="k">&lt;-</span> <span class="nc">Format</span><span class="o">.</span><span class="n">fromString</span><span class="o">(</span><span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"format"</span><span class="o">))</span>
    <span class="n">id</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="s">"id"</span><span class="o">)</span>
    <span class="n">title</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"title"</span><span class="o">)</span>
    <span class="n">author</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"author"</span><span class="o">)</span>
    <span class="n">book</span> <span class="k">&lt;-</span> <span class="n">format</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Print</span> <span class="k">=&gt;</span>
        <span class="nc">Success</span><span class="o">(</span><span class="nc">PrintBook</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">title</span><span class="o">,</span> <span class="n">author</span><span class="o">))</span>
      <span class="k">case</span> <span class="nc">Digital</span> <span class="k">=&gt;</span>
        <span class="n">parseDownloadType</span><span class="o">(</span><span class="n">row</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="s">"download_type"</span><span class="o">),</span> <span class="n">id</span><span class="o">)</span>
          <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="nc">EBook</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">title</span><span class="o">,</span> <span class="n">author</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">book</span>
</code></pre></div></div>

<p>It’s less code, the functions are smaller, and the top-level function
dictates the entire flow of control. No function takes more than 2
arguments. These are testable, understandable functions. This version
really shows the power of using monads to sequence computation.</p>

<p>Now we are truly making use of the fact that <code class="highlighter-rouge">Try</code> has a monad instance
and not just another container class. We can simply describe the “happy
path” and trust <code class="highlighter-rouge">Try</code> to short-circuit computation if something erroneous
or unexpected occurs. In that case, <code class="highlighter-rouge">Try</code> captures the error and stops
computation there. The code does this without the need for explicit
branching logic.</p>

<h3 id="abstracting-effect-type">Abstracting effect type</h3>
<p>Now, let’s take this one step further - here’s where we achieve
buzzword compliance. Let’s abstract away from the effect, <code class="highlighter-rouge">Try</code>, and
instead make use of
<a href="https://typelevel.org/cats/api/cats/MonadError.html">MonadError</a>.
This lets us use a more diverse set of effect types, from
<a href="https://typelevel.org/cats-effect/datatypes/io.html">IO</a> to
<a href="https://monix.io/docs/3x/eval/task.html">Task</a>, so we can execute our
function in whatever asynchronous context we wish. This has the feel
of a tagless final strategy (although we aren’t worrying about
describing interpreters here).</p>

<p>Here we go:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.MonadError</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">def</span> <span class="n">parseDownloadType</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">o</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)(</span>
    <span class="k">implicit</span> <span class="n">me</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Throwable</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">DownloadType</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">me</span><span class="o">.</span><span class="n">fromOption</span><span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="k">new</span> <span class="nc">AssertionError</span><span class="o">(</span><span class="n">s</span><span class="s">"download type not provided for digital book $id"</span><span class="o">))</span>
    <span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">me</span><span class="o">.</span><span class="n">fromTry</span><span class="o">(</span><span class="nc">DownloadType</span><span class="o">.</span><span class="n">fromString</span><span class="o">(</span><span class="n">s</span><span class="o">)))</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">findBookById</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">me</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Throwable</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Book</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">row</span> <span class="k">&lt;-</span> <span class="nc">DB</span><span class="o">.</span><span class="n">queryUnique</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">sql</span><span class="s">"""select * from catalog where id = $id"""</span><span class="o">)</span>
    <span class="n">format</span> <span class="k">&lt;-</span> <span class="n">me</span><span class="o">.</span><span class="n">fromTry</span><span class="o">(</span><span class="nc">Format</span><span class="o">.</span><span class="n">fromString</span><span class="o">(</span><span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"format"</span><span class="o">)))</span>
    <span class="n">id</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="s">"id"</span><span class="o">)</span>
    <span class="n">title</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"title"</span><span class="o">)</span>
    <span class="n">author</span> <span class="k">=</span> <span class="n">row</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">"author"</span><span class="o">)</span>
    <span class="n">book</span> <span class="k">&lt;-</span> <span class="n">format</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Print</span> <span class="k">=&gt;</span>
        <span class="n">me</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="nc">PrintBook</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">title</span><span class="o">,</span> <span class="n">author</span><span class="o">))</span>
      <span class="k">case</span> <span class="nc">Digital</span> <span class="k">=&gt;</span>
        <span class="n">parseDownloadType</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">row</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="s">"downloadType"</span><span class="o">),</span> <span class="n">id</span><span class="o">)</span>
          <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="nc">EBook</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">title</span><span class="o">,</span> <span class="n">author</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">book</span>
</code></pre></div></div>

<p>The code isn’t much more complicated than the version using <code class="highlighter-rouge">Try</code> but
it adds a lot of flexibility. In a synchronous context, we could still
use <code class="highlighter-rouge">Try</code>. In that case, however, the database call is executed
eagerly, which means the function isn’t referentially transparent. We
can make the function referentially transparent by using a monad such
as <code class="highlighter-rouge">IO</code> or <code class="highlighter-rouge">Task</code> as the effect type and delaying the evaluation of
the database call until “the end of the universe”.</p>

<p>In this example, pay attention to the use of
<a href="https://typelevel.github.io/cats/api/cats/syntax/ApplicativeErrorExtensionOps.html#fromOption[A](oa:Option[A],ifEmpty:=%3EE):F[A]">fromOption</a>
and
<a href="https://typelevel.github.io/cats/api/cats/ApplicativeError.html#fromTry[A](t:scala.util.Try[A])(implicitev:Throwable%3C:%3CE):F[A]">fromTry</a>,
which adapt <code class="highlighter-rouge">Option</code> and <code class="highlighter-rouge">Try</code> to <code class="highlighter-rouge">F</code>. If you are using existing APIs
that aren’t already generalized to <code class="highlighter-rouge">MonadError</code> these methods adapt
common error types, but require very little ceremony to use.</p>

<h3 id="refactoring-strategy">Refactoring strategy</h3>

<p>When faced with a similar refactoring problem, consider whether you
can break the problem into a sequence of independently executable
steps, each of which can be wrapped in a monad. If so, begin by
describing the control flow in your refactored function with a monadic
for-comprehension. Don’t define the individual functions that comprise
the steps of the for-comprehension until you have filled in the
<code class="highlighter-rouge">yield</code> at the end. You can use pseudocode or stubs to minimize the
amount of code churn at the beginning. This is a great time to shuffle
steps around and work out exactly what arguments are needed and when,
as well as where they are coming from.</p>

<p>Once the top level function looks plausible, begin implenting the
steps of the for-comprehension. You can replace the stubs or
pseudocode you wrote by refactoring code from your original function.
If the original code did not operate in a monadic context, recall that
you can convert a simple function <code class="highlighter-rouge">A =&gt; B</code> to <code class="highlighter-rouge">F[A] =&gt; F[B]</code> using
<a href="https://typelevel.org/cats/api/cats/Monad.html#lift[A,B](f:A=%3EB):F[A]=%3EF[B]">lift</a>
(thanks,
<a href="https://typelevel.org/cats/typeclasses/functor.html">Functor</a>!). This
makes converting your existing code even easier.</p>

<h3 id="conclusion">Conclusion</h3>
<p>In this post, we have seen how we can use monads as an aid in
refactoring code to improve both readability and testability. We have
also demonstrated that we can do this in many cases without needing to
specify the monad in use <em>a priori</em>. As a result, we gain the
flexibility to choose the appropriate monad for our application,
independently of the program logic.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Tue, 07 Aug 2018 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2018/08/07/refactoring-monads.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/08/07/refactoring-monads.html</guid>
      </item>
    
      <item>
        <title>Testing in the wild</title>
        
          <dc:creator>etorreborre</dc:creator>
                
        <description><![CDATA[<p>Writing tests seems like a wonderful idea in theory but real systems can be a real pain to test. Today I want to show a few tips on how to
 use <a href="http://specs2.org">specs2</a> + <a href="http://www.scalacheck.org">ScalaCheck</a> to make some real-world testing somewhat bearable.</p>

<p>I am currently refactoring a big piece of code. Such refactoring is more like a small rewrite and some of our previous tests also have to be
 rewritten from scratch. I will try to introduce you to the problem first.</p>

<h3 id="creating-articles">Creating articles</h3>

<p>The system-du-jour is called “Panda” (we have animal names for many of our services in my team) and is tasked with the creation of articles
 on our legacy platform. An article is already a complicated beast. We have 3 levels of descriptions:</p>

<ul>
  <li>Model: the description for a pair of RunFast shoes, with the brand, the gender it applies to, the size chart it uses and so on</li>
  <li>Config: the description for a specific combination of colours - black RunFast -, images, material,… There can be several configs per model</li>
  <li>Simple: the description of a specific size - 37, 38, 39 -, price, stock, EAN (European Article Number),… There can be several simples
  per config</li>
</ul>

<p>This data can be created in our legacy catalog by calling a bunch of SOAP (yes you read that right) APIs and getting back, at each level,
  some identifiers for the model, the configs, the simples.</p>

<p>This in itself can already be quite complicated and the creation of an article could fail in many ways. But it gets a lot more complex
  considering that:</p>

<ol>
  <li>
    <p>we need the service to be idempotent and not try to recreate an existing model/config/simple twice if we receive the same event twice
(we are using Kafka as our events system)</p>
  </li>
  <li>
    <p>the articles sent by a merchant can be created incrementally, so some parts of the model/config/simple might have been already created
in a previous call</p>
  </li>
  <li>
    <p>we are not the only ones creating articles in the system! Indeed, our team creates articles coming from external merchants but there is
also an internal “wholesale” department buying their own articles and creating them in the catalog. In that case a merchant might add
a new config to an existing model or some simples to an existing config</p>
  </li>
  <li>
    <p>any step in the process could break and we have no support for transactions making sure that everything is created at once</p>
  </li>
</ol>

<p>So many things which can go wrong, how would you go about testing it?</p>

<h3 id="combinations-the-key-to-testing">Combinations, the key to testing</h3>

<p>After I started rewriting the tests I realized that our current approach was barely scratching the surface of all the possible combinations.
 In a similar case your first thought should be “ScalaCheck”! But this time I am going to use ScalaCheck with a twist. Instead of only modelling
 input data (model/config/simples) I am also modelling the system state:</p>

<ul>
  <li>we have a “mapping table” to store merchant articles that have already been created. In which states can it be?</li>
  <li>the legacy catalog can also be in many different states: does a particular model/config/simple already exist or not?</li>
</ul>

<p>If we translate this into a specs2 + ScalaCheck specification, we get a property like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ArticleServiceSpec</span> <span class="k">extends</span> <span class="nc">Specification</span> <span class="k">with</span> <span class="nc">ScalaCheck</span> <span class="o">{</span> <span class="k">def</span> <span class="n">is</span> <span class="k">=</span> <span class="n">s2</span><span class="s">"""

  &lt;insert long description of the problem and what we want to test&gt;

  run tests for model creation $modelCreation

"""</span>

  <span class="k">def</span> <span class="n">modelCreation</span> <span class="k">=</span> <span class="n">prop</span> <span class="o">{</span> <span class="o">(</span><span class="n">reviewed</span><span class="k">:</span> <span class="kt">Article</span><span class="o">,</span> <span class="n">catalog</span><span class="k">:</span> <span class="kt">TestCatalog</span><span class="o">,</span> <span class="n">mappings</span><span class="k">:</span> <span class="kt">TestMappings</span><span class="o">)</span> <span class="k">=&gt;</span>

    <span class="n">ok</span> <span class="c1">// for now
</span>

  <span class="o">}.</span><span class="n">setGen1</span><span class="o">(</span><span class="n">genArticleOneConfig</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We are creating a ScalaCheck property, with a specs2 method <code class="highlighter-rouge">prop</code> which gives us some additional power over row ScalaCheck properties.
 One thing we do here is to restrict the kind of generated <code class="highlighter-rouge">Article</code> to articles containing only one new configuration because we want to
  focus first on all the possible cases of model creation. So we pass a specific generator to the property, just for the first argument
  with <code class="highlighter-rouge">setGen1</code>.</p>

<p>Then, as you can see above, we return <code class="highlighter-rouge">ok</code> which is a specs2 result. This is because <code class="highlighter-rouge">prop</code> allows us to return anything that specs2 recognizes
  as a <code class="highlighter-rouge">Result</code> (with the <code class="highlighter-rouge">org.specs2.execute.AsResult</code> typeclass) and then we are not limited to booleans in our ScalaCheck properties but
  we can use specs2 matchers as well (we are going use this in the next step).</p>

<p>Now, for testing we need to do the following:</p>

<ol>
  <li>capture the state before the article creation</li>
  <li>execute the article creation</li>
  <li>capture the state after the article creation</li>
  <li>compare the resulting state to expected values</li>
</ol>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">val</span> <span class="n">before</span> <span class="k">=</span> <span class="n">createBeforeState</span><span class="o">(</span><span class="n">reviewed</span><span class="o">,</span> <span class="n">catalog</span><span class="o">,</span> <span class="n">mappings</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">run</span><span class="o">(</span><span class="n">createService</span><span class="o">(</span><span class="n">catalog</span><span class="o">,</span> <span class="n">mappings</span><span class="o">).</span><span class="n">createArticles</span><span class="o">[</span><span class="kt">R</span><span class="o">](</span><span class="n">reviewed</span><span class="o">))</span>
  <span class="k">val</span> <span class="n">after</span>  <span class="k">=</span> <span class="n">createAfterState</span><span class="o">(</span><span class="n">reviewed</span><span class="o">,</span> <span class="n">catalog</span><span class="o">,</span> <span class="n">mappings</span><span class="o">,</span> <span class="n">result</span><span class="o">)</span>
</code></pre></div></div>

<p>What are <code class="highlighter-rouge">BeforeState</code> and <code class="highlighter-rouge">AfterState</code>? They are custom case classes modelling the variables we are interested in:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">case</span> <span class="k">class</span> <span class="nc">BeforeState</span><span class="o">(</span>
   <span class="n">modelIdProvided</span><span class="k">:</span>       <span class="kt">Boolean</span><span class="o">,</span>
   <span class="n">modelNeedsToBeCreated</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span>
   <span class="n">modelExistsInCatalog</span><span class="k">:</span>  <span class="kt">Boolean</span><span class="o">,</span>
   <span class="n">mappingExists</span><span class="k">:</span>         <span class="kt">Boolean</span><span class="o">)</span>

 <span class="k">case</span> <span class="k">class</span> <span class="nc">AfterState</span><span class="o">(</span>
   <span class="n">modelExistsInCatalog</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span>
   <span class="n">mappingExists</span><span class="k">:</span>        <span class="kt">Boolean</span><span class="o">,</span>
   <span class="n">exception</span><span class="k">:</span>            <span class="kt">Option</span><span class="o">[</span><span class="kt">Throwable</span><span class="o">])</span>
</code></pre></div></div>

<p>The first 2 variables of <code class="highlighter-rouge">BeforeState</code> are a bit curious. The first one gives us a <code class="highlighter-rouge">ModelId</code> if upstream systems know that a model already
  exist. Then how could <code class="highlighter-rouge">modelNeedsToBeCreated</code> be true? Well, the events we receive don’t rule out this possibility. This is the
  current state of our domain data and arguably we should model things differently and reject malformed events right away. This is where the
  saying <a href="https://www.obeythetestinggoat.com/book/chapter_purist_unit_tests.html#_listen_to_your_tests_ugly_tests_signal_a_need_to_refactor">“Listen to your tests”</a> comes in :-).</p>

<p>If we count the number of combinations we end up with 16 possibilities for our “before state” and 8 possible outcomes. How can we represent
   all those combinations in our test?</p>

<h3 id="datatables">DataTables</h3>

<p>Specs2 offers to possibility to create tables of data directly inside the code for better readability of actual and expected values
 when you have lots of different possible combinations. Here is what we can do here</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">val</span> <span class="n">results</span> <span class="k">=</span>
  <span class="s">"#"</span> <span class="o">|</span> <span class="s">"model-id"</span> <span class="o">|</span> <span class="s">"create"</span> <span class="o">|</span> <span class="s">"in catalog"</span> <span class="o">|</span> <span class="s">"mapping"</span> <span class="o">||</span> <span class="s">"in catalog"</span>  <span class="o">|</span> <span class="s">"mapping"</span> <span class="o">|</span> <span class="s">"exception"</span> <span class="o">|</span> <span class="s">"comment"</span> <span class="o">|</span>
  <span class="mi">1</span>   <span class="o">!</span>  <span class="kc">true</span>      <span class="o">!</span> <span class="kc">true</span>     <span class="o">!</span> <span class="kc">true</span>         <span class="o">!</span> <span class="kc">true</span>      <span class="o">!!</span> <span class="kc">true</span>          <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">false</span>       <span class="o">!</span> <span class="s">"no model is created, because it can be found in the catalog, creation data is ignored"</span> <span class="o">|</span>
  <span class="mi">2</span>   <span class="o">!</span>  <span class="kc">true</span>      <span class="o">!</span> <span class="kc">true</span>     <span class="o">!</span> <span class="kc">true</span>         <span class="o">!</span> <span class="kc">false</span>     <span class="o">!!</span> <span class="kc">true</span>          <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">false</span>       <span class="o">!</span> <span class="s">"we just updated the mapping"</span> <span class="o">|</span>
  <span class="mi">3</span>   <span class="o">!</span>  <span class="kc">true</span>      <span class="o">!</span> <span class="kc">true</span>     <span class="o">!</span> <span class="kc">false</span>        <span class="o">!</span> <span class="kc">true</span>      <span class="o">!!</span> <span class="kc">false</span>         <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">true</span>        <span class="o">!</span> <span class="s">"the config creation must fail, no existing model"</span> <span class="o">|</span>
  <span class="mi">4</span>   <span class="o">!</span>  <span class="kc">true</span>      <span class="o">!</span> <span class="kc">true</span>     <span class="o">!</span> <span class="kc">false</span>        <span class="o">!</span> <span class="kc">false</span>     <span class="o">!!</span> <span class="kc">true</span>          <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">false</span>       <span class="o">!</span> <span class="s">"the given model-id is ignored (a warning is logged)"</span> <span class="o">|</span>
  <span class="mi">5</span>   <span class="o">!</span>  <span class="kc">true</span>      <span class="o">!</span> <span class="kc">false</span>    <span class="o">!</span> <span class="kc">true</span>         <span class="o">!</span> <span class="kc">true</span>      <span class="o">!!</span> <span class="kc">true</span>          <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">false</span>       <span class="o">!</span> <span class="s">"no model is created, because it can be found in the catalog"</span> <span class="o">|</span>
  <span class="mi">6</span>   <span class="o">!</span>  <span class="kc">true</span>      <span class="o">!</span> <span class="kc">false</span>    <span class="o">!</span> <span class="kc">true</span>         <span class="o">!</span> <span class="kc">false</span>     <span class="o">!!</span> <span class="kc">true</span>          <span class="o">!</span> <span class="kc">false</span>     <span class="o">!</span> <span class="kc">false</span>       <span class="o">!</span> <span class="s">"the mappings are not updated because we did not create the model"</span> <span class="o">|</span>
  <span class="mi">7</span>   <span class="o">!</span>  <span class="kc">true</span>      <span class="o">!</span> <span class="kc">false</span>    <span class="o">!</span> <span class="kc">false</span>        <span class="o">!</span> <span class="kc">true</span>      <span class="o">!!</span> <span class="kc">false</span>         <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">true</span>        <span class="o">!</span> <span class="s">"no corresponding model in the catalog"</span> <span class="o">|</span>
  <span class="mi">8</span>   <span class="o">!</span>  <span class="kc">true</span>      <span class="o">!</span> <span class="kc">false</span>    <span class="o">!</span> <span class="kc">false</span>        <span class="o">!</span> <span class="kc">false</span>     <span class="o">!!</span> <span class="kc">false</span>         <span class="o">!</span> <span class="kc">false</span>     <span class="o">!</span> <span class="kc">true</span>        <span class="o">!</span> <span class="s">"no corresponding model in the catalog"</span> <span class="o">|</span>
  <span class="mi">9</span>   <span class="o">!</span>  <span class="kc">false</span>     <span class="o">!</span> <span class="kc">true</span>     <span class="o">!</span> <span class="kc">true</span>         <span class="o">!</span> <span class="kc">true</span>      <span class="o">!!</span> <span class="kc">true</span>          <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">false</span>       <span class="o">!</span> <span class="s">"we use the mapping table to retrieve the model id and the catalog for the model"</span> <span class="o">|</span>
  <span class="mi">10</span>  <span class="o">!</span>  <span class="kc">false</span>     <span class="o">!</span> <span class="kc">true</span>     <span class="o">!</span> <span class="kc">true</span>         <span class="o">!</span> <span class="kc">false</span>     <span class="o">!!</span> <span class="kc">true</span>          <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">false</span>       <span class="o">!</span> <span class="s">"in this case the model already exists in the catalag but we have no way to know"</span> <span class="o">|</span>
  <span class="mi">11</span>  <span class="o">!</span>  <span class="kc">false</span>     <span class="o">!</span> <span class="kc">true</span>     <span class="o">!</span> <span class="kc">false</span>        <span class="o">!</span> <span class="kc">true</span>      <span class="o">!!</span> <span class="kc">false</span>         <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">true</span>        <span class="o">!</span> <span class="s">"the mapping exists but not the data in the catalog"</span> <span class="o">|</span>
  <span class="mi">12</span>  <span class="o">!</span>  <span class="kc">false</span>     <span class="o">!</span> <span class="kc">true</span>     <span class="o">!</span> <span class="kc">false</span>        <span class="o">!</span> <span class="kc">false</span>     <span class="o">!!</span> <span class="kc">true</span>          <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">false</span>       <span class="o">!</span> <span class="s">"regular model + config creation case"</span> <span class="o">|</span>
  <span class="mi">13</span>  <span class="o">!</span>  <span class="kc">false</span>     <span class="o">!</span> <span class="kc">false</span>    <span class="o">!</span> <span class="kc">true</span>         <span class="o">!</span> <span class="kc">true</span>      <span class="o">!!</span> <span class="kc">true</span>          <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">true</span>        <span class="o">!</span> <span class="s">"there is no model id and no creation data"</span> <span class="o">|</span>
  <span class="mi">14</span>  <span class="o">!</span>  <span class="kc">false</span>     <span class="o">!</span> <span class="kc">false</span>    <span class="o">!</span> <span class="kc">true</span>         <span class="o">!</span> <span class="kc">false</span>     <span class="o">!!</span> <span class="kc">true</span>          <span class="o">!</span> <span class="kc">false</span>     <span class="o">!</span> <span class="kc">true</span>        <span class="o">!</span> <span class="s">"the model exists in the catalog but we have no way to retrieve it"</span> <span class="o">|</span>
  <span class="mi">15</span>  <span class="o">!</span>  <span class="kc">false</span>     <span class="o">!</span> <span class="kc">false</span>    <span class="o">!</span> <span class="kc">false</span>        <span class="o">!</span> <span class="kc">true</span>      <span class="o">!!</span> <span class="kc">false</span>         <span class="o">!</span> <span class="kc">true</span>      <span class="o">!</span> <span class="kc">true</span>        <span class="o">!</span> <span class="s">"model id found in the mapping but not in the catalog"</span> <span class="o">|</span>
  <span class="mi">16</span>  <span class="o">!</span>  <span class="kc">false</span>     <span class="o">!</span> <span class="kc">false</span>    <span class="o">!</span> <span class="kc">false</span>        <span class="o">!</span> <span class="kc">false</span>     <span class="o">!!</span> <span class="kc">false</span>         <span class="o">!</span> <span class="kc">false</span>     <span class="o">!</span> <span class="kc">true</span>        <span class="o">!</span> <span class="s">"not enough data to create the model nor the mapping"</span>

 <span class="n">checkState</span><span class="o">(</span><span class="n">before</span><span class="o">,</span> <span class="n">after</span><span class="o">,</span> <span class="n">parseTable</span><span class="o">(</span><span class="n">results</span><span class="o">))</span>
</code></pre></div></div>
<p>This looks like a strange piece of code but this is actually all valid Scala syntax! <code class="highlighter-rouge">results</code> is a specs2 <code class="highlighter-rouge">DataTable</code> created out of:</p>

<ul>
  <li>a header where column names are separated with <code class="highlighter-rouge">|</code></li>
  <li>rows that are also separated with <code class="highlighter-rouge">|</code></li>
  <li>cells on each row, separated with <code class="highlighter-rouge">!</code></li>
</ul>

<p>We can also use <code class="highlighter-rouge">||</code> and <code class="highlighter-rouge">!!</code> as separators and we use this possibility here to visually distinguish input columns from expected results
  columns.</p>

<h3 id="running-the-tests">Running the tests</h3>

<p>The table above is like a big “truth table” for all our input conditions. Running a test consists in:</p>

<ol>
  <li>using the ‘before state’ to locate one of the row</li>
  <li>getting the expected ‘after state’ from the expected columns</li>
  <li>comparing the actual ‘after state’ with the expected one</li>
</ol>

<p>The funny thing is that before executing the test I did not exactly know what the code would actually do! So I just let the test guide me.
I put some expected values, run the test and in case of a failure, inspect the input values, think hard about why the code is not behaving the
way I think it should.</p>

<p>One question comes to mind: since this is a ScalaCheck property, how can we be sure we hit all the cases in the table? The first thing we
can do is to massively increase the number of tests that are going to be executed for this property, like 10000. With specs2 you have many
ways to do this. You can set the <code class="highlighter-rouge">minTestsOk</code> ScalaCheck property directly in the code:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">modelCreation</span> <span class="k">=</span> <span class="n">prop</span> <span class="o">{</span> <span class="o">(</span><span class="n">reviewed</span><span class="k">:</span> <span class="kt">Article</span><span class="o">,</span> <span class="n">catalog</span><span class="k">:</span> <span class="kt">TestCatalog</span><span class="o">,</span> <span class="n">mappings</span><span class="k">:</span> <span class="kt">TestMappings</span><span class="o">)</span> <span class="k">=&gt;</span>
 <span class="o">...</span>
<span class="o">}.</span><span class="n">setGen1</span><span class="o">(</span><span class="n">genArticleOneConfig</span><span class="o">).</span><span class="n">set</span><span class="o">(</span><span class="n">minTestsOk</span> <span class="k">=</span> <span class="mi">10000</span><span class="o">)</span>
</code></pre></div></div>

<p>But you can also do it from sbt:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sbt&gt; testOnly *ArticleServiceSpec -- scalacheck.mintestsok 10000
</code></pre></div></div>

<p>This is quite cool because this means that you don’t have to recompile the code if you just want to run a ScalaCheck property with more tests.</p>

<h3 id="checking-the-results">Checking the results</h3>

<p>As I wrote, when a specific combination would fail I had to inspect the inputs/outputs and think hard, maybe my expectations are wrong and
I needed to change the expected values? To this end I added a “line number” column to the table and reported it in the result:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> [error]  &gt; On line 6
 [error]
 [error]  Before
 [error]    model id set:             true
 [error]    model creation data set:  false
 [error]    model exists in catalog : true
 [error]    model id mapping exists:  false
 [error]
 [error]  After
 [error]    model exists in catalog:  true
 [error]      expected:               true
 [error]
 [error]    model id mapping exists:  false
 [error]      expected:               false
 [error]
 [error]    exception thrown:         None
 [error]      expected:               Some
</code></pre></div></div>

<p>This reporting is all done in the <code class="highlighter-rouge">checkState</code> method which is:</p>

<ul>
  <li>doing the comparison between actual and expected values</li>
  <li>displaying the before / after states</li>
  <li>displaying the difference between expected and actual values</li>
</ul>

<p>Actually I even enhanced the display of actual/expected values by coloring them in green or red in the console, using one of specs2 helper
 classes <code class="highlighter-rouge">org.specs2.text.AnsiColors</code>:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">org.specs2.text.AnsiColors</span>

<span class="k">def</span> <span class="n">withColor</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">actual</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">expected</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">condition</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span> <span class="k">=</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span><span class="kt">A</span><span class="o">,</span> <span class="n">e</span><span class="k">:</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">==</span> <span class="n">e</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
  <span class="c1">// color the expected value in green or red, depending on the test success
</span>  <span class="n">color</span><span class="o">(</span><span class="n">expected</span><span class="o">.</span><span class="n">toString</span><span class="o">,</span> <span class="k">if</span> <span class="o">(</span><span class="n">condition</span><span class="o">(</span><span class="n">actual</span><span class="o">,</span> <span class="n">expected</span><span class="o">))</span> <span class="n">green</span> <span class="k">else</span> <span class="n">red</span><span class="o">)</span>

<span class="n">withColor</span><span class="o">(</span><span class="n">after</span><span class="o">.</span><span class="n">modelExistsInCatalog</span><span class="o">,</span> <span class="n">expected</span><span class="o">.</span><span class="n">modelExistsInCatalog</span><span class="o">)</span>
</code></pre></div></div>

<p>Both the line numbering and the coloring really helps in fixing issues fast!</p>

<h3 id="replaying-tests">Replaying tests</h3>

<p>A vexing issue with property-based testing is that being random, it will generate random failures every time you re-run a property. So you
can’t re-run a property with the exact same input data. But that was before ScalaCheck 1.14! Now we can pass the seed that is used by the random
 generator to faithfully re-run a failing test. Indeed when a property fails, specs2 will display the current seed value:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[error]  The seed is 1tRQ5-jdfEABEXz1y62Cs0C4vNJQKyXps9eWvbjJPSI=
</code></pre></div></div>

<p>And you can pass this value on the command line to re-run with exactly the failing input data:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sbt&gt; testOnly *ArticleServiceSpec -- scalacheck.seed 1tRQ5-jdfEABEXz1y62Cs0C4vNJQKyXps9eWvbjJPSI=
</code></pre></div></div>

<p>This is super-convenient for debugging!</p>

<h3 id="comments">Comments</h3>

<p>Finally when a given row in the table passes, there is a <code class="highlighter-rouge">comment</code> column to register the reason for this specific outcomes so that future
generations have a sense of <em>why</em> the code is behaving that way. In that sense this whole approach is a bit like having “golden tests” which
are capturing the behaviour of the system as a series of examples</p>

<h3 id="conclusion">Conclusion</h3>

<p>This post shows how we can leverage features from both specs2 and ScalaCheck to make our tests more exhaustive, more readable, more debuggable.
The reality is still more complicated than this:</p>

<ul>
  <li>
    <p>the total number of combinations would make our table very large. So there are actually several tables (one for model creation, one for
 config creation,…) where we assume that some variables are fixed while others can move</p>
  </li>
  <li>
    <p>specs2 datatables are currently limited to 10 columns. The <code class="highlighter-rouge">DataTable</code> code is actually code generated and the latest version only has 10
 columns. One easy first step would be to generate more code (and go up to the magic 22 number for example) or to re-implement this functionality
 as some kind of HList</p>
  </li>
  <li>
    <p>the input state is not trivial to generate because the objects are dependent. The <code class="highlighter-rouge">ModelId</code> of a generated model must be exactly the same
 as the one used in the <code class="highlighter-rouge">Mappings</code> component to register that a model has already been created. So in reality the 2 generators for <code class="highlighter-rouge">Article</code> and
 <code class="highlighter-rouge">Mappings</code> are not totally independent</p>
  </li>
  <li>
    <p>the <code class="highlighter-rouge">Arbitrary</code> instance for <code class="highlighter-rouge">Article</code> can give us articles with 5 <code class="highlighter-rouge">Configs</code> and 10 <code class="highlighter-rouge">Simples</code> but for this test, one <code class="highlighter-rouge">Config</code> and one <code class="highlighter-rouge">Simple</code>
  are enough. Unfortunately we miss a nice language to express those generation condition and easily tweak the default <code class="highlighter-rouge">Arbitrary[Article]</code> (I
  will explore a solution to this problem during the next Haskell eXchange)</p>
  </li>
  <li>
    <p>why are we even using ScalaCheck to generate all the cases since we already statically know all the possible 16 input conditions? We could
  invert this relation and have a ScalaCheck property generated for each row of the datatable with some arbitrary data for the model (and some
fixed data given by the current row). This would not necessarily lead to easier code to implement.</p>
  </li>
</ul>

<p>Anyway despite those remaining questions and issues I hope this post gives you some new ideas on how to be more effective when writing tests
  with specs2 and ScalaCheck, please comment on your own experiments!</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 12 Jul 2018 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2018/07/12/testing-in-the-wild.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/07/12/testing-in-the-wild.html</guid>
      </item>
    
      <item>
        <title>Optimizing Tagless Final – Part 2 – Monadic programs</title>
        
          <dc:creator>lukajcb</dc:creator>
                
        <description><![CDATA[<p>In our previous post on optimizing tagless final programs we learned how we could use the <a href="https://github.com/LukaJCB/sphynx">sphynx library</a> to derive some optimization schemes for your tagless final code. In case you missed it and want to read up on it, you can find it <a href="https://typelevel.org/blog/2017/12/27/optimizing-final-tagless.html">right here</a> or you can watch my presentation on the topic <a href="https://www.youtube.com/watch?v=E9iRYNuTIYA">here</a>, but you should be able to follow this blog post without going through it all in detail.</p>

<h2 id="optimizing-monadic-programs">Optimizing monadic programs</h2>

<p>One of the questions I’ve been getting a lot, is if we can also do something like that for the monadic parts of our program.
The answer is yes, we can, however it will have to be quite a bit different.</p>

<p>I don’t think the differences are quite obvious, so we’ll go through them step by step.
With applicative programs, we’re optimizing a bunch of independent instructions.
That means, we can look at all of them and extract information out of them statically (i.e. without running the interpreter).
They can be seen as a sequence of instructions that we can fold down to a single monoid <code class="highlighter-rouge">M</code>, that holds the information that we need to optimize.
We then used that monoid to recreate a new interpreter that can take this extra information into account.</p>

<p>With monadic programs, we do not have such luxury.
We can only step through each of our instructions one at a time, because every instruction depends on the results of the prior one.
This means that we cannot extract any information beyond the very first instruction we have.
That might seem like a deal breaker, but there’s still a few things we can do.
We could, for example, build up our monoid <code class="highlighter-rouge">M</code> dynamically, after each monadic instruction.
Then, before invoking the next computation in the monadic sequence, we could take that monoid and recreate that next computation with that extra information.</p>

<p>Now, that might sound super abstract to you, and I wouldn’t disagree, so let’s look at a quick example.
Say, we’re using the <code class="highlighter-rouge">KVStore</code> algebra again from last time:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span>
  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We could optimize programs with this algebra by caching the results of <code class="highlighter-rouge">get</code> and we could use that same cache to also cache key-value pairs we inserted using <code class="highlighter-rouge">put</code>.</p>

<p>So given this example program:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">](</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">F</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="s">"cat"</span><span class="o">)</span>
  <span class="n">dog</span> <span class="k">&lt;-</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span>
  <span class="n">cat</span> <span class="k">&lt;-</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">dog</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="s">"dog"</span><span class="o">))</span>
  <span class="n">cat2</span> <span class="k">&lt;-</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"cat"</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="nc">List</span><span class="o">(</span><span class="n">dog</span><span class="o">,</span> <span class="n">cat</span><span class="o">,</span> <span class="n">cat2</span><span class="o">).</span><span class="n">flatten</span>
</code></pre></div></div>

<p>The naively interpreted program would be doing the following things:</p>
<ol>
  <li>put the value “cat” into the store with the <code class="highlighter-rouge">key</code> passed by the user</li>
  <li>get the value “cat” back out of the store</li>
  <li>access the key-value store and maybe return a value associated with the key “cat”</li>
  <li>access the store again with the same “cat” key.</li>
</ol>

<p>Now if accessing the key-value store means going through a network layer this is of course highly inefficient.
Ideally our fully optimized program should do the following things:</p>
<ol>
  <li>put the value “cat” into the store with the <code class="highlighter-rouge">key</code> parameter passed by the user and cache it.</li>
  <li>access the cache to get the value “cat” associated with <code class="highlighter-rouge">key</code></li>
  <li>access the key-value-store and maybe return a value associated with the key “cat”</li>
  <li>access the cache to return the previous result for the “cat” key.</li>
</ol>

<p>Cool, next, let’s look at how we might get there.
First the type of our cache, which for our case can just be a <code class="highlighter-rouge">Map[String, String]</code>, but generically could just be any monoid.</p>

<p>Now what we want to do is transform any interpreter for <code class="highlighter-rouge">KVStore</code> programs into interpreters that</p>
<ol>
  <li>Look in the cache before performing a <code class="highlighter-rouge">get</code> action with the actual interpreter</li>
  <li>Write to the cache after performing either a <code class="highlighter-rouge">get</code> or <code class="highlighter-rouge">put</code> action.</li>
</ol>

<p>So how can we get there? It seems like we want to thread a bunch of state through our program, that we want to both read and write to.
If you’re familiar with FP folklore you might recognize that that description fits almost exactly to the <code class="highlighter-rouge">State</code> monad.
Furthermore, because we know that our <code class="highlighter-rouge">F[_]</code> is a monad, that means the <code class="highlighter-rouge">StateT</code> monad transformer over <code class="highlighter-rouge">F</code> will also be a monad.</p>

<p>Okay with that said, let’s try to develop function that turns any interpreter <code class="highlighter-rouge">KVStore[F]</code> into an interpreter into <code class="highlighter-rouge">StateT[F, M, A]</code>, so an <code class="highlighter-rouge">KVStore[StateT[F, M, ?]]</code>, where <code class="highlighter-rouge">M</code> is the monoid we use to accumulate our extracted information.
We’ll start with the <code class="highlighter-rouge">put</code> operation.
For <code class="highlighter-rouge">put</code>, we’ll want to call the interpreter to perform the action and then modify the state by adding the retrieved value into our cache.
To make the code a bit more legible we’ll also define a few type aliases.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Cache</span> <span class="o">=</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">]</span>
<span class="k">type</span> <span class="kt">CachedAction</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">A</span><span class="o">]</span>

<span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">interp</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">CachedAction</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">CachedAction</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">v</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">CachedAction</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">StateT</span><span class="o">.</span><span class="n">liftF</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">Unit</span><span class="o">](</span><span class="n">interp</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">v</span><span class="o">))</span> <span class="o">*&gt;</span> <span class="nc">StateT</span><span class="o">.</span><span class="n">modify</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">updated</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">v</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">CachedAction</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>So far, so good, now let’s have a look at what to do with the <code class="highlighter-rouge">get</code> function.
It’s a bit more complex, because we want to read from the cache, as well as write to it if the cache didn’t include our key.
What we have to do is, get our current state, then check if the key is included, if so, just return it, otherwise call the interpreter to perform the <code class="highlighter-rouge">get</code> action and then write that into the cache.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">CachedAction</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">cache</span> <span class="k">&lt;-</span> <span class="nc">StateT</span><span class="o">.</span><span class="n">get</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span><span class="o">]</span>
  <span class="n">result</span> <span class="k">&lt;-</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
              <span class="k">case</span> <span class="n">s</span> <span class="k">@</span> <span class="nc">Some</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">pure</span><span class="o">[</span><span class="kt">CachedAction</span><span class="o">]</span>
              <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">StateT</span><span class="o">.</span><span class="n">liftF</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="n">interp</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">))</span>
                             <span class="o">.</span><span class="n">flatTap</span><span class="o">(</span><span class="n">updateCache</span><span class="o">(</span><span class="n">key</span><span class="o">))</span>
            <span class="o">}</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">result</span>

<span class="k">def</span> <span class="n">updateCache</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="n">ov</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">CachedAction</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">ov</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">StateT</span><span class="o">.</span><span class="n">modify</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">updated</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">v</span><span class="o">))</span>
  <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="o">().</span><span class="n">pure</span><span class="o">[</span><span class="kt">CachedAction</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This is quite something, so let’s try to walk through it step by step.
First we get the cache using <code class="highlighter-rouge">StateT.get</code>, so far so good.
Now, we check if the key is in the cache using <code class="highlighter-rouge">cache.get(key)</code>.
The result of that is an <code class="highlighter-rouge">Option[String]</code>, which we can pattern match to see if it did include the key.
If it did, then we can just return that <code class="highlighter-rouge">Option[String]</code> by lifting it into <code class="highlighter-rouge">CachedAction</code> using <code class="highlighter-rouge">pure</code>.
If it wasn’t in the cache, things are a bit more tricky.
First, we lift the interpreter action into <code class="highlighter-rouge">CachedAction</code> using <code class="highlighter-rouge">StateT.liftF</code>, that gives us a <code class="highlighter-rouge">CachedAction[Option[String]]</code>, which is already the return type we need and we could return it right there, but we still need to update the cache.
Because we already have the return type we need, we can use the <code class="highlighter-rouge">flatTap</code> combinator.
Then inside the <code class="highlighter-rouge">updateCache</code> function, we take the result of our interpreter, which is again an <code class="highlighter-rouge">Option[String]</code>, and update the cache if the value is present.
If it’s empty, we don’t want to do anything at all, so we just lift unit into <code class="highlighter-rouge">CachedAction</code>.</p>

<p>In case you’re wondering <code class="highlighter-rouge">flatTap</code> works just like <code class="highlighter-rouge">flatMap</code>, but will then <code class="highlighter-rouge">map</code> the result type back to the original one, making it a bit similar to a monadic version of the left shark (<code class="highlighter-rouge">&lt;*</code>) operator, making it very useful for these “fire-and-forget” operations.
It’s defined like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">flatTap</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">fa</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">b</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">))</span>
</code></pre></div></div>

<p>And with that we now have a working function to turn any interpreter into an optimized interpreter.
We can also generalize this fairly easily into a function that will do all of the wiring for us.
To do so, we’ll generalize away from <code class="highlighter-rouge">KVStore</code> and <code class="highlighter-rouge">Cache</code> and instead use generic <code class="highlighter-rouge">Alg[_[_]]</code> and <code class="highlighter-rouge">M</code> parameters:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">optimize</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">M:</span> <span class="kt">Monoid</span>, <span class="kt">A</span><span class="o">]</span>
  <span class="o">(</span><span class="n">program</span><span class="k">:</span> <span class="kt">MonadProgram</span><span class="o">[</span><span class="kt">Alg</span>, <span class="kt">A</span><span class="o">])</span>
  <span class="o">(</span><span class="n">withState</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Alg</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">interpreter</span> <span class="k">=&gt;</span>
    <span class="n">program</span><span class="o">(</span><span class="n">withState</span><span class="o">(</span><span class="n">interpreter</span><span class="o">)).</span><span class="n">runEmptyA</span>
</code></pre></div></div>

<p>Just like last time, we have to use a <code class="highlighter-rouge">MonadProgram</code> wrapper around <code class="highlighter-rouge">Alg[F] =&gt; F[A]</code>, because Scala lacks rank-N types which would allow us to define values that work over ALL type constructors <code class="highlighter-rouge">F[_]: Monad</code> (Fortunately however, this will very probably soon be fixed in dotty, PR <a href="https://github.com/lampepfl/dotty/pull/4672">here</a>).</p>

<p>Now let’s see if we can actually use it, by checking it with a test interpreter that will print whenever we retrieve or insert values into the <code class="highlighter-rouge">KVStore</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">optimize</span><span class="o">[</span><span class="kt">KVStore</span>, <span class="kt">IO</span>, <span class="kt">Cache</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="n">program</span><span class="o">(</span><span class="s">"mouse"</span><span class="o">))(</span><span class="n">transform</span><span class="o">)</span>
  <span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">printInterpreter</span><span class="o">)</span>
  <span class="o">.</span><span class="n">unsafeRunSync</span><span class="o">()</span>

<span class="c1">// Put key: mouse, value: cat
// Get key: cat
</span></code></pre></div></div>

<p>It works and does exactly what we want! 
Nice! We could end this blog post right here, but there’s still a couple of things I’d like to slightly alter.</p>

<h3 id="refining-the-api">Refining the API</h3>

<p>As you were able to tell the implementation of our transformation from the standard interpreter to the optimized interpreter is already quite complex and that is for a very very simple algebra that doesn’t do a lot.
Even then, I initially wrote an implementation that packs everything in a single <code class="highlighter-rouge">StateT</code> constructor to avoid the overhead of multiple calls to <code class="highlighter-rouge">flatMap</code>, but considered the version I showed here more easily understandable.
For more involved algebras and more complex programs, all of this will become a lot more difficult to manage.
In our last blog post we were able to clearly separate the extraction of our information from the rebuilding of our interpreter with that information.
Let’s have a look at if we can do the same thing here.</p>

<p>First we’ll want to define an extraction method.
For applicative programs we used <code class="highlighter-rouge">Const[M, ?]</code>, however that cannot work here, as <code class="highlighter-rouge">Const</code> doesn’t have a <code class="highlighter-rouge">Monad</code> instance and also, because for extraction with monadic programs, we need to actually take the result of the computation into account. 
That means, that for every operation in our algebra, we want a way to turn it into our monoid <code class="highlighter-rouge">M</code>.
With that said, it seems we want a function <code class="highlighter-rouge">A =&gt; M</code>, where <code class="highlighter-rouge">A</code> is the result type of the operations in our algebra.
So what we can do here is define an algebra for <code class="highlighter-rouge">? =&gt; M</code>, in types an <code class="highlighter-rouge">Alg[? =&gt; M]</code>.</p>

<p>Let’s try to do define such an interpreter for our <code class="highlighter-rouge">KVStore</code> along with <code class="highlighter-rouge">Cache</code>/<code class="highlighter-rouge">Map[String, String</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">extract</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">Cache</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">Cache</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Cache</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Map</span><span class="o">(</span><span class="n">key</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">Map</span><span class="o">.</span><span class="n">empty</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=&gt;</span> <span class="nc">Cache</span> <span class="k">=</span>
    <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Map</span><span class="o">(</span><span class="n">key</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Just as before we want to extract the cache piece by piece with every monadic step.
Whenever we get an <code class="highlighter-rouge">Option[String]</code> after using <code class="highlighter-rouge">get</code>, we can then turn that into a <code class="highlighter-rouge">Cache</code> if it’s non-empty.
The same goes for <code class="highlighter-rouge">put</code>, where we’ll create a Map using the key-value pair.
We now have a way to turn the results of our algebra operations into our information <code class="highlighter-rouge">M</code>, so far so good!</p>

<p>Next, we’ll need a way to rebuild our operations using that extracted information.
For that, let’s consider what that actually means.
For applicative programs this meant a function that given a state <code class="highlighter-rouge">M</code> and an interpreter <code class="highlighter-rouge">Alg[F]</code>, gave a  reconstructed interpreter inside the <code class="highlighter-rouge">F</code> context <code class="highlighter-rouge">F[Alg[F]]</code>.
So a function <code class="highlighter-rouge">(M, Alg[F]) =&gt; F[Alg[F]]</code>.</p>

<p>For monadic programs, there’s no need to precompute any values, as we’re dealing with fully sequential computations that can potentially update the state after every evaluation.
So we’re left with a function <code class="highlighter-rouge">(M, Alg[F]) =&gt; Alg[F]</code>.
Let’s try building that for <code class="highlighter-rouge">KVStore</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">rebuild</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">M</span><span class="o">,</span> <span class="n">interp</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">o</span> <span class="k">@</span> <span class="nc">Some</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">pure</span><span class="o">(</span><span class="n">o</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="n">interp</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">m</span> <span class="k">=&gt;</span> <span class="n">interp</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Easy enough!
For <code class="highlighter-rouge">get</code> we look inside our cache and use the value if it’s there, otherwise we call the original interpreter to do its job.
For <code class="highlighter-rouge">put</code>, there’s nothing to gain from having access to our extracted information and the only thing we can do is call the interpreter and let it do what needs to be done.</p>

<p>Now we have a way to extract information and then also use that information, next up is finding a way to wire these two things together to get back to the behaviour we got using <code class="highlighter-rouge">StateT</code>.</p>

<p>And as a matter of fact, we’ll wire them back together using exactly <code class="highlighter-rouge">StateT</code>, as it’s monad instance does do exactly what we want.</p>

<p>Using our two functions <code class="highlighter-rouge">extract</code> and <code class="highlighter-rouge">rebuild</code> it’s fairly easy to get back to <code class="highlighter-rouge">KVStore[StateT[F, Cache, ?]]</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">interp</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">v</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">StateT</span><span class="o">(</span><span class="n">cache</span> <span class="k">=&gt;</span> <span class="n">rebuild</span><span class="o">(</span><span class="n">cache</span><span class="o">,</span> <span class="n">interp</span><span class="o">).</span><span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">v</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> 
      <span class="o">(</span><span class="n">cache</span> <span class="o">|+|</span><span class="err"> </span><span class="n">extract</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">v</span><span class="o">))</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nc">StateT</span><span class="o">(</span><span class="n">cache</span> <span class="k">=&gt;</span> <span class="n">rebuild</span><span class="o">(</span><span class="n">cache</span><span class="o">,</span> <span class="n">interp</span><span class="o">).</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> 
      <span class="o">(</span><span class="n">cache</span> <span class="o">|+|</span><span class="err"> </span><span class="n">extract</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This is fairly straightforward, we use rebuild with our cache and the interpreter to get a new interpreter that will run the operation.
Then, we use the result, which is just an <code class="highlighter-rouge">F[Unit]</code>/<code class="highlighter-rouge">F[Option[String]]</code> respectively, and map it 
  using the extractor to get the newest <code class="highlighter-rouge">Cache</code> and using its <code class="highlighter-rouge">Monoid</code> instance to update the state and then we tuple it with the result, giving us an <code class="highlighter-rouge">F[(Cache, Unit)]</code> or <code class="highlighter-rouge">F[(Cache, Option[String])]</code>, which is exactly what the <code class="highlighter-rouge">StateT</code> constructor needs.</p>

<p>This is great, but can we generalize this to any algebra and any monoid?</p>

<p>The answer is yes, but it’s not exactly easy.
First let’s look at the actual problem.
We have two interpreters <code class="highlighter-rouge">extract</code> and <code class="highlighter-rouge">rebuild</code>, but we have no way to combine them, because <code class="highlighter-rouge">Alg</code>, is completely unconstrained and that means we can’t call any functions on a generic <code class="highlighter-rouge">Alg[F]</code> at all.
So, okay, we need to constrain our <code class="highlighter-rouge">Alg</code> parameter to be able to combine values of <code class="highlighter-rouge">Alg[F]</code> with values of <code class="highlighter-rouge">Alg[G]</code> in some way, but what kind of type class could that be?
Are there even type classes that operate on the kind of <code class="highlighter-rouge">Alg</code>?</p>

<h3 id="higher-kinded-things">Higher kinded things</h3>

<p>There are, they’re just hidden away in a small library called <code class="highlighter-rouge">Mainecoon</code>.
That library gives us higher kinded versions of things like functors and contravariant functors, called <code class="highlighter-rouge">FunctorK</code> and <code class="highlighter-rouge">ContravariantK</code> respectively.</p>

<p>Let’s have a quick look at <code class="highlighter-rouge">FunctorK</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@typeclass</span>
<span class="k">trait</span> <span class="nc">FunctorK</span><span class="o">[</span><span class="kt">A</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">mapK</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">af</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">F</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span> <span class="kt">~&gt;</span> <span class="kt">G</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Instead of mapping over type constructors <code class="highlighter-rouge">F[_]</code>, we map over algebras <code class="highlighter-rouge">A[_[_]]</code> and insteading of using functions <code class="highlighter-rouge">A =&gt; B</code>, we use natural transformations <code class="highlighter-rouge">F ~&gt; G</code>.
This is nice, but doesn’t really get us that far.</p>

<p>What we really need is the equivalent of the <code class="highlighter-rouge">Applicative</code>/<code class="highlighter-rouge">Apply</code> <code class="highlighter-rouge">map2</code> operation.
<code class="highlighter-rouge">map2</code> looks like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">map2</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span>
</code></pre></div></div>

<p>And a higher kinded version would look like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">map2K</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">H</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">af</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">ag</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">G</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Tuple2K</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">?</span><span class="o">]</span> <span class="o">~&gt;</span> <span class="n">H</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">H</span><span class="o">]</span>
</code></pre></div></div>

<p>If you haven’t guessed yet <code class="highlighter-rouge">Tuple2K</code> is just a higher kinded version of <code class="highlighter-rouge">Tuple2</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Tuple2K</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
</code></pre></div></div>

<p>Unfortunately <code class="highlighter-rouge">Mainecoon</code> doesn’t have an <code class="highlighter-rouge">ApplyK</code> type class that gives us this <code class="highlighter-rouge">map2K</code> operation, but it gives the next best thing! 
A higher-kinded <code class="highlighter-rouge">Semigroupal</code>, which when combined with the higher kinded <code class="highlighter-rouge">Functor</code> gives us that higher kinded <code class="highlighter-rouge">Apply</code> type class.
It’s called <code class="highlighter-rouge">CartesianK</code> (because cats <code class="highlighter-rouge">Semigroupal</code> used to be called <code class="highlighter-rouge">Cartesian</code>, but is renamed to <code class="highlighter-rouge">SemigroupalK</code> in the next version) and looks like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@typeclass</span> 
<span class="k">trait</span> <span class="nc">CartesianK</span><span class="o">[</span><span class="kt">A</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">productK</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">af</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">ag</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">Tuple2K</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">?</span><span class="o">]]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now just like you can define <code class="highlighter-rouge">map2</code> using <code class="highlighter-rouge">map</code> and <code class="highlighter-rouge">product</code> we can do the same for <code class="highlighter-rouge">map2K</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">map2K</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">H</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">af</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">ag</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">G</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Tuple2K</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">?</span><span class="o">]</span> <span class="o">~&gt;</span> <span class="n">H</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">H</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">productK</span><span class="o">(</span><span class="n">af</span><span class="o">,</span> <span class="n">ag</span><span class="o">).</span><span class="n">mapK</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="putting-it-all-together">Putting it all together</h3>

<p>Okay, after that quick detour, let’s have a look at how can make use of these type classes.</p>

<p>If we look at what we have and how we’d like to use the <code class="highlighter-rouge">map2K</code> function, we can infer the rest that we need quite easily.</p>

<p>We have an <code class="highlighter-rouge">Alg[F]</code> and a <code class="highlighter-rouge">Alg[? =&gt; M]</code>, and we want an <code class="highlighter-rouge">Alg[StateT[F, M, ?]]</code>, so given those two as the inputs to <code class="highlighter-rouge">map2K</code>, all that seems to be missing is the natural transformation <code class="highlighter-rouge">Tuple2K[F, ? =&gt; M, ?] ~&gt; StateT[F, M, ?]</code>.
Nice! As so often, the types guide us and show us the way.</p>

<p>Well let’s try to define just that:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="o">(</span><span class="nc">Tuple2K</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">M</span>, <span class="kt">?</span><span class="o">]</span> <span class="o">~&gt;</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Tuple2K</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">M</span>, <span class="kt">?</span><span class="o">])</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">StateT</span><span class="o">(</span><span class="n">m</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">first</span><span class="o">)(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">M</span><span class="o">.</span><span class="n">combine</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">second</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="n">m</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This looks good, but actually has a problem, to get an <code class="highlighter-rouge">Alg[F]</code> from <code class="highlighter-rouge">rebuild</code> we give it an <code class="highlighter-rouge">M</code> and an interpreter <code class="highlighter-rouge">Alg[F]</code>. 
The interpreter isn’t really a problem, but the <code class="highlighter-rouge">M</code> can prove problematic as we need to give it to the <code class="highlighter-rouge">rebuild</code> function after each monadic step to always receive the latest state.
If we look at our natural transformation above, that function will never receive the newest state.
So what can we do about this?
Well, we could be a bit more honest about our types:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">FunctionM</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">M</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="k">def</span> <span class="n">rebuild</span><span class="o">(</span><span class="n">interp</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">FunctionM</span><span class="o">]</span>
</code></pre></div></div>

<p>Hey, now we’re getting there. This works, but if we look into some of the data types provided by <code class="highlighter-rouge">Cats</code> we can acutally see that this is just <code class="highlighter-rouge">Kleisli</code> or <code class="highlighter-rouge">ReaderT</code>, so our <code class="highlighter-rouge">rebuild</code> should actually look like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">rebuild</span><span class="o">(</span><span class="n">interp</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]]</span>
</code></pre></div></div>

<p>And now, we can easily implement a correct version of that natural transformation from earlier:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="o">(</span><span class="nc">Tuple2K</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">M</span>, <span class="kt">?</span><span class="o">]</span> <span class="o">~&gt;</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Tuple2K</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">A</span><span class="o">]</span>, <span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">M</span>, <span class="kt">?</span><span class="o">])</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">StateT</span><span class="o">(</span><span class="n">m</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">m</span><span class="o">))(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">second</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">m</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Cool, then let us also adjust the rebuild function we created for <code class="highlighter-rouge">KVStore</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">rebuild</span><span class="o">(</span><span class="n">interp</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Kleisli</span><span class="o">(</span><span class="n">m</span> <span class="k">=&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">o</span> <span class="k">@</span> <span class="nc">Some</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">pure</span><span class="o">(</span><span class="n">o</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="n">interp</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span>
  <span class="o">})</span>

  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Kleisli</span><span class="o">(</span><span class="n">m</span> <span class="k">=&gt;</span> <span class="n">interp</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">a</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>It’s stayed pretty much the same, we just needed to wrap the whole thing in a <code class="highlighter-rouge">Kleisli</code> and we’re good!</p>

<p>Now we can go ahead and define the full function signature:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">optimize</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span><span class="kt">:</span> <span class="kt">FunctorK:</span> <span class="kt">CartesianK</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">M:</span> <span class="kt">Monoid</span>, <span class="kt">A</span><span class="o">]</span>
  <span class="o">(</span><span class="n">program</span><span class="k">:</span> <span class="kt">MonadProgram</span><span class="o">[</span><span class="kt">Alg</span>, <span class="kt">A</span><span class="o">])</span>
  <span class="o">(</span><span class="n">extract</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">M</span><span class="o">])</span>
  <span class="o">(</span><span class="n">rebuild</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Alg</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="n">interpreter</span> <span class="k">=&gt;</span>
  
    <span class="k">val</span> <span class="n">tupleToState</span> <span class="k">=</span> <span class="k">new</span> <span class="o">(</span><span class="nc">Tuple2K</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">M</span>, <span class="kt">?</span><span class="o">]</span> <span class="o">~&gt;</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">])</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Tuple2K</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">A</span><span class="o">]</span>, <span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">M</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
        <span class="nc">StateT</span><span class="o">(</span><span class="n">m</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">m</span><span class="o">))(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">second</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">m</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">))</span>
    <span class="o">}</span>

    <span class="k">val</span> <span class="n">withState</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
      <span class="n">map2K</span><span class="o">(</span><span class="n">extract</span><span class="o">(</span><span class="n">interpreter</span><span class="o">),</span> <span class="n">rebuild</span><span class="o">))(</span><span class="n">tupleToState</span><span class="o">)</span>

    <span class="n">program</span><span class="o">(</span><span class="n">withState</span><span class="o">).</span><span class="n">runEmptyA</span>
  
  <span class="o">}</span>
</code></pre></div></div>

<p>That is all, we’ve got a fully polymorphic function that can optimize monadic programs.</p>

<p>Let’s use it!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">optimize</span><span class="o">(</span><span class="n">program</span><span class="o">)(</span><span class="n">extract</span><span class="o">)(</span><span class="n">rebuild</span><span class="o">)</span>
  <span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">printInterpreter</span><span class="o">)</span>
  <span class="o">.</span><span class="n">unsafeRunSync</span><span class="o">()</span>
</code></pre></div></div>

<p>Now, when we run this, it should be exactly the same result as when we ran it earlier using the direct <code class="highlighter-rouge">StateT</code> interpreter, but the resulting code is much cleaner.
However, it does have the drawback that you’ll now need additional constraints for every algebra to use this function.
That said though, one of the cool features of <code class="highlighter-rouge">Mainecoon</code> is that it comes with auto-derivation.
Meaning we can just add an annotation to any of our algebras and it will automatically derive the <code class="highlighter-rouge">FunctorK</code> and <code class="highlighter-rouge">CartesianK</code> instances.</p>

<p>In fact, that is exactly how I defined those two instances for the <code class="highlighter-rouge">KVStore</code> algebra:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@autoFunctorK</span>
<span class="nd">@autoCartesianK</span>
<span class="k">trait</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div></div>

<p>This makes it fairly easy to use these extra type classes and helpts mitigate the drawbacks I mentioned.</p>

<h3 id="conclusions">Conclusions</h3>

<p>Today we’ve seen a way to make optimizing monadic tagless final programs easier and intuitive, all the code is taken from the sphynx library and can be found <a href="https://github.com/LukaJCB/sphynx">right here</a>, but might still be subject to change, because designing a good API is hard.</p>

<p>What do you think about this optimization scheme? Maybe you just prefer using <code class="highlighter-rouge">StateT</code> and being done with it, or maybe you like to use a typeclass based approach like the one we used last time?</p>

<p>Would love to hear from you all in the comments!</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 27 Jun 2018 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2018/06/27/optimizing-tagless-final-2.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/06/27/optimizing-tagless-final-2.html</guid>
      </item>
    
      <item>
        <title>Typedapi or how to derive your clients and servers from types</title>
        
          <dc:creator>pheymann</dc:creator>
                
        <description><![CDATA[<p>In this blog post, I will show you how to leverage Scala’s type system to derive an HTTP client function from a single type. This will also be the story of how I started to work on <a href="https://github.com/pheymann/typedapi">Typedapi</a> which is basically the attempt to bring Haskell’s <a href="https://github.com/haskell-servant/servant">Servant</a> to Scala.</p>

<h2 id="servant-in-a-nutshell-and-how-it-began">Servant in a nutshell and how it began</h2>
<p>For everyone not knowing Servant, it is a library which lets you define your web apis as types and derives the client and server functions from it. When I saw it for the first time while working on a pet project I immediately loved the idea. Creating web server and clients this way reduces your code to a mere type, you get extra type safety and you can use the api types as contracts between your server and its clients.</p>

<p>I couldn’t find any viable alternative in Scala at the time and decided to build it on my own. But I just wanted to start with a single feature to not overwhelm myself and abandon the project after a short time. Therefore, I set out to make Scala able to derive a client function from a single api type, as we will do in this post.</p>

<h2 id="derive-a-client-function-from-a-type-how-hard-can-it-be">Derive a client function from a type. How hard can it be?</h2>
<p>Let’s start with an example we will use later on to ease understanding. Consider the following api:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /users/:name?minAge=:age -&gt; List[User]
</code></pre></div></div>

<p>It only consists of a single endpoint which returns a list of <code class="highlighter-rouge">Users</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">User</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</code></pre></div></div>

<p>with a given <code class="highlighter-rouge">name: String</code>. Furthermore, you filter the resulting users by their <code class="highlighter-rouge">age: Int</code>. Our big goal is to end up with a function which is derived from a type-level representation of our endpoint:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">minAge</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span>
</code></pre></div></div>

<h3 id="represent-the-api-as-a-type">Represent the api as a type</h3>
<p>Question: how do you represent the above api as a type in Scala? I think the best way is to break it apart and try to find type-level representations for each element. After that, we “just” merge them together.</p>

<p>When we take a closer look at our endpoint we see that it consists of:</p>
<ul>
  <li>a method <code class="highlighter-rouge">GET</code> to identify which kind of operation we want to do and which also describes the expected return type</li>
  <li>constant path elements identifying an endpoint: <code class="highlighter-rouge">/users</code></li>
  <li>dynamic path elements called “segments” which represent input parameters with a name and type: <code class="highlighter-rouge">:name</code></li>
  <li>queries which again represent input parameters with a name and type: <code class="highlighter-rouge">minAge=[age]</code></li>
</ul>

<p>Or in other words, just a plain HTTP definition of a web endpoint. Now that we know what we are working with let’s try and find a type-level representation.</p>

<p>But how do you transform a value-level information as a type? First of all, the value has to be known at compile time which leaves us with literals. If we would work with Dotty we could leverage a concept called literal type:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Path</span> <span class="o">=</span> <span class="s">"users"</span>
</code></pre></div></div>

<p>But since we want to stay in Vanilla Scala this will not work. We have to take another route by using a tool probably every developer has to use when it comes to working on the type-level called <a href="https://github.com/milessabin/shapeless">shapeless</a>. It has this nifty class <a href="https://github.com/milessabin/shapeless/blob/shapeless-2.3.3/core/src/main/scala/shapeless/singletons.scala#L32">Witness</a> which comes with an abstract type <code class="highlighter-rouge">T</code>. And <code class="highlighter-rouge">T</code> is exactly what we need here as it transforms our literals into types.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless.Witness</span>

<span class="k">val</span> <span class="n">usersW</span> <span class="k">=</span> <span class="nc">Witness</span><span class="o">(</span><span class="s">"users"</span><span class="o">)</span>
</code></pre></div></div>

<p>But this isn’t a pure type declaration, you will say. And you are right, but right now there is no other way in Scala. We have to go the ordinary value road first to create our types.</p>

<p>Now that we know how to get a type representation from a <code class="highlighter-rouge">String</code> which describes our path we should clearly mark it as a path element:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Path</span><span class="o">[</span><span class="kt">P</span><span class="o">]</span>

<span class="nc">type</span> <span class="n">users</span> <span class="k">=</span> <span class="nc">Path</span><span class="o">[</span><span class="kt">usersW.T</span><span class="o">]</span>
</code></pre></div></div>

<p>That’s it. That is the basic concept of how we can describe our apis as types. We just reuse this concept now for the remaining elements like the segment.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">nameW</span> <span class="k">=</span> <span class="nc">Witness</span><span class="o">(</span><span class="ss">'name)</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Segment</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">]</span>

<span class="nc">type</span> <span class="n">name</span> <span class="k">=</span> <span class="nc">Segment</span><span class="o">[</span><span class="kt">nameW.T</span>, <span class="kt">String</span><span class="o">]</span>
</code></pre></div></div>

<p>Do you see how we included the segment’s identifier in the type? This way we are not only gain information about the expected type but also what kind of value we want to see. By the way, I decided to use <code class="highlighter-rouge">Symbols</code> as identifiers, but you could also switch to <code class="highlighter-rouge">String</code> literals. The remaining definitions look pretty similar:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">minAgeW</span> <span class="k">=</span> <span class="nc">Witness</span><span class="o">(</span><span class="ss">'minAge)</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Query</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">]</span>

<span class="nc">type</span> <span class="n">minAge</span> <span class="k">=</span> <span class="nc">Query</span><span class="o">[</span><span class="kt">minAgeW.T</span>, <span class="kt">Int</span><span class="o">]</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Method</span>
<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Get</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Method</span>
</code></pre></div></div>

<p>Here, <code class="highlighter-rouge">A</code> in <code class="highlighter-rouge">Get[A]</code> represents the expected result type of our api endpoint.</p>

<p>Now that we know how to obtain the types of our api elements we have to put them together into a single type representation. After looking through shapeless’s features we will find <code class="highlighter-rouge">HLists</code>, a list structure which can store elements of different types.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless.</span><span class="o">{::,</span> <span class="nc">HNil</span><span class="o">}</span>

<span class="k">type</span> <span class="kt">Api</span> <span class="o">=</span> <span class="nc">Get</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="o">::</span> <span class="n">users</span> <span class="o">::</span> <span class="n">name</span> <span class="o">::</span> <span class="n">minAge</span> <span class="o">::</span> <span class="nc">HNil</span>
</code></pre></div></div>

<p>Here you go. <code class="highlighter-rouge">Api</code> is an exact representation of the endpoint we defined at the beginning. But you don’t want to write <code class="highlighter-rouge">Witness</code> and <code class="highlighter-rouge">HLists</code> all the time so let’s wrap it up into a convenient function call:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">api</span><span class="o">[</span><span class="kt">M</span> <span class="k">&lt;:</span> <span class="kt">Method</span>, <span class="kt">P</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">Q</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">Api</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">]</span>
       <span class="o">(</span><span class="n">method</span><span class="k">:</span> <span class="kt">M</span><span class="o">,</span> <span class="n">path</span><span class="k">:</span> <span class="kt">PathList</span><span class="o">[</span><span class="kt">P</span><span class="o">],</span> <span class="n">queries</span><span class="k">:</span> <span class="kt">QueryList</span><span class="o">[</span><span class="kt">Q</span><span class="o">])</span>
       <span class="o">(</span><span class="k">implicit</span> <span class="n">prepQP</span><span class="k">:</span> <span class="kt">Prepend.Aux</span><span class="o">[</span><span class="kt">Q</span>, <span class="kt">P</span>, <span class="kt">Api</span><span class="o">])</span><span class="k">:</span> <span class="kt">ApiTypeCarrier</span><span class="o">[</span><span class="kt">M</span> <span class="kt">::</span> <span class="kt">Api</span><span class="o">]</span> <span class="k">=</span> <span class="nc">ApiTypeCarrier</span><span class="o">()</span>
      
<span class="k">val</span> <span class="nc">Api</span> <span class="k">=</span> <span class="n">api</span><span class="o">(</span><span class="nc">Get</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]],</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="o">/</span> <span class="nc">Segment</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="ss">'name)</span><span class="o">,</span> <span class="nc">Queries</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="nc">Query</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="ss">'minAge)</span><span class="o">))</span>
</code></pre></div></div>

<p>Not clear what is happening? Let’s take a look at the different elements of <code class="highlighter-rouge">def api(...)</code>:</p>
<ul>
  <li><code class="highlighter-rouge">method</code> should be obvious. It takes some method type.</li>
  <li><code class="highlighter-rouge">PathList</code> is a type carrier with a function <code class="highlighter-rouge">def /(...)</code> to concatenate path elements and segments. In the end, <code class="highlighter-rouge">PathList</code> only stores the type of an <code class="highlighter-rouge">HList</code> and nothing more.</li>
</ul>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">PathList</span><span class="o">[</span><span class="kt">P</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">]()</span> <span class="o">{</span>
  
  <span class="k">def</span> <span class="o">/[</span><span class="kt">S</span><span class="o">](</span><span class="n">path</span><span class="k">:</span> <span class="kt">Witness.Lt</span><span class="o">[</span><span class="kt">S</span><span class="o">])</span><span class="k">:</span> <span class="kt">PathList</span><span class="o">[</span><span class="kt">S</span> <span class="kt">::</span> <span class="kt">P</span><span class="o">]</span> <span class="k">=</span> <span class="nc">PathList</span><span class="o">()</span>
  <span class="o">...</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nc">Root</span> <span class="k">=</span> <span class="nc">PathList</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]()</span>
</code></pre></div></div>
<ul>
  <li>Same is true for <code class="highlighter-rouge">QueryList</code>.</li>
  <li>The last step is to merge all these <code class="highlighter-rouge">HLists</code> types into a single one. Shapeless comes again with a handy type class called <code class="highlighter-rouge">Prepend</code> which provides us with the necessary functionality. Two <code class="highlighter-rouge">HList</code> types go in, a single type comes out. And again, we use a type carrier here to store the api type.</li>
</ul>

<p>Whoho, we did it. One thing we can mark as done on our todo list. Next step is to derive an actual client function from it.</p>

<h3 id="clients-from-types">Clients from types</h3>
<p>So far we have a type carrier describing our api as type:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ApiTypeCarrier</span><span class="o">[</span><span class="kt">Get</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="kt">::</span> <span class="kt">Query</span><span class="o">[</span><span class="kt">minAgeW.T</span>, <span class="kt">Int</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">Segment</span><span class="o">[</span><span class="kt">nameW.T</span>, <span class="kt">String</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">usersW.T</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]</span>
</code></pre></div></div>

<p>Now we want to transform that into a function call <code class="highlighter-rouge">(name: String, minAge: Int) =&gt; F[List[User]]</code>. So what we need is the following:</p>
<ul>
  <li>the types of our expected input</li>
  <li>the output type</li>
  <li>the path to the endpoint we want to call</li>
</ul>

<p>All information are available but mixed up and we need to separate them. Usually, when we work with collections and want to change their shape we do a <code class="highlighter-rouge">fold</code> and alas shapeless has type classes to fold left and right over an <code class="highlighter-rouge">HList</code>. But we only have a type. How do we fold that?</p>

<h4 id="type-level-foldleft">Type-level FoldLeft</h4>
<p>What we want is to go from <code class="highlighter-rouge">Api &lt;: HList</code> to <code class="highlighter-rouge">(El &lt;: HList, KIn &lt;: HList, VIn &lt;: HList, M, Out)</code> with:</p>
<ul>
  <li><code class="highlighter-rouge">El</code> al the elements in our api: <code class="highlighter-rouge">"users".type :: SegmentInput :: QueryInput :: GetCall :: HNil</code></li>
  <li><code class="highlighter-rouge">KIn</code> the input key types: <code class="highlighter-rouge">nameW.T :: minAgeW.T :: HNil</code></li>
  <li><code class="highlighter-rouge">VIn</code> the input value types: <code class="highlighter-rouge">String :: Int :: HNil</code></li>
  <li>the method type: <code class="highlighter-rouge">GetCall</code></li>
  <li>and <code class="highlighter-rouge">Out</code>: <code class="highlighter-rouge">List[User]</code></li>
</ul>

<p>Here, we introduced new types <code class="highlighter-rouge">SegmentInput</code> and <code class="highlighter-rouge">QueryInput</code> which act as placeholders and indicate that our api has the following inputs. This representation will come in handy when we construct our function.</p>

<p>Now, how to fold on the type-level? The first step, we have to define a function which describes how to aggregate two types:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">FoldLeftFunction</span><span class="o">[</span><span class="kt">In</span>, <span class="kt">Agg</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">}</span>
</code></pre></div></div>

<p>That’s it. We say what goes in and what comes out. You need some examples to get a better idea? Here you go:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">pathTransformer</span><span class="o">[</span><span class="kt">P</span>, <span class="kt">El</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">KIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">VIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">M</span>, <span class="kt">Out</span><span class="o">]</span> <span class="k">=</span> 
  <span class="nc">FoldLeftFunction</span><span class="o">[</span><span class="kt">Path</span><span class="o">[</span><span class="kt">P</span><span class="o">]</span>, <span class="o">(</span><span class="kt">El</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span>, <span class="kt">M</span>, <span class="kt">Out</span><span class="o">)]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="o">(</span><span class="n">P</span> <span class="o">::</span> <span class="nc">El</span><span class="o">,</span> <span class="nc">KIn</span><span class="o">,</span> <span class="nc">VIn</span><span class="o">,</span> <span class="nc">Out</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div></div>

<p>We expect a <code class="highlighter-rouge">Path[P]</code> and intermediate aggregation state <code class="highlighter-rouge">(El, KIn, VIn, M, Out)</code>. We merge the two by adding <code class="highlighter-rouge">P</code> to our list of api elements. The same technique is also used for more involved aggregations:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">segmentTransformer</span><span class="o">[</span><span class="kt">K</span> <span class="k">&lt;:</span> <span class="kt">Symbol</span>, <span class="kt">V</span>, <span class="kt">El</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">KIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">VIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">M</span>, <span class="kt">Out</span><span class="o">]</span> <span class="k">=</span> 
  <span class="nc">FoldLeftFunction</span><span class="o">[</span><span class="kt">Segment</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">]</span>, <span class="o">(</span><span class="kt">El</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span>, <span class="kt">M</span>, <span class="kt">Out</span><span class="o">)]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="o">(</span><span class="nc">SegmentInput</span> <span class="o">::</span> <span class="nc">El</span><span class="o">,</span> <span class="n">K</span> <span class="o">::</span> <span class="nc">KIn</span><span class="o">,</span> <span class="n">V</span> <span class="o">::</span> <span class="nc">VIn</span><span class="o">,</span> <span class="nc">Out</span><span class="o">)</span> <span class="o">}</span>
</code></pre></div></div>

<p>Here, we get some <code class="highlighter-rouge">Segment</code> with a name <code class="highlighter-rouge">K</code> and a type <code class="highlighter-rouge">V</code> and an intermediate aggregation state we will update by adding a placeholder to <code class="highlighter-rouge">El</code>, the name to <code class="highlighter-rouge">KIn</code> and the value type to <code class="highlighter-rouge">VIn</code>.</p>

<p>Now that we can aggregate types we need a vehicle to traverse our <code class="highlighter-rouge">HList</code> type and transform it on the fly by using our <code class="highlighter-rouge">FoldLeftFunction</code> instances. I think yet another type class can help us here.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">TypeLevelFoldLeft</span><span class="o">[</span><span class="kt">H</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">Agg</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">}</span>

<span class="k">object</span> <span class="nc">TypeLevelFoldLeft</span> <span class="o">{</span>

  <span class="k">implicit</span> <span class="k">def</span> <span class="n">returnCase</span><span class="o">[</span><span class="kt">Agg</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TypeLevelFoldLeft</span><span class="o">[</span><span class="kt">HNil</span>, <span class="kt">Agg</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">Agg</span>
  <span class="o">}</span>

  <span class="k">implicit</span> <span class="k">def</span> <span class="n">foldCase</span><span class="o">[</span><span class="kt">H</span>, <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">Agg</span>, <span class="kt">FfOut</span>, <span class="kt">FOut</span><span class="o">](</span><span class="k">implicit</span> <span class="n">f</span><span class="k">:</span> <span class="kt">FoldLeftFunction.Aux</span><span class="o">[</span><span class="kt">H</span>, <span class="kt">Agg</span>, <span class="kt">FfOut</span><span class="o">],</span> 
                                                                  <span class="n">next</span><span class="k">:</span> <span class="kt">Lazy</span><span class="o">[</span><span class="kt">TypeLevelFoldLeft.Aux</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">FfOut</span>, <span class="kt">FOut</span><span class="o">]])</span> <span class="k">=</span> 
    <span class="k">new</span> <span class="nc">TypeLevelFoldLeft</span><span class="o">[</span><span class="kt">H</span> <span class="kt">::</span> <span class="kt">T</span>, <span class="kt">Agg</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">FOut</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The above definition describes a recursive function which will apply the <code class="highlighter-rouge">FoldLeftFunction</code> on <code class="highlighter-rouge">H</code> and the current aggregated type <code class="highlighter-rouge">Agg</code> and continues with the resulting <code class="highlighter-rouge">FfOut</code> and the remaining list. And before you bang your head against the wall for hours until the clock strikes 3 am, like I did, a small hint, make <code class="highlighter-rouge">next</code> lazy. Otherwise, Scala is not able to find <code class="highlighter-rouge">next</code>. My guess is that Scala is not able to infer <code class="highlighter-rouge">next</code>, because it depends on <code class="highlighter-rouge">FfOut</code> which is also unknown. So we have to defer <code class="highlighter-rouge">next</code>’s inference to give the compiler some time to work.</p>

<p>And another hint, you can start with <code class="highlighter-rouge">Unit</code> as the initial type for your aggregate.</p>

<h4 id="collect-all-the-request-data">Collect all the request data</h4>
<p>We folded our api type into the new representation making it easier now to derive a function which collects all the data necessary to make a request.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// path to our endpoint described by Path and Segment
</span><span class="k">type</span> <span class="kt">Uri</span> <span class="o">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>

<span class="c1">// queries described by Query
</span><span class="k">type</span> <span class="kt">Queries</span> <span class="o">=</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span>

<span class="nc">VIn</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nc">Uri</span><span class="o">,</span> <span class="nc">Queries</span><span class="o">)</span>
</code></pre></div></div>

<p>This function will form the basis of our client function we try to build. It generates the <code class="highlighter-rouge">Uri</code> and a <code class="highlighter-rouge">Map</code> of <code class="highlighter-rouge">Queries</code> which will be used later on to do a request using some HTTP library.</p>

<p>By now, you should be already comfortable with type classes. Therefore, it shouldn’t shock you that I will introduce yet another one to derive the above function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">RequestDataBuilder</span><span class="o">[</span><span class="kt">El</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">KIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">VIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">inputs</span><span class="k">:</span> <span class="kt">VIn</span><span class="o">,</span> <span class="n">uri</span><span class="k">:</span> <span class="kt">Uri</span><span class="o">,</span> <span class="n">queries</span><span class="k">:</span> <span class="kt">Queries</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">Uri</span><span class="o">,</span> <span class="kt">Queries</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Instances of this type class update <code class="highlighter-rouge">uri</code> and <code class="highlighter-rouge">queries</code> depending on the types they see. For example, if the current head of <code class="highlighter-rouge">El</code> is a path element we prepend its <code class="highlighter-rouge">String</code> literal to <code class="highlighter-rouge">uri</code>. Just keep in mind to reverse the <code class="highlighter-rouge">List</code> before returning it.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">pathBuilder</span><span class="o">[</span><span class="kt">P</span>, <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">KIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">VIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span><span class="k">implicit</span> <span class="n">wit</span><span class="k">:</span> <span class="kt">Witness.Aux</span><span class="o">[</span><span class="kt">P</span><span class="o">],</span> <span class="n">next</span><span class="k">:</span> <span class="kt">RequestDataBuilder</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span><span class="o">])</span> <span class="k">=</span> 
  <span class="k">new</span> <span class="nc">RequestDataBuilder</span><span class="o">[</span><span class="kt">P</span> <span class="kt">::</span> <span class="kt">T</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">inputs</span><span class="k">:</span> <span class="kt">VIn</span><span class="o">,</span> <span class="n">uri</span><span class="k">:</span> <span class="kt">Uri</span><span class="o">,</span> <span class="n">queries</span><span class="k">:</span> <span class="kt">Queries</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">Uri</span><span class="o">,</span> <span class="kt">Queries</span><span class="o">)</span> <span class="k">=</span>
      <span class="n">next</span><span class="o">(</span><span class="n">inputs</span><span class="o">,</span> <span class="n">wit</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">toString</span><span class="o">()</span> <span class="o">::</span> <span class="n">uri</span><span class="o">,</span> <span class="n">queries</span><span class="o">,</span> <span class="n">headers</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Or if we encounter a query input we derive the key’s type-literal, pair it with the given input value and add both to <code class="highlighter-rouge">queries</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">queryBuilder</span><span class="o">[</span><span class="kt">K</span> <span class="k">&lt;:</span> <span class="kt">Symbol</span>, <span class="kt">V</span>, <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">KIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">VIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span><span class="k">implicit</span> <span class="n">wit</span><span class="k">:</span> <span class="kt">Witness.Aux</span><span class="o">[</span><span class="kt">K</span><span class="o">],</span> <span class="n">next</span><span class="k">:</span> <span class="kt">RequestDataBuilder</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span><span class="o">])</span> <span class="k">=</span> 
  <span class="k">new</span> <span class="nc">RequestDataBuilder</span><span class="o">[</span><span class="kt">QueryInput</span> <span class="kt">::</span> <span class="kt">T</span>, <span class="kt">K</span> <span class="kt">::</span> <span class="kt">KIn</span>, <span class="kt">V</span> <span class="kt">::</span> <span class="kt">VIn</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">inputs</span><span class="k">:</span> <span class="kt">V</span> <span class="kt">::</span> <span class="kt">VIn</span><span class="o">,</span> <span class="n">uri</span><span class="k">:</span> <span class="kt">Uri</span><span class="o">,</span> <span class="n">queries</span><span class="k">:</span> <span class="kt">Queries</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">Uri</span><span class="o">,</span> <span class="kt">Queries</span><span class="o">)</span> <span class="k">=</span>
      <span class="n">next</span><span class="o">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">tail</span><span class="o">,</span> <span class="n">uri</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="n">wit</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">name</span> <span class="o">-&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">toString</span><span class="o">()))</span> <span class="o">++</span> <span class="n">queries</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>The other cases are looking quite similar and it is up to the interested reader to find the implementations.</p>

<p>What we end up with is a nested function call structure which will take an <code class="highlighter-rouge">HList</code> and returns the <code class="highlighter-rouge">uri</code> and <code class="highlighter-rouge">queries</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">builder</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">RequestDataBuilder</span><span class="o">[</span><span class="kt">El</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span><span class="o">]]</span>

<span class="k">val</span> <span class="n">f</span><span class="k">:</span> <span class="kt">VIn</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="nc">Uri</span><span class="o">,</span> <span class="nc">Queries</span><span class="o">)</span> <span class="k">=</span> <span class="n">input</span> <span class="k">=&gt;</span> <span class="n">builder</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">,</span> <span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>

<span class="s">"joe"</span> <span class="o">::</span> <span class="mi">42</span> <span class="o">::</span> <span class="nc">HNil</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="s">"users"</span><span class="o">,</span> <span class="s">"joe"</span><span class="o">),</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"minAge"</span> <span class="o">-&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="s">"42"</span><span class="o">)))</span>
</code></pre></div></div>

<p>Here, <code class="highlighter-rouge">"joe"</code> and <code class="highlighter-rouge">42</code> are our expected inputs (<code class="highlighter-rouge">VIn</code>) which we derived from the segments and queries of our <code class="highlighter-rouge">Api</code>.</p>

<h4 id="make-the-request">Make the request</h4>
<p>We have all the data we need to make an IO request but nothing to execute it. We change that now. By adding an HTTP backend. But we don’t want to expose this implementation detail through our code. What we want is a generic description of a request action and that sounds again like a job for type classes.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">ApiRequest</span><span class="o">[</span><span class="kt">M</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">C</span>, <span class="kt">Out</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">data</span><span class="k">:</span> <span class="o">(</span><span class="kt">Uri</span><span class="o">,</span> <span class="kt">Queries</span><span class="o">),</span> <span class="n">client</span><span class="k">:</span> <span class="kt">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Out</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We have to specialize that for the set of methods we have:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">GetRequest</span><span class="o">[</span><span class="kt">C</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">Out</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">ApiRequest</span><span class="o">[</span><span class="kt">GetCall</span>, <span class="kt">C</span>, <span class="kt">F</span>, <span class="kt">Out</span><span class="o">]</span>

<span class="o">...</span>

<span class="k">val</span> <span class="n">request</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">ApiRequest</span><span class="o">[</span><span class="kt">GetCall</span>, <span class="kt">IO</span>, <span class="kt">C</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]]</span>

<span class="k">val</span> <span class="n">f</span><span class="k">:</span> <span class="kt">VIn</span> <span class="o">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span> <span class="k">=</span> 
  <span class="n">input</span> <span class="k">=&gt;</span> <span class="n">request</span><span class="o">(</span><span class="n">builder</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">,</span> <span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">),</span> <span class="n">c</span><span class="o">)</span>
</code></pre></div></div>

<p>Let’s say we want http4s as our backend. Then we just have to implement these <code class="highlighter-rouge">traits</code> using http4s functionality.</p>

<h4 id="make-it-a-whole">Make it a whole</h4>
<p>We have a bunch of type classes which in theory do a request, but so far they are completely useless. To make a working piece of code out of it we have to connect them.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">derive</span><span class="o">[</span><span class="kt">Api</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">El</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">KIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">VIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">M</span>, <span class="kt">Out</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">C</span><span class="o">]</span>
  <span class="o">(</span><span class="n">api</span><span class="k">:</span> <span class="kt">ApiTypeCarrier</span><span class="o">[</span><span class="kt">Api</span><span class="o">],</span> <span class="n">client</span><span class="k">:</span> <span class="kt">C</span><span class="o">)</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">fold</span><span class="k">:</span> <span class="kt">Lazy</span><span class="o">[</span><span class="kt">TypeLevelFoldLeft.Aux</span><span class="o">[</span><span class="kt">Api</span>, <span class="kt">Fold</span><span class="o">]</span>, <span class="o">(</span><span class="kt">El</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span>, <span class="kt">M</span>, <span class="kt">Out</span><span class="o">)]</span>
            <span class="n">builder</span><span class="k">:</span> <span class="kt">RequestBuilder</span><span class="o">[</span><span class="kt">El</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span><span class="o">],</span>
            <span class="n">request</span><span class="k">:</span> <span class="kt">ApiRequest</span><span class="o">[</span><span class="kt">M</span>, <span class="kt">F</span>, <span class="kt">C</span>, <span class="kt">Out</span><span class="o">])</span><span class="k">:</span> <span class="kt">VIn</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">Out</span><span class="o">]</span> <span class="k">=</span> <span class="n">vin</span> <span class="k">=&gt;</span> <span class="n">request</span><span class="o">(</span><span class="n">builder</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">vin</span><span class="o">,</span> <span class="nc">List</span><span class="o">.</span><span class="n">newBuilder</span><span class="o">,</span> <span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">),</span> <span class="n">client</span><span class="o">)</span>
</code></pre></div></div>

<p>The first approach gives us the desired function. It transforms our api type into a <code class="highlighter-rouge">(El, KIn, VIn, Method, Out)</code> representation, derives a function to collect all data to do a request, and finds an IO backend to actually do the request. But it has a major drawback. You have to fix <code class="highlighter-rouge">F[_]</code> somehow and the only way is to set it explicitly. But by doing that you are forced to provide definitions for all the type parameters. Furthermore, this function isn’t really convenient. To use it you have to create and pass an <code class="highlighter-rouge">HList</code> and as we said before, we don’t want to expose something like that.</p>

<p>To fix the first problem we simply add a helper class which moves the step of defining the higher kind <code class="highlighter-rouge">F[_]</code> to a separate function call:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">class</span> <span class="nc">ExecutableDerivation</span><span class="o">[</span><span class="kt">El</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">KIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">VIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">M</span>, <span class="kt">O</span><span class="o">](</span><span class="n">builder</span><span class="k">:</span> <span class="kt">RequestDataBuilder</span><span class="o">[</span><span class="kt">El</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span><span class="o">],</span> <span class="n">input</span><span class="k">:</span> <span class="kt">VIn</span><span class="o">)</span> <span class="o">{</span>

  <span class="k">final</span> <span class="k">class</span> <span class="nc">Derivation</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>

    <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">C</span><span class="o">](</span><span class="n">client</span><span class="k">:</span> <span class="kt">C</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">req</span><span class="k">:</span> <span class="kt">ApiRequest</span><span class="o">[</span><span class="kt">M</span>, <span class="kt">C</span>, <span class="kt">F</span>, <span class="kt">O</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">O</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="n">builder</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nc">List</span><span class="o">.</span><span class="n">newBuilder</span><span class="o">,</span> <span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">,</span> <span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>

      <span class="n">req</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">cm</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">run</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span><span class="k">:</span> <span class="kt">Derivation</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Derivation</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Making a function of arity <code class="highlighter-rouge">Length[VIn]</code> out of <code class="highlighter-rouge">Vin =&gt; F[O]</code>is possible by using <code class="highlighter-rouge">shapeless.ops.function.FnFromProduct</code>.</p>

<p>When we apply both solutions we end up with:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">derive</span><span class="o">[</span><span class="kt">H</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">Fold</span>, <span class="kt">El</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">KIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">VIn</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">M</span>, <span class="kt">Out</span><span class="o">]</span>
  <span class="o">(</span><span class="n">apiList</span><span class="k">:</span> <span class="kt">ApiTypeCarrier</span><span class="o">[</span><span class="kt">H</span><span class="o">])</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">fold</span><span class="k">:</span> <span class="kt">Lazy</span><span class="o">[</span><span class="kt">TypeLevelFoldLeft.Aux</span><span class="o">[</span><span class="kt">H</span>, <span class="kt">Unit</span>, <span class="o">(</span><span class="kt">El</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span>, <span class="kt">M</span>, <span class="kt">Out</span><span class="o">)]],</span>
            <span class="n">builder</span><span class="k">:</span> <span class="kt">RequestDataBuilder</span><span class="o">[</span><span class="kt">El</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span><span class="o">],</span>
            <span class="n">vinToFn</span><span class="k">:</span> <span class="kt">FnFromProduct</span><span class="o">[</span><span class="kt">VIn</span> <span class="k">=&gt;</span> <span class="kt">ExecutableDerivation</span><span class="o">[</span><span class="kt">El</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span>, <span class="kt">M</span>, <span class="kt">Out</span><span class="o">]])</span><span class="k">:</span> <span class="kt">vinToFn.Out</span> <span class="o">=</span> 
  <span class="n">vinToFn</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">input</span> <span class="k">=&gt;</span> <span class="k">new</span> <span class="nc">ExecutableDerivation</span><span class="o">[</span><span class="kt">El</span>, <span class="kt">KIn</span>, <span class="kt">VIn</span>, <span class="kt">M</span>, <span class="kt">Out</span><span class="o">](</span><span class="n">builder</span><span class="o">,</span> <span class="n">input</span><span class="o">))</span>
</code></pre></div></div>

<p>I already hear the “your function signature is so big …” jokes incoming, but this is basically what we will (and want to) end up with when doing type-level programming. In the end, our types have to express the logic of our program and that needs some space.</p>

<p>But finally, we can say we did it! We convinced the Scala compiler to derive a client function from a type. Let’s have a look at our example to see how it works.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>
<span class="k">import</span> <span class="nn">org.http4s.client.Client</span>

<span class="k">val</span> <span class="nc">Api</span> <span class="k">=</span> <span class="n">api</span><span class="o">(</span><span class="nc">Get</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]],</span> <span class="nc">Root</span> <span class="o">/</span> <span class="s">"users"</span> <span class="o">/</span> <span class="nc">Segment</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="ss">'name)</span><span class="o">,</span> <span class="nc">Queries</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="nc">Query</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="ss">'minAge)</span><span class="o">))</span>
<span class="k">val</span> <span class="n">get</span> <span class="k">=</span> <span class="n">derive</span><span class="o">(</span><span class="nc">Api</span><span class="o">)</span>

<span class="n">get</span><span class="o">(</span><span class="s">"joe"</span><span class="o">,</span> <span class="mi">42</span><span class="o">).</span><span class="n">run</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="nc">Client</span><span class="o">[</span><span class="kt">IO</span><span class="o">])</span> <span class="c1">// IO[List[User]]
</span></code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>
<p>When you take a closer look at the code above you will see that we were able to move most of the heavy lifting to the compiler or shapeless therefore reducing our code to a relatively small set of “simple” type classes. And when literal types are in thing in Scala we can also remove most of the boilerplate necessary to create our api types.</p>

<p>This, again, shows me how powerful Scalas type system is and how much you can gain when you embrace it.</p>

<h2 id="next-step---typedapi">Next Step - Typedapi</h2>
<p>Now that we are able to derive a single client function from a type we should also be able to do the same for a collection of api types. And if we are already on it, let’s add server-side support. Or … you just use <a href="https://github.com/pheymann/typedapi">Typedapi</a>. It already comes with the following features:</p>
<ul>
  <li>client function derivation</li>
  <li>server function derivation</li>
  <li>single and multi api type handling</li>
  <li>support for htt4s</li>
  <li>support for akka-http in the making</li>
  <li>simple interface to add more HTTP frameworks/libraries</li>
</ul>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Fri, 15 Jun 2018 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2018/06/15/typedapi.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/06/15/typedapi.html</guid>
      </item>
    
      <item>
        <title>Shared State in Functional Programming</title>
        
          <dc:creator>gvolpe</dc:creator>
                
        <description><![CDATA[<p>Newcomers to functional programming (FP) are often very confused about the proper way to share state without breaking purity and end up having a mix of pure and impure code that <a href="https://queue.acm.org/detail.cfm?id=2611829">defeats the purpose</a> of having pure FP code in the first place.</p>

<p>This is the reason that has motivated me to write a beginner friendly guide :)</p>

<h2 id="use-case">Use Case</h2>

<p>We have a program that runs three computations at the same time and updates the internal state to keep track of the
tasks that have been completed. When all the tasks are completed we request the final state and print it out.</p>

<p>You should get an output similar to the following one:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Starting process #1
Starting process #2
Starting process #3
  ... 3 seconds
Done #2
  ... 5 seconds
Done #1
  ... 10 seconds
Done #3
List(#2, #1, #3)
</code></pre></div></div>

<p>We’ll use the concurrency primitive <a href="https://typelevel.org/cats-effect/concurrency/ref.html"><code class="highlighter-rouge">Ref[IO, List[String]]</code></a> to represent our internal state because it’s a great fit.</p>

<h3 id="getting-started">Getting started</h3>

<p>So this is how we might decide to start writing our code having some knowledge about <a href="https://typelevel.org/cats-effect/datatypes/io.html"><code class="highlighter-rouge">cats.effect.IO</code></a>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect._</span>
<span class="k">import</span> <span class="nn">cats.effect.concurrent.Ref</span>
<span class="k">import</span> <span class="nn">cats.instances.list._</span>
<span class="k">import</span> <span class="nn">cats.syntax.all._</span>

<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">object</span> <span class="nc">sharedstate</span> <span class="k">extends</span> <span class="nc">IOApp</span> <span class="o">{</span>

  <span class="k">var</span> <span class="n">myState</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="k">_</span>

  <span class="k">def</span> <span class="n">putStrLn</span><span class="o">(</span><span class="n">str</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">str</span><span class="o">))</span>

  <span class="k">val</span> <span class="n">process1</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">putStrLn</span><span class="o">(</span><span class="s">"Starting process #1"</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nc">IO</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="n">myState</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="k">_</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="s">"#1"</span><span class="o">))</span> <span class="o">*&gt;</span>
      <span class="n">putStrLn</span><span class="o">(</span><span class="s">"Done #1"</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">val</span> <span class="n">process2</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">putStrLn</span><span class="o">(</span><span class="s">"Starting process #2"</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nc">IO</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="n">myState</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="k">_</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="s">"#2"</span><span class="o">))</span> <span class="o">*&gt;</span>
      <span class="n">putStrLn</span><span class="o">(</span><span class="s">"Done #2"</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">val</span> <span class="n">process3</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">putStrLn</span><span class="o">(</span><span class="s">"Starting process #3"</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nc">IO</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="n">myState</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="k">_</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="s">"#3"</span><span class="o">))</span> <span class="o">*&gt;</span>
      <span class="n">putStrLn</span><span class="o">(</span><span class="s">"Done #3"</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">masterProcess</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">myState</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">.</span><span class="n">of</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="nc">List</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]).</span><span class="n">unsafeRunSync</span><span class="o">()</span>
    <span class="k">val</span> <span class="n">ioa</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">process1</span><span class="o">,</span> <span class="n">process2</span><span class="o">,</span> <span class="n">process3</span><span class="o">).</span><span class="n">parSequence</span><span class="o">.</span><span class="n">void</span>
    <span class="n">ioa</span> <span class="o">*&gt;</span> <span class="n">myState</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">rs</span> <span class="k">=&gt;</span> <span class="n">putStrLn</span><span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="n">toString</span><span class="o">))</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">ExitCode</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">masterProcess</span><span class="o">.</span><span class="n">as</span><span class="o">(</span><span class="nc">ExitCode</span><span class="o">.</span><span class="nc">Success</span><span class="o">)</span>

<span class="o">}</span>
</code></pre></div></div>

<p>We defined a <code class="highlighter-rouge">var myState: Ref[IO, List[String]]</code> initialized as <code class="highlighter-rouge">null</code> so we can create it on startup and all the child processes can have access to it. A so called <code class="highlighter-rouge">global state</code>.</p>

<p>But now we try to run our application and we encounter our first ugly problem: <code class="highlighter-rouge">NullPointerException</code> on line 19. All the processes are defined by using <code class="highlighter-rouge">myState</code> which has not yet been initialized. So an easy way to fix it is to define all our processes as <code class="highlighter-rouge">lazy val</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">lazy</span> <span class="k">val</span> <span class="n">process1</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="k">lazy</span> <span class="k">val</span> <span class="n">process2</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="k">lazy</span> <span class="k">val</span> <span class="n">process3</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>That worked, brilliant! We have an application that meets the business criteria and most importantly it works!</p>

<h3 id="rethinking-our-application">Rethinking our application</h3>

<p>But let’s take a step back and review our code once again, there are at least two pieces of code that should have caught your attention:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">myState</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="k">_</span>
</code></pre></div></div>

<p>We are using <code class="highlighter-rouge">var</code> and initializing our state to <code class="highlighter-rouge">null</code>, OMG! Also the workaround of <code class="highlighter-rouge">lazy val</code> should get you thinking…</p>

<p>And here’s the second obvious one:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">myState</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">.</span><span class="n">of</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="nc">List</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]).</span><span class="n">unsafeRunSync</span><span class="o">()</span>
</code></pre></div></div>

<p>We require our <code class="highlighter-rouge">myState</code> to be of type <code class="highlighter-rouge">Ref[IO, List[String]</code> but the smart constructor gives us an <code class="highlighter-rouge">IO[Ref[IO, List[String]]]</code> so we are “forced” to call <code class="highlighter-rouge">unsafeRunSync()</code> to get our desired type. And there’s a reason for that, the creation of a <code class="highlighter-rouge">Ref[F, A]</code> is side-effectful, therefore it needs to be wrapped in <code class="highlighter-rouge">IO</code> to keep the purity.</p>

<p>But wait a minute… that <code class="highlighter-rouge">unsafeRunSync()</code> is something that you should only see at the edge of your program, most commonly in the <code class="highlighter-rouge">main</code> method that is invoked by the <code class="highlighter-rouge">JVM</code> and that is impure by nature (of type <code class="highlighter-rouge">Unit</code>). But because we are using <code class="highlighter-rouge">IOApp</code> we shouldn’t be calling any operations which names are prefixed with <code class="highlighter-rouge">unsafe</code>.</p>

<p>You say to yourself, yes, I know this is bad and ugly but I don’t know a better way to share the state between different computations and this works. But we know you have heard that funcional programming is beautiful so why doing this?</p>

<h3 id="functional-programming">Functional Programming</h3>

<p>Okay, can we do better? Of course we do and you wouldn’t believe how simple it is!</p>

<p>Let’s get started by getting rid of that ugly <code class="highlighter-rouge">var myState</code> initialized to <code class="highlighter-rouge">null</code> and pass it as parameter to the processes that need to access it:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect._</span>
<span class="k">import</span> <span class="nn">cats.effect.concurrent.Ref</span>
<span class="k">import</span> <span class="nn">cats.instances.list._</span>
<span class="k">import</span> <span class="nn">cats.syntax.all._</span>

<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">object</span> <span class="nc">sharedstate</span> <span class="k">extends</span> <span class="nc">IOApp</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">putStrLn</span><span class="o">(</span><span class="n">str</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">str</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">process1</span><span class="o">(</span><span class="n">myState</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">putStrLn</span><span class="o">(</span><span class="s">"Starting process #1"</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nc">IO</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="n">myState</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="k">_</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="s">"#1"</span><span class="o">))</span> <span class="o">*&gt;</span>
      <span class="n">putStrLn</span><span class="o">(</span><span class="s">"Done #1"</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">process2</span><span class="o">(</span><span class="n">myState</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">putStrLn</span><span class="o">(</span><span class="s">"Starting process #2"</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nc">IO</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="n">myState</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="k">_</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="s">"#2"</span><span class="o">))</span> <span class="o">*&gt;</span>
      <span class="n">putStrLn</span><span class="o">(</span><span class="s">"Done #2"</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">process3</span><span class="o">(</span><span class="n">myState</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">putStrLn</span><span class="o">(</span><span class="s">"Starting process #3"</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nc">IO</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="n">myState</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="k">_</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="s">"#3"</span><span class="o">))</span> <span class="o">*&gt;</span>
      <span class="n">putStrLn</span><span class="o">(</span><span class="s">"Done #3"</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">masterProcess</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">myState</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Ref</span><span class="o">.</span><span class="n">of</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="nc">List</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]).</span><span class="n">unsafeRunSync</span><span class="o">()</span>

    <span class="k">val</span> <span class="n">ioa</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">process1</span><span class="o">(</span><span class="n">myState</span><span class="o">),</span> <span class="n">process2</span><span class="o">(</span><span class="n">myState</span><span class="o">),</span> <span class="n">process3</span><span class="o">(</span><span class="n">myState</span><span class="o">)).</span><span class="n">parSequence</span><span class="o">.</span><span class="n">void</span>
    <span class="n">ioa</span> <span class="o">*&gt;</span> <span class="n">myState</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">rs</span> <span class="k">=&gt;</span> <span class="n">putStrLn</span><span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="n">toString</span><span class="o">))</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">ExitCode</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">masterProcess</span><span class="o">.</span><span class="n">as</span><span class="o">(</span><span class="nc">ExitCode</span><span class="o">.</span><span class="nc">Success</span><span class="o">)</span>

<span class="o">}</span>
</code></pre></div></div>

<p>Great! We got rid of that <code class="highlighter-rouge">global state</code> and we are now passing our <code class="highlighter-rouge">Ref</code>as a parameter. Remember that it is a concurrency primitive meant to be accesed and modified in concurrent scenarios, so we are safe here.</p>

<p>Notice how all our processes are now defined as <code class="highlighter-rouge">def processN(myState: Ref[IO, List[String]])</code>.</p>

<h3 id="a-well-known-method-flatmap">A well known method: flatMap!</h3>

<p>Now, we still have that <code class="highlighter-rouge">unsafeRunSync()</code> hanging around our code, how can we get rid of it? The answer is <code class="highlighter-rouge">flatMap</code>!!!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">masterProcess</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Ref</span><span class="o">.</span><span class="n">of</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="nc">List</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">myState</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">ioa</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">process1</span><span class="o">(</span><span class="n">myState</span><span class="o">),</span> <span class="n">process2</span><span class="o">(</span><span class="n">myState</span><span class="o">),</span> <span class="n">process3</span><span class="o">(</span><span class="n">myState</span><span class="o">)).</span><span class="n">parSequence</span><span class="o">.</span><span class="n">void</span>
    <span class="n">ioa</span> <span class="o">*&gt;</span> <span class="n">myState</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">rs</span> <span class="k">=&gt;</span> <span class="n">putStrLn</span><span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="n">toString</span><span class="o">))</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>You only need to call <code class="highlighter-rouge">flatMap</code> once up in the call chain where you call the processes to make sure they all share the same state. If you don’t do this, a new <code class="highlighter-rouge">Ref</code> will be created every time you <code class="highlighter-rouge">flatMap</code> (remember creating a <code class="highlighter-rouge">Ref</code> is side effectful!) and thus your processes will not be sharing the same state changing the behavior of your program.</p>

<p>We now have a purely functional code that shares state in a simple and pure fashion. Here’s the entire FP program:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect._</span>
<span class="k">import</span> <span class="nn">cats.effect.concurrent.Ref</span>
<span class="k">import</span> <span class="nn">cats.instances.list._</span>
<span class="k">import</span> <span class="nn">cats.syntax.all._</span>

<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">object</span> <span class="nc">sharedstate</span> <span class="k">extends</span> <span class="nc">IOApp</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">putStrLn</span><span class="o">(</span><span class="n">str</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">str</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">process1</span><span class="o">(</span><span class="n">myState</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">putStrLn</span><span class="o">(</span><span class="s">"Starting process #1"</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nc">IO</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="n">myState</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="k">_</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="s">"#1"</span><span class="o">))</span> <span class="o">*&gt;</span>
      <span class="n">putStrLn</span><span class="o">(</span><span class="s">"Done #1"</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">process2</span><span class="o">(</span><span class="n">myState</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">putStrLn</span><span class="o">(</span><span class="s">"Starting process #2"</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nc">IO</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="n">myState</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="k">_</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="s">"#2"</span><span class="o">))</span> <span class="o">*&gt;</span>
      <span class="n">putStrLn</span><span class="o">(</span><span class="s">"Done #2"</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">process3</span><span class="o">(</span><span class="n">myState</span><span class="k">:</span> <span class="kt">Ref</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">putStrLn</span><span class="o">(</span><span class="s">"Starting process #3"</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="nc">IO</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span> <span class="o">*&gt;</span>
      <span class="n">myState</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="k">_</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="s">"#3"</span><span class="o">))</span> <span class="o">*&gt;</span>
      <span class="n">putStrLn</span><span class="o">(</span><span class="s">"Done #3"</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">masterProcess</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Ref</span><span class="o">.</span><span class="n">of</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="nc">List</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">myState</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">ioa</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">process1</span><span class="o">(</span><span class="n">myState</span><span class="o">),</span> <span class="n">process2</span><span class="o">(</span><span class="n">myState</span><span class="o">),</span> <span class="n">process3</span><span class="o">(</span><span class="n">myState</span><span class="o">)).</span><span class="n">parSequence</span><span class="o">.</span><span class="n">void</span>
      <span class="n">ioa</span> <span class="o">*&gt;</span> <span class="n">myState</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">rs</span> <span class="k">=&gt;</span> <span class="n">putStrLn</span><span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="n">toString</span><span class="o">))</span>
    <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">ExitCode</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">masterProcess</span><span class="o">.</span><span class="n">as</span><span class="o">(</span><span class="nc">ExitCode</span><span class="o">.</span><span class="nc">Success</span><span class="o">)</span>

<span class="o">}</span>
</code></pre></div></div>

<h2 id="mutable-reference">Mutable reference</h2>

<p>As I mentioned in one of the sections above, the creation of <code class="highlighter-rouge">Ref[F, A]</code> is side-effectful. So what does this mean? Does it write to disk? Does it perform HTTP Requests? Not exactly.</p>

<p>It all comes down to wanting to keep the property of <em>referential transparency</em> while sharing and mutating state. So let’s again put up an example to follow up along with some explanation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">a</span> <span class="k">=</span> <span class="n">n</span>
<span class="k">def</span> <span class="n">get</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">a</span>
</code></pre></div></div>

<p>Here we have imperative and impure code that mutates state. So we can try wrapping things in <code class="highlighter-rouge">IO</code> to keep side effects under control:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">IORef</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="n">a</span> <span class="k">=</span> <span class="n">n</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">get</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This is way better since now the mutation is encapsulated within <code class="highlighter-rouge">IORef</code> but we are now pushing some responsibility to whoever creates an <code class="highlighter-rouge">IORef</code>. Consider this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">ref</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">IORef</span><span class="o">()</span>
</code></pre></div></div>

<p>If we have two or more references to <code class="highlighter-rouge">ref</code> in our code, they will be referring to the same mutable state and we don’t really want that. We can make sure this doesn’t happen and a way to achieve this is to wrap the creation of <code class="highlighter-rouge">IORef</code> in <code class="highlighter-rouge">IO</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">class</span> <span class="nc">IORef</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="n">a</span> <span class="k">=</span> <span class="n">n</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">get</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">IORef</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">IORef</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="k">new</span> <span class="nc">IORef</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We have now regained purity. So whenever you create an <code class="highlighter-rouge">IORef</code> you’ll get an <code class="highlighter-rouge">IO[IORef]</code> instead of a mutable reference to <code class="highlighter-rouge">IORef</code>. This means that when you invoke <code class="highlighter-rouge">flatMap</code> on it twice you’ll get two different mutable states, and this is the power of <code class="highlighter-rouge">Referential Transparency</code>. It gives you way more control than having a <code class="highlighter-rouge">val ref</code> hanging around in your code and gives you <strong><em>local reasoning</em></strong>.</p>

<p><em>All these examples are written in terms of <code class="highlighter-rouge">IO</code> for the sake of simplicity but in practice they are polymorphic on the effect type.</em></p>

<h2 id="applying-the-technique-in-other-libraries">Applying the technique in other libraries</h2>

<p>Although in the example above we only see how it’s done with the <code class="highlighter-rouge">cats-effect</code> library, this principle expands to other FP libraries as well.</p>

<p>For example, when writing an <code class="highlighter-rouge">http4s</code> application you might need to create an <code class="highlighter-rouge">HttpClient</code> that needs to be used by more than one of your services. So again, create it at startup and <code class="highlighter-rouge">flatMap</code> it once:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">HttpServer</span> <span class="k">extends</span> <span class="nc">StreamApp</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">stream</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">requestShutdown</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">])</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">ExitCode</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="n">httpClient</span> <span class="k">&lt;-</span> <span class="nc">Http1Client</span><span class="o">.</span><span class="n">stream</span><span class="o">[</span><span class="kt">IO</span><span class="o">]()</span>
      <span class="n">endpoint1</span>  <span class="k">=</span> <span class="k">new</span> <span class="nc">HttpEndpointOne</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">httpClient</span><span class="o">)</span>
      <span class="n">endpoint2</span>  <span class="k">=</span> <span class="k">new</span> <span class="nc">HttpEndpointTwo</span><span class="o">[</span><span class="kt">IO</span><span class="o">](</span><span class="n">httpClient</span><span class="o">)</span>
      <span class="n">exitCode</span>   <span class="k">&lt;-</span> <span class="nc">BlazeBuilder</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
                      <span class="o">.</span><span class="n">bindHttp</span><span class="o">(</span><span class="mi">8080</span><span class="o">,</span> <span class="s">"0.0.0.0"</span><span class="o">)</span>
                      <span class="o">.</span><span class="n">mountService</span><span class="o">(</span><span class="n">endpoint1</span><span class="o">)</span>
                      <span class="o">.</span><span class="n">mountService</span><span class="o">(</span><span class="n">endpoint2</span><span class="o">)</span>
                      <span class="o">.</span><span class="n">serve</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="n">exitCode</span>

<span class="o">}</span>

<span class="k">class</span> <span class="nc">HttpEndpointOne</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">client</span><span class="k">:</span> <span class="kt">Client</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="k">class</span> <span class="nc">HttpEndpointTwo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">client</span><span class="k">:</span> <span class="kt">Client</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div></div>

<p>When writing <code class="highlighter-rouge">fs2</code> applications you can apply the same technique, for example between processes that share a <code class="highlighter-rouge">Queue</code>, <code class="highlighter-rouge">Topic</code>, <code class="highlighter-rouge">Signal</code>, <code class="highlighter-rouge">Semaphore</code>, etc.</p>

<p>Remember that if you are forced to call <code class="highlighter-rouge">unsafeRunSync()</code> other than in your <code class="highlighter-rouge">main</code> method it might be a <em>code smell</em>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>To conclude this post I would like to give a big shout out to <a href="https://github.com/SystemFw">@SystemFW</a> who has been untiringly teaching this concept in the Gitter channels. And here’s a quote from his response on <a href="https://www.reddit.com/r/scala/comments/8ofc8j/shared_state_in_pure_functional_programming_github/e050wy2/">Reddit</a>:</p>

<blockquote>
  <p>At the end of the day all the benefits from <em>referential transparency</em> boil down to being able to understand and build code compositionally. That is, understanding code by understanding individual parts and putting them back together, and building code by building individual parts and combining them together. This is only possible if <em>local reasoning</em> is guaranteed, because otherwise there will be weird interactions when you put things back together, and referential transparency is <em>defined</em> as something that guarantees local reasoning.</p>
</blockquote>

<blockquote>
  <p>In the specific case of state sharing, this gives rise to a really nice property: since the only way to share is passing things as an argument, <em>the regions of sharing are exactly the same of your call graph</em>, so you transform an important aspect of the behaviour (“who shares this state?”) into a straightforward syntactical property (“what methods take this argument”?). This makes shared state in pure FP a lot easier to reason about than its side-effectful counterpart imho.</p>
</blockquote>

<p>In simple terms, remind yourself about this: <strong>“flatMap once and pass the reference as an argument!”</strong></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 07 Jun 2018 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2018/06/07/shared-state-in-fp.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/06/07/shared-state-in-fp.html</guid>
      </item>
    
      <item>
        <title>Tagless Final algebras and Streaming</title>
        
          <dc:creator>gvolpe</dc:creator>
                
        <description><![CDATA[<p>There have been a couple of really <a href="https://typelevel.org/blog/2017/12/27/optimizing-final-tagless.html">nice blog posts</a> about <code class="highlighter-rouge">Tagless Final</code> and some related topics. However, I have faced some design problems when writing some algebras and haven’t seen anybody talking about. So please let me introduce this problem to you.</p>

<h3 id="algebra-definition">Algebra definition</h3>

<p>Given the following data definition:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">ItemName</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Item</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">,</span> <span class="n">price</span><span class="k">:</span> <span class="kt">BigDecimal</span><span class="o">)</span>
</code></pre></div></div>

<p>Consider the following algebra:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">ItemRepository</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">findAll</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Item</span><span class="o">]]</span>
  <span class="k">def</span> <span class="n">find</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Item</span><span class="o">]]</span>
  <span class="k">def</span> <span class="n">save</span><span class="o">(</span><span class="n">item</span><span class="k">:</span> <span class="kt">Item</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Let’s go through each method’s definition:</p>

<ul>
  <li><code class="highlighter-rouge">findAll</code> needs to return many Items, obtainable inside a context: <code class="highlighter-rouge">F[List[Item]]</code>.</li>
  <li><code class="highlighter-rouge">find</code> might or might not return an Item inside a context: <code class="highlighter-rouge">F[Option[Item]]</code>.</li>
  <li><code class="highlighter-rouge">save</code> and <code class="highlighter-rouge">remove</code> will perform some actions without returning any actual value: <code class="highlighter-rouge">F[Unit]</code>.</li>
</ul>

<p>Everything is clear and you might have seen this kind of pattern before, so let’s create an interpreter for it:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">doobie.implicits._</span>
<span class="k">import</span> <span class="nn">doobie.util.transactor.Transactor</span>
<span class="k">import</span> <span class="nn">cats.effect.Sync</span>

<span class="c1">// Doobie implementation (not fully implemented, what matters here are the types).
</span><span class="k">class</span> <span class="nc">PostgreSQLItemRepository</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">xa</span><span class="k">:</span> <span class="kt">Transactor</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span>
                                    <span class="o">(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">ItemRepository</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">findAll</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Item</span><span class="o">]]</span> <span class="k">=</span> <span class="n">sql</span><span class="s">"select name, price from items"</span>
                                           <span class="o">.</span><span class="n">query</span><span class="o">[</span><span class="kt">Item</span><span class="o">]</span>
                                           <span class="o">.</span><span class="n">to</span><span class="o">[</span><span class="kt">List</span><span class="o">]</span>
                                           <span class="o">.</span><span class="n">transact</span><span class="o">(</span><span class="n">xa</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">find</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Item</span><span class="o">]]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">save</span><span class="o">(</span><span class="n">item</span><span class="k">:</span> <span class="kt">Item</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">unit</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">unit</span>
<span class="o">}</span>

</code></pre></div></div>

<p>Here we are using <a href="http://tpolecat.github.io/doobie/">Doobie</a>, defined as <code class="highlighter-rouge">A principled JDBC layer for Scala</code> and one of the most popular DB libraries in the Typelevel ecosystem. And it comes with one super powerful feature: it supports <code class="highlighter-rouge">Streaming</code> results, since it’s built on top of <a href="https://functional-streams-for-scala.github.io/fs2/">fs2</a>.</p>

<p>Now it could be very common to have a huge amount of <code class="highlighter-rouge">Item</code>s in our DB that a <code class="highlighter-rouge">List</code> will not fit into memory and / or it will be a very expensive operation. So we might want to stream the results of <code class="highlighter-rouge">findAll</code> instead of have them all in memory on a <code class="highlighter-rouge">List</code>, making <code class="highlighter-rouge">Doobie</code> a great candidate for the job. But wait… We have a problem now. Our <code class="highlighter-rouge">ItemRepository</code> algebra has fixed the definition of <code class="highlighter-rouge">findAll</code> as <code class="highlighter-rouge">F[List[Item]]</code> so we won’t be able to create an interpreter that returns a streaming result instead.</p>

<h3 id="rethinking-our-algebra">Rethinking our algebra</h3>

<p>We should think about abstracting over that <code class="highlighter-rouge">List</code> and two of the most common abstractions that immediately come to mind are <code class="highlighter-rouge">Foldable</code> and <code class="highlighter-rouge">Traverse</code>. But although these typeclasses are very useful, they are not enough to represent a stream of values, so we should come up with a better abstraction.</p>

<p>Well, it seems that our options are either adding another higher-kinded parameter <code class="highlighter-rouge">G[_]</code> to our algebra or just define an abstract member <code class="highlighter-rouge">G[_]</code>. So let’s go with the first one:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">ItemRepository</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">findAll</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">Item</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">find</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Item</span><span class="o">]]</span>
  <span class="k">def</span> <span class="n">save</span><span class="o">(</span><span class="n">item</span><span class="k">:</span> <span class="kt">Item</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Great! This looks good so far.</p>

<h3 id="streaming-support-interpreter">Streaming support interpreter</h3>

<p>Now let’s write a new <code class="highlighter-rouge">PostgreSQL</code> interpreter with streaming support:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">doobie.implicits._</span>
<span class="k">import</span> <span class="nn">doobie.util.transactor.Transactor</span>
<span class="k">import</span> <span class="nn">fs2.Stream</span>

<span class="c1">// Doobie implementation (not fully implemented, what matters here are the types).
</span><span class="k">class</span> <span class="nc">StreamingItemRepository</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">xa</span><span class="k">:</span> <span class="kt">Transactor</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span>
                                   <span class="o">(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">ItemRepository</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Stream</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">findAll</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Item</span><span class="o">]</span> <span class="k">=</span> <span class="n">sql</span><span class="s">"select name, price from items"</span>
                                           <span class="o">.</span><span class="n">query</span><span class="o">[</span><span class="kt">Item</span><span class="o">]</span>
                                           <span class="o">.</span><span class="n">stream</span>
                                           <span class="o">.</span><span class="n">transact</span><span class="o">(</span><span class="n">xa</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">find</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Item</span><span class="o">]]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">save</span><span class="o">(</span><span class="n">item</span><span class="k">:</span> <span class="kt">Item</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">delay</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Saving item: $item"</span><span class="o">))</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">delay</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Removing item: $item"</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Voilà! We got our streaming implementation of <code class="highlighter-rouge">findAll</code>.</p>

<h3 id="test-interpreter">Test interpreter</h3>

<p>That’s all we wanted, but what about testing it? Sure, we might prefer to have a simple implementation by just using a plain <code class="highlighter-rouge">List</code>, so what can we possibly do?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">MemRepository</span> <span class="k">extends</span> <span class="nc">ItemRepository</span><span class="o">[</span><span class="kt">Id</span>, <span class="kt">List</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">mem</span> <span class="k">=</span> <span class="nc">MutableMap</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Item</span><span class="o">]</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">findAll</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Item</span><span class="o">]</span> <span class="k">=</span> <span class="n">mem</span><span class="o">.</span><span class="n">headOption</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">_2</span><span class="o">).</span><span class="n">toList</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">find</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">Id</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Item</span><span class="o">]]</span> <span class="k">=</span> <span class="n">mem</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">save</span><span class="o">(</span><span class="n">item</span><span class="k">:</span> <span class="kt">Item</span><span class="o">)</span><span class="k">:</span> <span class="kt">Id</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">mem</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="o">,</span> <span class="n">item</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">Id</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">mem</span><span class="o">.</span><span class="n">remove</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="o">)</span>
    <span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>That’s pretty much it! We managed to abstract over the return type of <code class="highlighter-rouge">findAll</code> by just adding an extra parameter to our algebra.</p>

<h3 id="about-composition">About composition</h3>

<p>At this point the avid reader might have thought, what if I want to write a generic function that takes all the items (using <code class="highlighter-rouge">findAll</code>), applies some discounts and writes them back to the DB (using <code class="highlighter-rouge">save</code>)?</p>

<p>Short answer is, you might want to define a different algebra where <code class="highlighter-rouge">findAll</code> and <code class="highlighter-rouge">save</code> have the same types (eg: both of them are streams) but in case you find yourself wanting to make this work with the current types then let’s try and find out!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DiscountProcessor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Functor</span><span class="o">](</span><span class="n">repo</span><span class="k">:</span> <span class="kt">ItemRepository</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span><span class="o">],</span> <span class="n">join</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">])</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">process</span><span class="o">(</span><span class="n">discount</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">items</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">Item</span><span class="o">]</span> <span class="k">=</span> <span class="n">repo</span><span class="o">.</span><span class="n">findAll</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">item</span> <span class="k">=&gt;</span> <span class="n">item</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">price</span> <span class="k">=</span> <span class="n">item</span><span class="o">.</span><span class="n">price</span> <span class="o">*</span> <span class="o">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">discount</span><span class="o">)))</span>
    <span class="k">val</span> <span class="n">saved</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]]</span> <span class="k">=</span> <span class="n">items</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">repo</span><span class="o">.</span><span class="n">save</span><span class="o">)</span>
    <span class="n">join</span><span class="o">(</span><span class="n">saved</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We defined a <code class="highlighter-rouge">join</code> function responsible for evaluating the effects and flatten the result to <code class="highlighter-rouge">F[Unit]</code>. As you can see below, this works for both a streaming interpreter and a list interpreter (shout out to <a href="https://github.com/fthomas">fthomas</a> for proposing this solution):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">StreamingDiscountInterpreter</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">val</span> <span class="n">join</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]]</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="k">_</span><span class="o">.</span><span class="n">evalMap</span><span class="o">(</span><span class="n">identity</span><span class="o">).</span><span class="n">compile</span><span class="o">.</span><span class="n">drain</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">repo</span><span class="k">:</span> <span class="kt">ItemRepository</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Stream</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">?</span><span class="o">]])</span><span class="k">:</span> <span class="kt">DiscountProcessor</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Stream</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">DiscountProcessor</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Stream</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">?</span><span class="o">]](</span><span class="n">repo</span><span class="o">,</span> <span class="n">join</span><span class="o">)</span>

<span class="o">}</span>

<span class="k">object</span> <span class="nc">ListDiscountInterpreter</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">val</span> <span class="n">join</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]]</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">list</span> <span class="k">=&gt;</span> <span class="nc">Traverse</span><span class="o">[</span><span class="kt">List</span><span class="o">].</span><span class="n">sequence</span><span class="o">(</span><span class="n">list</span><span class="o">).</span><span class="n">void</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">repo</span><span class="k">:</span> <span class="kt">ItemRepository</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">])</span><span class="k">:</span> <span class="kt">DiscountProcessor</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">DiscountProcessor</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">](</span><span class="n">repo</span><span class="o">,</span> <span class="n">join</span><span class="o">)</span>

<span class="o">}</span>
</code></pre></div></div>

<p>While in this case it was possible to make it generic I don’t recommend to do this at home because:</p>

<ol>
  <li>it involves some extra boilerplate and the code becomes harder to understand / maintain.</li>
  <li>as soon as the logic gets more complicated you might run out of options to make it work in a generic way.</li>
  <li>you lose the ability to use the <code class="highlighter-rouge">fs2 DSL</code> which is super convenient.</li>
</ol>

<p>What I recommend instead, is to write this kind of logic in the streaming interpreter itself. You could also write a generic program that implements the parts that can be abstracted (eg. applying a discount to an item <code class="highlighter-rouge">f: Item =&gt; Item</code>) and leave the other parts to the interpreter.</p>

<h3 id="design-alternative">Design alternative</h3>

<p>Another possible and very interesting alternative suggested by <a href="https://github.com/mpilquist">Michael Pilquist</a>, would be to define our repository as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">ItemRepository</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">S</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">findAll</span><span class="k">:</span> <span class="kt">S</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Item</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Where the second type parameter matches the shape of <code class="highlighter-rouge">fs2.Stream</code>. In this case our streaming repository will remain the same (it should just extend <code class="highlighter-rouge">ItemRepository[F, Stream]</code> instead of <code class="highlighter-rouge">ItemRepository[F, Stream[F, ?]]</code>) but our in memory interpreter will now rely on <code class="highlighter-rouge">fs2.Stream</code> instead of a parametric <code class="highlighter-rouge">G[_]</code>, for example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">MemRepositoryAlt</span> <span class="k">extends</span> <span class="nc">ItemRepository</span><span class="o">[</span><span class="kt">Id</span>, <span class="kt">Stream</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">findAll</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Id</span>, <span class="kt">Item</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">sql</span><span class="s">"select name, price from items"</span>
      <span class="o">.</span><span class="n">query</span><span class="o">[</span><span class="kt">Item</span><span class="o">]</span>
      <span class="o">.</span><span class="n">stream</span>
      <span class="o">.</span><span class="n">transact</span><span class="o">(</span><span class="n">xa</span><span class="o">)</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>I think it’s an alternative worth exploring further that might require a blog post on its own, so I’ll leave it here for reference :)</p>

<h3 id="source-of-inspiration">Source of inspiration</h3>

<p>I’ve come up with most of the ideas presented here during my work on <a href="https://gvolpe.github.io/fs2-rabbit/">Fs2 Rabbit</a>, a stream based client for <code class="highlighter-rouge">Rabbit MQ</code>, where I make heavy use of this technique as I originally described in <a href="https://partialflow.wordpress.com/2018/02/01/a-tale-of-tagless-final-cats-effect-and-streaming-fs2-rabbit-v0-1/">this blog post</a>.</p>

<p>Another great source of inspiration was <a href="https://www.youtube.com/watch?v=1h11efA4k8E">this talk</a> given by <a href="https://github.com/LukaJCB">Luka Jacobowitz</a> at Scale by the Bay.</p>

<h3 id="abstracting-over-the-effect-type">Abstracting over the effect type</h3>

<p>One thing you might have noticed in the examples above is that both <code class="highlighter-rouge">ItemRepository</code> interpreters are not fixed to <code class="highlighter-rouge">IO</code> or <code class="highlighter-rouge">Task</code> or any other effect type but rather requiring a parametric <code class="highlighter-rouge">F[_]</code> and an implicit instance of <code class="highlighter-rouge">Sync[F]</code>. This is a quite powerful technique for both library authors and application developers. Well know libraries such as <a href="https://http4s.org/">Http4s</a>, <a href="https://monix.io/">Monix</a> and <a href="https://functional-streams-for-scala.github.io/fs2/">Fs2</a> make a heavy use of it.</p>

<p>And by requiring a <code class="highlighter-rouge">Sync[F]</code> instance we are just saying that our implementation will need to suspend synchronous side effects.</p>

<p>Once at the edge of our program, commonly the main method, we can give <code class="highlighter-rouge">F[_]</code> a concrete type. At the moment, there are two options: <code class="highlighter-rouge">cats.effect.IO</code> and <code class="highlighter-rouge">monix.eval.Task</code>. But hopefully soon we’ll have a <code class="highlighter-rouge">Scalaz 8 IO</code> implementation as well (fingers crossed).</p>

<h3 id="principle-of-least-power">Principle of least power</h3>

<p>Abstracting over the effect type doesn’t only mean that we should require <code class="highlighter-rouge">Sync[F]</code>, <code class="highlighter-rouge">Async[F]</code> or <code class="highlighter-rouge">Effect[F]</code>. It also means that we should only require the minimal typeclass instance that satisfies our predicate. For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Functor</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">def</span> <span class="n">bar</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

<span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Functor</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">fa</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span>
</code></pre></div></div>

<p>Here our <code class="highlighter-rouge">bar</code> method just returns a pure value in the <code class="highlighter-rouge">F</code> context, thus we need an <code class="highlighter-rouge">Applicative[F]</code> instance that defines <code class="highlighter-rouge">pure</code>. On the other hand, our <code class="highlighter-rouge">foo</code> method just converts the inner <code class="highlighter-rouge">Int</code> into <code class="highlighter-rouge">String</code>, what we call a pure data transformation. So all we need here is a <code class="highlighter-rouge">Functor[F]</code> instance. Another example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Monad</span>

<span class="k">def</span> <span class="n">fp</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
<span class="o">`</span>  <span class="k">for</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">&lt;-</span> <span class="n">bar</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="n">bar</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</code></pre></div></div>

<p>The above implementation makes use of a <code class="highlighter-rouge">for-comprehension</code> which is a syntactic sugar for <code class="highlighter-rouge">flatMap</code> and <code class="highlighter-rouge">map</code>, so all we need is a <code class="highlighter-rouge">Monad[F]</code> instance because we also need an <code class="highlighter-rouge">Applicative[F]</code> instance for <code class="highlighter-rouge">bar</code>, otherwise we could just use a <code class="highlighter-rouge">FlatMap[F]</code> instance.</p>

<h3 id="final-thoughts">Final thoughts</h3>

<p>I think we got quite far with all these abstractions, giving us the chance to write clean and elegant code in a pure functional programming style, and there’s even more! Other topics worth mentioning that might require a blog post on their own are:</p>

<ul>
  <li>Dependency Injection
    <ul>
      <li>Tagless Final + implicits (MTL style) enables DI in an elegant way.</li>
    </ul>
  </li>
  <li>Algebras Composition
    <ul>
      <li>It is very common to have multiple algebras with a different <code class="highlighter-rouge">F[_]</code> implementation. In some cases, <code class="highlighter-rouge">FunctionK</code> (a.k.a. natural transformation) can be the solution.</li>
    </ul>
  </li>
</ul>

<p>What do you think about it? Have you come across a similar design problem? I’d love to hear your thoughts!</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 09 May 2018 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2018/05/09/tagless-final-streaming.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/05/09/tagless-final-streaming.html</guid>
      </item>
    
      <item>
        <title>Product with Serializable</title>
        
          <dc:creator>ceedubs</dc:creator>
                
        <description><![CDATA[<p>A somewhat common Scala idiom is to make an <code class="highlighter-rouge">abstract</code> type extend <code class="highlighter-rouge">Product with Serializable</code>. There isn’t an obvious reason to do this, and people have asked me a number of times why I’ve done this. While I don’t think that <code class="highlighter-rouge">Product</code> or <code class="highlighter-rouge">Serializable</code> are particularly good abstractions, there’s a reason that I extend them.</p>

<p>Let’s say that I’m writing a simple enum-like <code class="highlighter-rouge">Status</code> type:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">EnumExample1</span> <span class="o">{</span>
  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Status</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Pending</span> <span class="k">extends</span> <span class="nc">Status</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">InProgress</span> <span class="k">extends</span> <span class="nc">Status</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Finished</span> <span class="k">extends</span> <span class="nc">Status</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now let’s create a <code class="highlighter-rouge">Set</code> of statuses that represent incomplete items:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">EnumExample1._</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">incomplete</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="nc">Pending</span><span class="o">,</span> <span class="nc">InProgress</span><span class="o">)</span>
<span class="c1">// incomplete: scala.collection.immutable.Set[Product with Serializable with EnumExample1.Status] = Set(Pending, InProgress)
</span></code></pre></div></div>

<p>Here, I didn’t give in explicit return type to <code class="highlighter-rouge">incomplete</code> and you may have noticed that the compiler inferred a somewhat bizarre one: <code class="highlighter-rouge">Set[Product with Serializable with Status]</code>. Why is that?</p>

<p>The compiler generally tries to infer the most specific type possible. Usually this makes sense. If you write <code class="highlighter-rouge">val x = 3</code> you probably don’t want it to infer <code class="highlighter-rouge">val x: Any = 3</code>. And in the example above, I didn’t want the return type for <code class="highlighter-rouge">incomplete</code> to be inferred as <code class="highlighter-rouge">Any</code> or even <code class="highlighter-rouge">Set[Any]</code>. However, the compiler was a bit <em>too</em> clever and realized that not only is every item in the set an instance of <code class="highlighter-rouge">Status</code>, they are also instances of <code class="highlighter-rouge">Product</code> and <code class="highlighter-rouge">Serializable</code> since every <code class="highlighter-rouge">case object</code> (and <code class="highlighter-rouge">case class</code>) automatically extends <code class="highlighter-rouge">Product</code> and <code class="highlighter-rouge">Serializable</code>. Therefore, when it calculates the least upper bound (LUB) of the types in the set, it comes up with <code class="highlighter-rouge">Product with Serializable with Status</code>.</p>

<p>While there’s nothing inherently wrong with the return type of <code class="highlighter-rouge">Product with Serializable with Status</code>, it is verbose, it wasn’t what I intended, and in certain situations it might cause inference issues. Luckily there’s a simple workaround to get the inferred type that I want:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">EnumExample2</span> <span class="o">{</span>
  <span class="c1">// note the `extends` addition here
</span>  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Status</span> <span class="k">extends</span> <span class="nc">Product</span> <span class="k">with</span> <span class="nc">Serializable</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Pending</span> <span class="k">extends</span> <span class="nc">Status</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">InProgress</span> <span class="k">extends</span> <span class="nc">Status</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Finished</span> <span class="k">extends</span> <span class="nc">Status</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">EnumExample2._</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">incomplete</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="nc">Pending</span><span class="o">,</span> <span class="nc">InProgress</span><span class="o">)</span>
<span class="c1">// incomplete: scala.collection.immutable.Set[EnumExample2.Status] = Set(Pending, InProgress)
</span></code></pre></div></div>

<p>Now since <code class="highlighter-rouge">Status</code> itself already includes <code class="highlighter-rouge">Product</code> and <code class="highlighter-rouge">Serializable</code>, <code class="highlighter-rouge">Status</code> is the LUB type of <code class="highlighter-rouge">Pending</code>, <code class="highlighter-rouge">InProgress</code>, and <code class="highlighter-rouge">Finished</code>.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 09 May 2018 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2018/05/09/product-with-serializable.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/05/09/product-with-serializable.html</guid>
      </item>
    
      <item>
        <title>Rethinking MonadError</title>
        
          <dc:creator>lukajcb</dc:creator>
                
        <description><![CDATA[<p><code class="highlighter-rouge">MonadError</code> is a very old type class, hackage shows me it was originally added in 2001, long before I had ever begun doing functional programming, just check the <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Error-Class.html">hackage page</a>.
In this blog post I’d like to rethink the way we use <code class="highlighter-rouge">MonadError</code> today.
It’s usually used to signal that a type might be capable of error handling and is basically like a type class encoding of <code class="highlighter-rouge">Either</code>s ability to short circuit.
That makes it pretty useful for building computations from sequences of values that may fail and then halt the computation or to catch those errors in order to resume the computation.
It’s also parametrized by its error type, making it one of the most common example of multi-parameter type classes.
Some very common instances include <code class="highlighter-rouge">Either</code> and <code class="highlighter-rouge">IO</code>, but there are a ton more.</p>

<p>We can divide instances into 3 loosely defined groups:</p>

<p>First we have simple data types like <code class="highlighter-rouge">Either</code>, <code class="highlighter-rouge">Option</code> or <code class="highlighter-rouge">Ior</code> (with <code class="highlighter-rouge">Validated</code> not having a <code class="highlighter-rouge">Monad</code> instance).</p>

<p>Secondly we’ve got the <code class="highlighter-rouge">IO</code>-like types, the various <code class="highlighter-rouge">IO</code>s, <code class="highlighter-rouge">Task</code>s and the like. These are used to suspend side effects which might have errors and therefore need to be able to handle these.</p>

<p>Thirdly and least importantly, we have monad transformers, which get their instances from their respective underlying monads. Since they basically just propagate their underlying instances we’re only going to talk about the first two groups for now.</p>

<p>The simple data types all define <code class="highlighter-rouge">MonadError</code> instances, but I wager they’re not actually used as much. This is because <code class="highlighter-rouge">MonadError</code> doesn’t actually allow us to deconstruct e.g. an <code class="highlighter-rouge">Either</code> to actually handle the errors. We’ll see more on that later, next let’s look at the <code class="highlighter-rouge">IO</code>-like types and their instances.</p>

<p><code class="highlighter-rouge">cats.effect.IO</code> currently defines a <code class="highlighter-rouge">MonadError[IO, Throwable]</code>, meaning that it’s fully able to raise and catch errors that might be thrown during evaluation of encapsulated side effects.
Using <code class="highlighter-rouge">MonadError</code> with these effect types seems a lot more sensical at first, as you can’t escape <code class="highlighter-rouge">IO</code> even when you handle errors, so it looks like it makes sense to stay within <code class="highlighter-rouge">IO</code> due to the side effect capture.</p>

<p>The problem I see with <code class="highlighter-rouge">MonadError</code> is that it does not address the fundamental difference between these two types of instances. I can pattern match an <code class="highlighter-rouge">Option[A]</code> with a default value to get back an <code class="highlighter-rouge">A</code>. With <code class="highlighter-rouge">IO</code> that is just not possible. So these two groups of types are pretty different, when does it actually make sense to abstract over both of them?
Well, it turns out there a few instances where it might be useful, but as we’ll see later, I’m proposing something that will be equally useful to both groups.</p>

<p>Now before we continue, let’s look at the <code class="highlighter-rouge">MonadError</code> type class in a bit more detail.
<code class="highlighter-rouge">MonadError</code> currently comprises two parts, throwing and catching errors.
To begin let’s have a look at the <code class="highlighter-rouge">throw</code> part, sometimes also called <code class="highlighter-rouge">MonadThrow</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">raiseError</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This looks fine for now, but one thing that strikes me is that the <code class="highlighter-rouge">F</code> type seems to “swallow” errors.
If we look at <code class="highlighter-rouge">F[A]</code> we have no clue that it might actually yield an error of type <code class="highlighter-rouge">E</code>, that fact is not required to be represented at all.
However, that’s not a really big issue, so now let’s look at the <code class="highlighter-rouge">catch</code> part:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">MonadThrow</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="k">def</span> <span class="n">handleErrorWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Immediately I have a few questions, if the errors are handled, why does it return the exact same type?
Furthermore if this is really supposed to handle errors, what happens if I have errors in the <code class="highlighter-rouge">E =&gt; F[A]</code> function? 
This is even more blatant in the <code class="highlighter-rouge">attempt</code> function:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">attempt</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Here there is no way the outer <code class="highlighter-rouge">F</code> still has any errors, so why does it have the same type?
Shouldn’t we represent the fact that we handled all the errors in the type system?
This means you can’t actually observe that the errors are now inside <code class="highlighter-rouge">Either</code>. That leads to this being fully legal code:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.implicits._</span>
<span class="c1">// import cats.implicits._
</span>
<span class="nc">Option</span><span class="o">(</span><span class="mi">42</span><span class="o">).</span><span class="n">attempt</span><span class="o">.</span><span class="n">attempt</span><span class="o">.</span><span class="n">attempt</span><span class="o">.</span><span class="n">attempt</span>
<span class="c1">// res0: Option[Either[Unit,Either[Unit,Either[Unit,Either[Unit,Int]]]]] = Some(Right(Right(Right(Right(42)))))
</span></code></pre></div></div>

<p>Another example that demonstrates this is the fact that calling <code class="highlighter-rouge">handleError</code>, which looks like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">handleError</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>
<p>also returns an <code class="highlighter-rouge">F[A]</code>. This method takes a pure function <code class="highlighter-rouge">E =&gt; A</code> and thus can not fail during recovery like <code class="highlighter-rouge">handleErrorWith</code>, yet it still doesn’t give us any sign that it doesn’t throw errors.
For <code class="highlighter-rouge">IO</code>-like types this is somewhat excusable as something like an unexceptional <code class="highlighter-rouge">IO</code> is still very uncommon, but for simple data types like <code class="highlighter-rouge">Either</code> or <code class="highlighter-rouge">Some</code> that function should just return an <code class="highlighter-rouge">A</code>, since that’s the only thing it can be.
Just like with <code class="highlighter-rouge">attempt</code>, we can infinitely chain calls to <code class="highlighter-rouge">handleError</code>, as it will never change the type.</p>

<p>Ideally our type system should stop us from being able to write this nonsensical code and give us a way to show anyone reading the code that we’ve already handled errors.
Now I’m not saying that the functions on <code class="highlighter-rouge">MonadError</code> aren’t useful, but only that they could be more constrained and thus more accurate in their representation.</p>

<p>For this purpose let’s try to write a different <code class="highlighter-rouge">MonadError</code> type class, one that’s designed to leverage the type system to show when values are error-free, we’ll call it <code class="highlighter-rouge">MonadBlunder</code> for now.</p>

<p>To mitigate the problems with <code class="highlighter-rouge">MonadError</code> we have a few options, the first one I’d like to present is using two different type constructors to represent types that might fail and types that are guaranteed not to. So instead of only a single type constructor our <code class="highlighter-rouge">MonadBlunder</code> class will have two:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span>
</code></pre></div></div>

<p>Our type class now has the shape <code class="highlighter-rouge">(* -&gt; *) -&gt; (* -&gt; *) -&gt; * -&gt; *</code>, which is quite a handful, but I believe we can justify its usefulness.
The first type parameter <code class="highlighter-rouge">F[_]</code> will represent our error-handling type, which will be able to yield values of type <code class="highlighter-rouge">E</code>.
The second type parameter <code class="highlighter-rouge">G[_]</code> will represent a corresponding type that does not allow any errors and can therefore guarantee that computations of the form <code class="highlighter-rouge">G[A]</code> will always yield a value of type <code class="highlighter-rouge">A</code>.</p>

<p>Now that we figured out the shape, let’s see what we can actually do with it.
For throwing errors, we’ll create a <code class="highlighter-rouge">raiseError</code> function that should return a value inside <code class="highlighter-rouge">F</code>, as it will obviously be able to yield an error.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">raiseError</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This definition looks identical to the one defined one <code class="highlighter-rouge">MonadError</code> so let’s move on to error-handling.
For handled errors, we want to return a value inside <code class="highlighter-rouge">G</code>, so our <code class="highlighter-rouge">handleErrorWith</code> function should indeed return a <code class="highlighter-rouge">G[A]</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="k">def</span> <span class="n">handleErrorWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Looks good so far, right? 
Well, we still have the problem that <code class="highlighter-rouge">f</code> might return an erronous value, so if we want to guarantee that the result won’t have any errors, we’ll have to change that to <code class="highlighter-rouge">G[A]</code> as well:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="k">def</span> <span class="n">handleErrorWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And now we’re off to a pretty good start, we fixed one short coming of <code class="highlighter-rouge">MonadError</code> with this approach.</p>

<p>Another approach, maybe more obvious to some, might be to require the type constructor to take two arguments, one for the value and one for the error type.
Let’s see if we can define <code class="highlighter-rouge">raiseError</code> on top of it:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">raiseError</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span>

  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This looks pretty similar to what we already have, though now we have the guarantee that our type doesn’t actually “hide” the error-type somewhere.
Next up is <code class="highlighter-rouge">handleErrorWith</code>. Ideally after we handled the error we should again get back a type that signals that it doesn’t have any errors. 
We can do exactly that by choosing an unhabited type like <code class="highlighter-rouge">Nothing</code> as our error-type:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="k">def</span> <span class="n">handleErrorWith</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">Nothing</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Nothing</span>, <span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And this approach works as well, however now we’ve forced the two type parameter shape onto implementors. This <code class="highlighter-rouge">MonadBlunder</code> has the following kind <code class="highlighter-rouge">(* -&gt; * -&gt; *) -&gt; *</code>.
This means we can very easily define instances for types with two type parameters like <code class="highlighter-rouge">Either</code>.
However, one issue might be that it’s much easier to fit a type with two type parameters onto a type class that expects a single type constructor <code class="highlighter-rouge">(* -&gt; *)</code> than to do it the other way around.</p>

<p>For example try to implement the above <code class="highlighter-rouge">MonadBlunder[F[_, _]]</code> for the standard <code class="highlighter-rouge">cats.effect.IO</code>.
It’s not going to be simple, whereas with the first encoding we can easily encode both <code class="highlighter-rouge">Either</code> and <code class="highlighter-rouge">IO</code>. For this reason, I will continue this article with the first encoding using the two different type constructors.</p>

<p>Next we’re going to look at laws we can define to make sense of the behaviour we want.
The first two laws should be fairly obvious. 
If we <code class="highlighter-rouge">flatMap</code> over a value created by <code class="highlighter-rouge">raiseError</code> it shouldn’t propogate:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">raiseErrorStops</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="n">F</span><span class="o">.</span><span class="n">raiseError</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="o">).</span><span class="n">flatMap</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">===</span> <span class="n">F</span><span class="o">.</span><span class="n">raiseError</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="o">)</span>
</code></pre></div></div>

<p>Next we’re going to formulate a law that states, that raising an error and then immediatly handling it with a given function should be equivalent to just calling that function on the error value:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">raiseErrorHandleErrorWith</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="n">raiseError</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="o">).</span><span class="n">handleErrorWith</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">===</span> <span class="n">f</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
</code></pre></div></div>

<p>Another law could state that handling errors for a pure value lifted into the <code class="highlighter-rouge">F</code> context does nothing and is equal to the pure value in the <code class="highlighter-rouge">G</code> context:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">handleErrorPureIsPure</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="n">a</span><span class="o">.</span><span class="n">pure</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">handleErrorWith</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">===</span> <span class="n">a</span><span class="o">.</span><span class="n">pure</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span>
</code></pre></div></div>

<p>Those should be good for now, but we’ll be able to find more when we add more derived functions to our type class.
Also note that none of the laws are set in stone, these are just the ones I came up with for now, it’s completely possible that we’ll need to revise these in the future.</p>

<p>Now let’s focus on adding extra functions to our type class. <code class="highlighter-rouge">MonadError</code> offer us a bunch of derived methods that can be really useful. For most of those however we need access to methods like <code class="highlighter-rouge">flatMap</code> for both <code class="highlighter-rouge">F</code> and <code class="highlighter-rouge">G</code>, so before we figure out derived combinators, let’s revisit how exactly we define the type class.</p>

<p>The easiest would be to give both <code class="highlighter-rouge">F</code> and <code class="highlighter-rouge">G</code> a <code class="highlighter-rouge">Monad</code> constraint and move on. 
But then we’d have two type classes that both define a <code class="highlighter-rouge">raiseError</code> function extends <code class="highlighter-rouge">Monad</code>, and we wouldn’t be able to use them together, since that would cause ambiguities and as I’ve said before, the functions on <code class="highlighter-rouge">MonadError</code> are useful in some cases.</p>

<p>Instead, since I don’t really like duplication and the fact that we’re not going to deprecate <code class="highlighter-rouge">MonadError</code> overnight, I decided to extend <code class="highlighter-rouge">MonadBlunder</code> from <code class="highlighter-rouge">MonadError</code> for the <code class="highlighter-rouge">F</code> type, to get access to the <code class="highlighter-rouge">raiseError</code> function.
If <code class="highlighter-rouge">raiseError</code> and <code class="highlighter-rouge">handleErrorWith</code> were instead separated into separate type classes (as is currently the case in the PureScript prelude), we could extend only the <code class="highlighter-rouge">raiseError</code> part.
This also allows us to define laws that our counterparts of functions like <code class="highlighter-rouge">attempt</code> and <code class="highlighter-rouge">ensure</code> are consistent with the ones defined on <code class="highlighter-rouge">MonadError</code>.
So the type signature now looks like this (expressed in Haskell, since it’s easier on the eyes):</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="p">(</span><span class="kt">MonadError</span> <span class="n">f</span> <span class="n">e</span><span class="p">,</span> <span class="kt">Monad</span> <span class="n">g</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">MonadBlunder</span> <span class="n">f</span> <span class="n">g</span> <span class="n">e</span> <span class="o">|</span><span class="err"> </span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="n">g</span> <span class="kr">where</span>
  <span class="o">...</span>
</code></pre></div></div>

<p>In Scala, we can’t express this as nicely, so we’re going to have to use something close to the <code class="highlighter-rouge">cats-mtl</code> encoding:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">monadErrorF</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span>
  <span class="k">val</span> <span class="n">monadG</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span>
  
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now since this means that any instance of <code class="highlighter-rouge">MonadBlunder</code> will also have an instance of <code class="highlighter-rouge">MonadError</code> on <code class="highlighter-rouge">F</code>, we might want to rename the functions we’ve got so far.
Here’s a complete definition of what we’ve come up with with <code class="highlighter-rouge">raiseError</code> removed and <code class="highlighter-rouge">handleErrorWith</code> renamed to <code class="highlighter-rouge">handleBlunderWith</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">monadErrorF</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span>
  <span class="k">val</span> <span class="n">monadG</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">handleBlunderWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now let us go back to defining more derived functions for <code class="highlighter-rouge">MonadBlunder</code>.
The easiest probably being <code class="highlighter-rouge">handleError</code>, so let’s see if we can come up with a good alternative:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="k">def</span> <span class="n">handleBlunder</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> 
    <span class="n">handleBlunderWith</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span> <span class="n">andThen</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">pure</span><span class="o">[</span><span class="kt">G</span><span class="o">]))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This one is almost exactly like <code class="highlighter-rouge">handleBlunderWith</code>, but takes a function from <code class="highlighter-rouge">E</code> to <code class="highlighter-rouge">A</code> instead of to <code class="highlighter-rouge">G[A]</code>. We can easily reuse <code class="highlighter-rouge">handleBlunderWith</code> by using <code class="highlighter-rouge">pure</code> to go back to <code class="highlighter-rouge">E =&gt; G[A]</code>.</p>

<p>Next another function that’s really useful is <code class="highlighter-rouge">attempt</code>.
Our alternative, let’s call it <code class="highlighter-rouge">endeavor</code> for now, should return a value in <code class="highlighter-rouge">G</code> instead, which doesn’t have a <code class="highlighter-rouge">MonadError</code> instance and therefore can not make any additional calls to <code class="highlighter-rouge">endeavor</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="k">def</span> <span class="n">endeavor</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
    <span class="n">handleBlunder</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="k">_</span><span class="o">)))(</span><span class="nc">Left</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The implementation is fairly straightforward as well, we just handle all the errors by lifting them into the left side of an <code class="highlighter-rouge">Either</code> and map successful values to the right side of <code class="highlighter-rouge">Either</code>.</p>

<p>Next, let’s look at the dual to <code class="highlighter-rouge">attempt</code>, called <code class="highlighter-rouge">rethrow</code> in Cats. 
For <code class="highlighter-rouge">MonadError</code> it turns an <code class="highlighter-rouge">F[Either[E, A]]</code> back into an <code class="highlighter-rouge">F</code>, but we’re going to use our unexceptional type again:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="k">def</span> <span class="n">absolve</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>But looking at this signature, we quickly realize that we need a way to get back to <code class="highlighter-rouge">F[A]</code> from <code class="highlighter-rouge">G[A]</code>.
So we’re going to add another function to our minimal definition:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">monadErrorF</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span>
  <span class="k">val</span> <span class="n">monadG</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">handleBlunderWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">accept</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ga</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

<span class="o">}</span>
</code></pre></div></div>

<p>This function <code class="highlighter-rouge">accept</code>, allows us to lift any value without errors into a context where errors might be present.</p>

<p>We can now formulate a law that values in <code class="highlighter-rouge">G</code> never stop propagating, so <code class="highlighter-rouge">flatMap</code> should always work, we do this by specifying that calling <code class="highlighter-rouge">handleBlunder</code> after calling <code class="highlighter-rouge">accept</code> on any <code class="highlighter-rouge">G[A]</code>, is never going to actually change the value:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">gNeverHasErrors</span><span class="o">(</span><span class="n">ga</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="n">accept</span><span class="o">(</span><span class="n">ga</span><span class="o">).</span><span class="n">handleBlunder</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">===</span> <span class="n">ga</span>
</code></pre></div></div>

<p>Now we can go back to implementing the <code class="highlighter-rouge">absolve</code> function:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">absolve</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">gea</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">accept</span><span class="o">(</span><span class="n">gea</span><span class="o">).</span><span class="n">flatMap</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="n">raiseError</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="k">_</span><span class="o">.</span><span class="n">pure</span><span class="o">[</span><span class="kt">F</span><span class="o">]))</span>
</code></pre></div></div>

<p>Now that we’ve got the equivalent of both <code class="highlighter-rouge">attempt</code> and <code class="highlighter-rouge">rethrow</code>, let’s add a law that states that the two should cancel each other out:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">endeavorAbsolve</span><span class="o">(</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="n">absolve</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">endeavor</span><span class="o">)</span> <span class="o">===</span> <span class="n">fa</span>
</code></pre></div></div>

<p>We can also add laws so that <code class="highlighter-rouge">handleBlunder</code> and <code class="highlighter-rouge">endeavor</code> are consistent with their counterparts now that we have <code class="highlighter-rouge">accept</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">deriveHandleError</span><span class="o">(</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="n">accept</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">handleBlunder</span><span class="o">(</span><span class="n">f</span><span class="o">))</span> <span class="o">===</span> <span class="n">fa</span><span class="o">.</span><span class="n">handleError</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>

<span class="k">def</span> <span class="n">deriveAttempt</span><span class="o">(</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="n">accept</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">endeavor</span><span class="o">)</span> <span class="o">===</span> <span class="n">fa</span><span class="o">.</span><span class="n">attempt</span>
</code></pre></div></div>

<p>One nice thing about <code class="highlighter-rouge">attempt</code>, is that it’s really easy to add a derivative combinator that doesn’t go to <code class="highlighter-rouge">F[Either[E, A]]</code>, but to the isomorphic monad transformer <code class="highlighter-rouge">EitherT[F, E, A]</code>.
We can do the exact same thing with <code class="highlighter-rouge">endeavor</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">endeavorT</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">EitherT</span><span class="o">(</span><span class="n">endeavor</span><span class="o">(</span><span class="n">fa</span><span class="o">))</span>
</code></pre></div></div>

<p>One last combinator I’d like to “port” from <code class="highlighter-rouge">MonadError</code> is the <code class="highlighter-rouge">ensureOr</code> function.
<code class="highlighter-rouge">ensureOr</code> turns a successful value into an error if it does not satisfy a given predicate.
We’re going to name the counterpart <code class="highlighter-rouge">assureOr</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">assureOr</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ga</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">error</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">E</span><span class="o">)(</span><span class="n">predicate</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">accept</span><span class="o">(</span><span class="n">ga</span><span class="o">).</span><span class="n">flatMap</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">predicate</span><span class="o">(</span><span class="n">a</span><span class="o">))</span> <span class="n">a</span><span class="o">.</span><span class="n">pure</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">else</span> <span class="n">raiseError</span><span class="o">(</span><span class="n">error</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
  <span class="o">)</span>
</code></pre></div></div>

<p>This plays nicely with the rest of our combinators and we can again add a law that dictates it must be consistent with <code class="highlighter-rouge">ensureOr</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">deriveEnsureOr</span><span class="o">(</span><span class="n">ga</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">error</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">E</span><span class="o">)(</span><span class="n">predicate</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="n">ensureOr</span><span class="o">(</span><span class="n">accept</span><span class="o">(</span><span class="n">ga</span><span class="o">))(</span><span class="n">error</span><span class="o">)(</span><span class="n">predicate</span><span class="o">)</span> <span class="o">===</span> <span class="n">assureOr</span><span class="o">(</span><span class="n">ga</span><span class="o">)(</span><span class="n">error</span><span class="o">)(</span><span class="n">predicate</span><span class="o">)</span>
</code></pre></div></div>

<p>Now we have a great base to work with laws that should guarantee principled and sensible behaviour.
Next we’ll actually start defining some instances for our type class.</p>

<p>The easiest definitions are for <code class="highlighter-rouge">Either</code> and <code class="highlighter-rouge">Option</code>, though I’m not going to cover both, as the instances for <code class="highlighter-rouge">Option</code> can simply be derived by <code class="highlighter-rouge">Either[Unit, A]</code>and I’m going to link to the code at the end.
For <code class="highlighter-rouge">Either[E, A]</code>, when we handle all errors of type <code class="highlighter-rouge">E</code>, all we end up with is <code class="highlighter-rouge">A</code>, so the corresponding <code class="highlighter-rouge">G</code> type for our instance should be <code class="highlighter-rouge">Id</code>.
That leaves us with the following definition:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">monadBlunderEither</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span><span class="k">:</span> <span class="kt">MonadBlunder</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">Id</span>, <span class="kt">E</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">Id</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">monadErrorF</span> <span class="k">=</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span>
    <span class="k">val</span> <span class="n">monadG</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">Id</span><span class="o">]</span>

    <span class="k">def</span> <span class="n">handleBlunderWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">fa</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
      <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="n">accept</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ga</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Right</span><span class="o">(</span><span class="n">ga</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Fairly straightforward, as <code class="highlighter-rouge">Id[A]</code> is just <code class="highlighter-rouge">A</code>, but with this instance we can already see a small part of the power we gain over <code class="highlighter-rouge">MonadError</code>.
When we handle errors with <code class="highlighter-rouge">handleBlunder</code>, we’re no longer “stuck” inside the <code class="highlighter-rouge">Either</code> Monad, but instead have a guarantee that our value is free of errors.
Sometimes it’ll make sense to stay inside <code class="highlighter-rouge">Either</code>, but we can easily get back into <code class="highlighter-rouge">Either</code>, so we have full control over what we want to do.</p>

<p>Next up, we’ll look at <code class="highlighter-rouge">IO</code> and the type that inspired this whole blog post <code class="highlighter-rouge">UIO</code>.
<code class="highlighter-rouge">UIO</code> is equivalent to an <code class="highlighter-rouge">IO</code> type where all errors are handled and is short for “unexceptional IO”.
<code class="highlighter-rouge">UIO</code> currently lives inside my own <code class="highlighter-rouge">cats-uio</code> library, but if things go well, we might see it inside <code class="highlighter-rouge">cats-effect</code> eventually. This would also work for <code class="highlighter-rouge">IO</code> types who use two type parameters <code class="highlighter-rouge">IO[E, A]</code> where the first represents the error type and the second the actual value. There you’d choose <code class="highlighter-rouge">IO[E, A]</code> as the <code class="highlighter-rouge">F</code> type and <code class="highlighter-rouge">IO[Nothing, A]</code> as the <code class="highlighter-rouge">G</code> type. <code class="highlighter-rouge">IO[Nothing, A]</code> there is equivalent to <code class="highlighter-rouge">UIO[A]</code>.</p>

<p>As one might expect, you can not simply go from <code class="highlighter-rouge">IO[A]</code> to <code class="highlighter-rouge">UIO[A]</code>, but we’ll need to go from <code class="highlighter-rouge">IO[A]</code> to <code class="highlighter-rouge">UIO[Either[E, A]]</code> instead, which if you look at it, is exactly the definition of <code class="highlighter-rouge">endeavor</code>.
Now let’s have a look at how the <code class="highlighter-rouge">MonadBlunder</code> instance for <code class="highlighter-rouge">IO</code> and <code class="highlighter-rouge">UIO</code> looks:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="n">monadBlunderIO</span><span class="k">:</span> <span class="kt">MonadBlunder</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">UIO</span>, <span class="kt">Throwable</span><span class="o">]</span> <span class="k">=</span> 
  <span class="k">new</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">UIO</span>, <span class="kt">Throwable</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">monadErrorF</span> <span class="k">=</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Throwable</span><span class="o">]</span>
    <span class="k">val</span> <span class="n">monadG</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">UIO</span><span class="o">]</span>

    <span class="k">def</span> <span class="n">handleBlunderWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Throwable</span> <span class="o">=&gt;</span> <span class="nc">UIO</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">UIO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">UIO</span><span class="o">.</span><span class="n">unsafeFromIO</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">handleErrorWith</span><span class="o">(</span><span class="n">f</span> <span class="n">andThen</span> <span class="n">accept</span><span class="o">))</span>

    <span class="k">def</span> <span class="n">accept</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ga</span><span class="k">:</span> <span class="kt">UIO</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">UIO</span><span class="o">.</span><span class="n">runUIO</span><span class="o">(</span><span class="n">ga</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>And voila! We’ve got a fully working implementation that will allow us to switch between these two types whenever we have a guarantee that all errors are handled.
This makes a lot of things much simpler.
For example, if one wants to use <code class="highlighter-rouge">bracket</code> with <code class="highlighter-rouge">UIO</code>, you just need to <code class="highlighter-rouge">flatMap</code> to the finalizer, as <code class="highlighter-rouge">flatMap</code> is always guaranteed to not short-circuit.</p>

<p>We can also define instances for <code class="highlighter-rouge">EitherT</code> and <code class="highlighter-rouge">OptionT</code> (being isomorphic to <code class="highlighter-rouge">EitherT[F, Unit, A]</code>), where the corresponding unexceptional type is just the outer <code class="highlighter-rouge">F</code>, so <code class="highlighter-rouge">endeavor</code> is just a call to <code class="highlighter-rouge">.value</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">catsEndeavorForEitherT</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">E</span><span class="o">]</span><span class="k">:</span> <span class="kt">MonadBlunder</span><span class="o">[</span><span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">monadErrorF</span> <span class="k">=</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span>
    <span class="k">val</span> <span class="n">monadG</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">endeavor</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
      <span class="n">fa</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="n">handleBlunderWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
      <span class="n">fa</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">pure</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
      <span class="o">}</span>

    <span class="k">def</span> <span class="n">accept</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ga</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">EitherT</span><span class="o">.</span><span class="n">liftF</span><span class="o">(</span><span class="n">ga</span><span class="o">)</span>

  <span class="o">}</span>
</code></pre></div></div>

<p>Finally, it’s also possible to create instances for other standard monad transformers like <code class="highlighter-rouge">WriterT</code>, <code class="highlighter-rouge">ReaderT</code> or <code class="highlighter-rouge">StateT</code> as long as their underlying monads themselves have instances for <code class="highlighter-rouge">MonadBlunder</code>, as is typical in mtl.
As their implementations are very similar we’ll only show the <code class="highlighter-rouge">StateT</code> transformer instance:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">catsEndeavorForStateT</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">S</span>, <span class="kt">E</span><span class="o">]</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">M</span><span class="k">:</span> <span class="kt">MonadBlunder</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">MonadBlunder</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">StateT</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">S</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">StateT</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">S</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">implicit</span> <span class="k">val</span> <span class="n">F</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span> <span class="k">=</span> <span class="n">M</span><span class="o">.</span><span class="n">monadErrorF</span>
      <span class="k">implicit</span> <span class="k">val</span> <span class="n">G</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span> <span class="k">=</span> <span class="n">M</span><span class="o">.</span><span class="n">monadG</span>

      <span class="k">val</span> <span class="n">monadErrorF</span> <span class="k">=</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span>
      <span class="k">val</span> <span class="n">monadG</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">S</span>, <span class="kt">?</span><span class="o">]]</span>

      <span class="k">def</span> <span class="n">accept</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ga</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">ga</span><span class="o">.</span><span class="n">mapK</span><span class="o">(</span><span class="k">new</span> <span class="o">(</span><span class="n">G</span> <span class="o">~&gt;</span> <span class="n">F</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">ga</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">M</span><span class="o">.</span><span class="n">accept</span><span class="o">(</span><span class="n">ga</span><span class="o">)</span>
      <span class="o">})</span>

      <span class="k">def</span> <span class="n">handleBlunderWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
        <span class="nc">IndexedStateT</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">M</span><span class="o">.</span><span class="n">handleBlunderWith</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">s</span><span class="o">))(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">e</span><span class="o">).</span><span class="n">run</span><span class="o">(</span><span class="n">s</span><span class="o">)))</span>

    <span class="o">}</span>
</code></pre></div></div>

<p>In practice this means we can call <code class="highlighter-rouge">handleBlunderWith</code> on things like <code class="highlighter-rouge">StateT[IO, S, A]</code> and get back a <code class="highlighter-rouge">StateT[UIO, S, A]</code>. Pretty neat!
You can also create instances for pretty much any <code class="highlighter-rouge">MonadError</code> using <code class="highlighter-rouge">Unexceptional</code>, e.g.: <code class="highlighter-rouge">MonadBlunder[Future, Unexceptional[Future, ?], Throwable]</code>. The <code class="highlighter-rouge">Unexceptional</code> type is designed to turn any erroring type into one that doesn’t throw errors by catching them with <code class="highlighter-rouge">attempt</code>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>In this article, I’ve tried to present the argument that <code class="highlighter-rouge">MonadError</code> is insufficient for principled error handling.
We also tried to build a solution that deals with the shortcomings described earlier.
Thereby it seeks not to replace, but to expand on <code class="highlighter-rouge">MonadError</code> to get a great variety of error handling capabilities.
I believe the <code class="highlighter-rouge">MonadBlunder</code> type class, or whatever it will be renamed to, can be a great addition not just to the Cats community, but to the functional community at large, especially as it’s much easier to express in languages like <code class="highlighter-rouge">PureScript</code> and <code class="highlighter-rouge">Haskell</code>.</p>

<p>For now, all of the code lives inside the <a href="https://github.com/LukaJCB/cats-uio">cats-uio repo</a>, which houses the <code class="highlighter-rouge">MonadBlunder</code> type class the <code class="highlighter-rouge">UIO</code> data type and the <code class="highlighter-rouge">Unexceptional</code> data type.
I hope that this blog post gave a motivation as to why I created the library and why it might be nice to adopt some of its features into the core typelevel libraries.</p>

<p>Note again, that none of this is final or set in stone and before it arrives anywhere might still change a lot, especially in regards to naming (which I’m not really happy with at the moment), so if you have any feedback of any sorts, please do chime in! Would love to hear your thoughts and thank you for reading this far!</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Fri, 13 Apr 2018 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2018/04/13/rethinking-monaderror.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2018/04/13/rethinking-monaderror.html</guid>
      </item>
    
      <item>
        <title>Optimizing Tagless Final – Saying farewell to Free</title>
        
          <dc:creator>lukajcb</dc:creator>
                
        <description><![CDATA[<p>The Tagless Final encoding has gained some steam recently, with some people hailing 2017 as the year of Tagless Final.
Being conceptually similar to the Free Monad, different comparisons have been brought up and the one trade-off that always comes up is the lack or the difficulty of inspection of tagless final programs and in fact, I couldn’t find a single example on the web.
This seems to make sense, as programs in the tagless final encoding aren’t values, like programs expressed in terms of free structures. 
However, in this blog post, I’d like to dispell the myth that inspecting and optimizing tagless final programs is more difficult than using <code class="highlighter-rouge">Free</code>.</p>

<p>Without further ado, let’s get into it, starting with our example algebra, a very simple key-value store:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span>
  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>To get the easiest example out of the way, here’s how to achieve parallelism in a tagless final program:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats._</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">def</span> <span class="n">program</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">FlatMap</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="n">K</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">M</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">P</span><span class="k">:</span> <span class="kt">Parallel</span><span class="o">[</span><span class="kt">M</span>, <span class="kt">F</span><span class="o">])</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">K</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="s">"A"</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
    <span class="n">x</span> <span class="k">&lt;-</span> <span class="o">(</span><span class="n">K</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"B"</span><span class="o">),</span> <span class="n">K</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"C"</span><span class="o">)).</span><span class="n">parMapN</span><span class="o">(</span><span class="k">_</span> <span class="o">|+|</span> <span class="k">_</span><span class="o">)</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">K</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="s">"X"</span><span class="o">,</span> <span class="n">x</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="s">"-"</span><span class="o">))</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">x</span>
</code></pre></div></div>

<p>This programs makes use of the <code class="highlighter-rouge">cats.Parallel</code> type class, that allows us to make use of the <code class="highlighter-rouge">parMapN</code> combinator to use independent computations with a related <code class="highlighter-rouge">Applicative</code> type. This is already much simpler than doing the same thing with <code class="highlighter-rouge">Free</code> and <code class="highlighter-rouge">FreeApplicative</code>. For more info on <code class="highlighter-rouge">Parallel</code> check out the cats docs <a href="https://typelevel.org/cats/typeclasses/parallel.html">here</a>.</p>

<p>However this is kind of like cheating, we’re not really inspecting the structure of our program at all, so let’s look at an example where we actually have access to the structure to do optimizations with.</p>

<p>Let’s say we have the following program:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Apply</span><span class="o">](</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
    <span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"Cats"</span><span class="o">),</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"Dogs"</span><span class="o">),</span> <span class="n">F</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="s">"Mice"</span><span class="o">,</span> <span class="s">"42"</span><span class="o">),</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"Cats"</span><span class="o">))</span>
      <span class="o">.</span><span class="n">mapN</span><span class="o">((</span><span class="n">f</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">).</span><span class="n">flatten</span><span class="o">)</span>
</code></pre></div></div>

<p>Not a very exciting program, but it has some definite optimization potential.
Right now, if our KVStore implementation is an asynchronous one with a network boundary, our program will make 4 network requests sequentially if interpreted with the standard <code class="highlighter-rouge">Apply</code> instance of something like <code class="highlighter-rouge">cats.effect.IO</code>.
We also have a duplicate request with the <code class="highlighter-rouge">"Cats"</code>-key.</p>

<p>So let’s look at what we could potentially do about this.
The first thing we should do, is extract the static information.
The easiest way to do so, is to interpret it into something we can use using a <code class="highlighter-rouge">Monoid</code>.
This is essentially equivalent to the <code class="highlighter-rouge">analyze</code> function commonly found on <code class="highlighter-rouge">FreeApplicative</code>.</p>

<p>Getting this done, is actually quite simple, as we can use <code class="highlighter-rouge">cats.Const</code> as our <code class="highlighter-rouge">Applicative</code> data type, whenever the lefthand side of <code class="highlighter-rouge">Const</code> is a <code class="highlighter-rouge">Monoid</code>. 
I.e. if <code class="highlighter-rouge">M</code> has a <code class="highlighter-rouge">Monoid</code> instance, <code class="highlighter-rouge">Const[M, A]</code> has an <code class="highlighter-rouge">Applicative</code> instance.
You can read more about <code class="highlighter-rouge">Const</code> <a href="https://typelevel.org/cats/datatypes/const.html">here</a>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">analysisInterpreter</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">Const</span><span class="o">[(</span><span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">])</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">Const</span><span class="o">[(</span><span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">])</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Const</span><span class="o">((</span><span class="nc">Set</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">))</span>
    <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Const</span><span class="o">((</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="n">key</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">)))</span>
  <span class="o">}</span>

<span class="n">program</span><span class="o">(</span><span class="n">analysisInterpreter</span><span class="o">).</span><span class="n">getConst</span>
<span class="c1">// res0: (Set[String], Map[String,String]) = (Set(Cats, Dogs),Map(Mice -&gt; 42))
</span>
</code></pre></div></div>

<p>By using a Tuple of <code class="highlighter-rouge">Set</code> and <code class="highlighter-rouge">Map</code> as our <code class="highlighter-rouge">Monoid</code>, we now get all the unique keys for our <code class="highlighter-rouge">get</code> and <code class="highlighter-rouge">put</code> operations.
Next, we can use this information to recreate our program in an optimized way.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">optimizedProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">](</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="o">(</span><span class="n">gets</span><span class="o">,</span> <span class="n">puts</span><span class="o">)</span> <span class="k">=</span> <span class="n">program</span><span class="o">(</span><span class="n">analysisInterpreter</span><span class="o">).</span><span class="n">getConst</span>

  <span class="n">puts</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">traverse</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="o">}</span> 
    <span class="o">*&gt;</span> <span class="n">gets</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">traverse</span><span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">flatten</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And we got our first very simple optimization.
It’s not much, but we can imagine the power of this technique.
For example, if we were using something like <code class="highlighter-rouge">GraphQL</code>, we could sum all of our <code class="highlighter-rouge">get</code> requests into one large request, so only one network roundtrip is made.
We could imagine similar things for other use cases, e.g. if we’re querying a bunch of team members that all belong to the same team, it might make sense to just make one request to all the team’s members instead of requesting them all individually.</p>

<p>Other more complex optimizations could involve writing a new interpreter with the information we gained from our static analysis.
One could also precompute some of the computations and then create a new interpreter with those computations in mind.</p>

<p>Embedding our Applicative program inside a larger monadic program is also trivial:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Apply</span><span class="o">](</span><span class="n">mouse</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"Cats"</span><span class="o">),</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"Dogs"</span><span class="o">),</span> <span class="n">F</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="s">"Mice"</span><span class="o">,</span> <span class="n">mouse</span><span class="o">),</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"Cats"</span><span class="o">))</span>
    <span class="o">.</span><span class="n">mapN</span><span class="o">((</span><span class="n">f</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">).</span><span class="n">flatten</span><span class="o">)</span>

<span class="k">def</span> <span class="n">optimizedProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">](</span><span class="n">mouse</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="o">(</span><span class="n">gets</span><span class="o">,</span> <span class="n">puts</span><span class="o">)</span> <span class="k">=</span> <span class="n">program</span><span class="o">(</span><span class="n">mouse</span><span class="o">)(</span><span class="n">analysisInterpreter</span><span class="o">).</span><span class="n">getConst</span>

  <span class="n">puts</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">traverse</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="o">}</span> 
    <span class="o">*&gt;</span> <span class="n">gets</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">traverse</span><span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">flatten</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">monadicProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">](</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">mouse</span> <span class="k">&lt;-</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"Mice"</span><span class="o">)</span>
  <span class="n">list</span> <span class="k">&lt;-</span> <span class="n">optimizedProgram</span><span class="o">(</span><span class="n">mouse</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="s">"64"</span><span class="o">))(</span><span class="n">F</span><span class="o">)</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">F</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="s">"Birds"</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="n">headOption</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="s">"128"</span><span class="o">))</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>Here we refactor our <code class="highlighter-rouge">optimizedProgram</code> to take an extra parameter <code class="highlighter-rouge">mouse</code>. Then in our larger <code class="highlighter-rouge">monadicProgram</code>, we perform a <code class="highlighter-rouge">get</code> operation and then apply its result to <code class="highlighter-rouge">optimizedProgram</code>.</p>

<p>So now we have a way to optimize our one specific program, next we should see if we can introduce some abstraction.
Sadly Scala lacks Rank-N types, which makes this a bit difficult as we’ll see.</p>

<p>First we’ll have to look at the shape of a generic program, they usually are functions from an interpreter <code class="highlighter-rouge">Algebra[F]</code> to an expression inside the type constructor <code class="highlighter-rouge">F</code>, such as <code class="highlighter-rouge">F[A]</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Program</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>The problem of Rank-N types becomes apparent when we want to write a function where we interpret our program with two different interpreters, as we did before when interpreting into <code class="highlighter-rouge">Const</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">optimize</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span>, <span class="kt">A</span>, <span class="kt">M:</span> <span class="kt">Monoid</span><span class="o">]</span>
  <span class="o">(</span><span class="n">program</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
  <span class="o">(</span><span class="n">extract</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">Const</span><span class="o">[</span><span class="kt">M</span>, <span class="kt">?</span><span class="o">]])</span>
  <span class="o">(</span><span class="n">restructure</span><span class="k">:</span> <span class="kt">M</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="n">interp</span> <span class="k">=&gt;</span>

    <span class="k">val</span> <span class="n">m</span> <span class="k">=</span> <span class="n">program</span><span class="o">(</span><span class="n">extract</span><span class="o">).</span><span class="n">getConst</span> <span class="c1">// error: type mismatch;
</span>    <span class="c1">// found   : extract.type (with underlying type Alg[[β$0$]cats.data.Const[M,β$0$]])
</span>    <span class="c1">// required: Alg[F]
</span>
    <span class="n">restructure</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>
<p>So, because of the lack of Rank-N types, this simple definition for our program is not enough to say that our program works for ALL type constructors <code class="highlighter-rouge">F[_]: Applicative</code>.</p>

<p>Fortunately there is a workaround, albeit requiring a bit more boilerplate:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Program</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">](</span><span class="n">interpreter</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">optimize</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span>, <span class="kt">A</span>, <span class="kt">M:</span> <span class="kt">Monoid</span><span class="o">]</span>
  <span class="o">(</span><span class="n">program</span><span class="k">:</span> <span class="kt">Program</span><span class="o">[</span><span class="kt">Alg</span>, <span class="kt">A</span><span class="o">])</span>
  <span class="o">(</span><span class="n">extract</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">Const</span><span class="o">[</span><span class="kt">M</span>, <span class="kt">?</span><span class="o">]])</span>
  <span class="o">(</span><span class="n">restructure</span><span class="k">:</span> <span class="kt">M</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="n">interp</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">m</span> <span class="k">=</span> <span class="n">program</span><span class="o">(</span><span class="n">extract</span><span class="o">).</span><span class="n">getConst</span>

    <span class="n">restructure</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>And now it should compile without a problem.
Now we should be able to express our original optimization with this new generic approach:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Apply</span><span class="o">](</span><span class="n">mouse</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"Cats"</span><span class="o">),</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"Dogs"</span><span class="o">),</span> <span class="n">F</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="s">"Mice"</span><span class="o">,</span> <span class="n">mouse</span><span class="o">),</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"Cats"</span><span class="o">))</span>
    <span class="o">.</span><span class="n">mapN</span><span class="o">((</span><span class="n">f</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">).</span><span class="n">flatten</span><span class="o">)</span>

<span class="k">def</span> <span class="n">wrappedProgram</span><span class="o">(</span><span class="n">mouse</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Program</span><span class="o">[</span><span class="kt">KVStore</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">](</span><span class="n">alg</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="n">program</span><span class="o">(</span><span class="n">mouse</span><span class="o">)(</span><span class="n">alg</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">optimizedProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">](</span><span class="n">mouse</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> 
  <span class="n">optimize</span><span class="o">(</span><span class="n">wrappedProgram</span><span class="o">(</span><span class="n">mouse</span><span class="o">))(</span><span class="n">analysisInterpreter</span><span class="o">)</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">gets</span><span class="o">,</span> <span class="n">puts</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">puts</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">traverse</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="o">}</span> <span class="o">*&gt;</span> <span class="n">gets</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">traverse</span><span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>So far so good, we’ve managed to write a function to generically optimize tagless final programs.
However, one of the main advantages of tagless final is that implementation and logic should be separate concerns.
With what we have right now, we’re violating the separation, by mixing the optimization part with the program logic part.
Our optimization should be handled by the interpreter, just as the sequencing of individual steps of a monadic program is the job of the target <code class="highlighter-rouge">Monad</code> instance.</p>

<p>One way to go forward, is to create a typeclass that requires certain algebras to be optimizable.
This typeclass could be written using the generic function we wrote before, so let’s see what we can come up with:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Optimizer</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">M</span>

  <span class="k">def</span> <span class="n">monoidM</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">M</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">monadF</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">extract</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">Const</span><span class="o">[</span><span class="kt">M</span>, <span class="kt">?</span><span class="o">]]</span>
  <span class="k">def</span> <span class="n">rebuild</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">M</span><span class="o">,</span> <span class="n">interpreter</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span>

  <span class="k">def</span> <span class="n">optimize</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="kt">Program</span><span class="o">[</span><span class="kt">Alg</span>, <span class="kt">Applicative</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="n">interpreter</span> <span class="k">=&gt;</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">M</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">M</span><span class="o">]</span> <span class="k">=</span> <span class="n">monoidM</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="n">monadF</span>

    <span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">M</span> <span class="o">=</span> <span class="n">p</span><span class="o">(</span><span class="n">extract</span><span class="o">).</span><span class="n">getConst</span>

    <span class="n">rebuild</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">interpreter</span><span class="o">).</span><span class="n">flatMap</span><span class="o">(</span><span class="n">interp</span> <span class="k">=&gt;</span> <span class="n">p</span><span class="o">(</span><span class="n">interp</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This might look a bit daunting at first, but we’ll go through it bit by bit.
First we define our type class <code class="highlighter-rouge">Optimizer</code> parameterized by an algebra <code class="highlighter-rouge">Alg[_[_]]</code> and a type constructor <code class="highlighter-rouge">F[_]</code>.
This means we can define different optimizations for different algebras and different target types.
For example, we might want a different optimization for a production <code class="highlighter-rouge">Optimizer[KVStore, EitherT[Task, E, ?]]</code> and a testing <code class="highlighter-rouge">Optimizer[KVStore, Id]</code>.
Next, for our interpreter we need a <code class="highlighter-rouge">Monoid M</code> for our static analysis, however we don’t to parameterize our <code class="highlighter-rouge">Optimizer</code> with an extra type parameter, since the actual type of <code class="highlighter-rouge">M</code> isn’t necessary for the API, so we use an abstract type member instead.</p>

<p>Next we need actual <code class="highlighter-rouge">Monoid</code> and <code class="highlighter-rouge">Monad</code> instances for <code class="highlighter-rouge">F[_]</code> and <code class="highlighter-rouge">M</code> respectively.
The other two functions should seem familiar, the <code class="highlighter-rouge">extract</code> function defines an interpreter to get an <code class="highlighter-rouge">M</code> out of our program.
The <code class="highlighter-rouge">rebuild</code> function takes that value of <code class="highlighter-rouge">M</code> and the interpreter and produces an <code class="highlighter-rouge">F[Alg[F]]</code>, which can be understood as an <code class="highlighter-rouge">F</code> of an interpreter.
This means that we can statically analyze a program and then use the result of that to create a new optimized interpreter and this is exactly what the <code class="highlighter-rouge">optimize</code> function does.
This is also why we needed the <code class="highlighter-rouge">Monad</code> constraint on <code class="highlighter-rouge">F</code>, we could also get away with returning just a new interpreter <code class="highlighter-rouge">Alg[F]</code> from the <code class="highlighter-rouge">rebuild</code> method and get away with an <code class="highlighter-rouge">Applicative</code> constraint, but we can do more different things this way.</p>

<p>We’ll also define some quick syntax sugar for this type class to make using it a tiny bit more ergonomic.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">class</span> <span class="nc">OptimizerOps</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">A</span><span class="o">](</span><span class="k">val</span> <span class="n">value</span><span class="k">:</span> <span class="kt">Program</span><span class="o">[</span><span class="kt">Alg</span>, <span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">AnyVal</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">optimize</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">](</span><span class="n">interp</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">O</span><span class="k">:</span> <span class="kt">Optimizer</span><span class="o">[</span><span class="kt">Alg</span>, <span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">O</span><span class="o">.</span><span class="n">optimize</span><span class="o">(</span><span class="n">value</span><span class="o">)(</span><span class="n">interp</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Let’s see what our program would look like with this new functionality:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">monadicProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">](</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">O</span><span class="k">:</span> <span class="kt">Optimizer</span><span class="o">[</span><span class="kt">KVStore</span>, <span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">mouse</span> <span class="k">&lt;-</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"Mice"</span><span class="o">)</span>
  <span class="n">list</span> <span class="k">&lt;-</span> <span class="n">wrappedProgram</span><span class="o">(</span><span class="n">mouse</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="s">"64"</span><span class="o">)).</span><span class="n">optimize</span><span class="o">(</span><span class="n">F</span><span class="o">)</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">F</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="s">"Birds"</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="n">headOption</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="s">"128"</span><span class="o">))</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>Looking good so far, now all we need to run this is an actual instance of <code class="highlighter-rouge">Optimizer</code>.
We’ll use a Monix <code class="highlighter-rouge">Task</code> for this and for simplicity our new optimization will only look at the <code class="highlighter-rouge">get</code> operations:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="n">kvStoreTaskOptimizer</span><span class="k">:</span> <span class="kt">Optimizer</span><span class="o">[</span><span class="kt">KVStore</span>, <span class="kt">Task</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Optimizer</span><span class="o">[</span><span class="kt">KVStore</span>, <span class="kt">Task</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">M</span> <span class="o">=</span> <span class="nc">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">monoidM</span> <span class="k">=</span> <span class="n">implicitly</span>

  <span class="k">def</span> <span class="n">monadF</span> <span class="k">=</span> <span class="n">implicitly</span>

  <span class="k">def</span> <span class="n">extract</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">Const</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Const</span><span class="o">(</span><span class="nc">Set</span><span class="o">(</span><span class="n">key</span><span class="o">))</span>
    <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Const</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Const</span><span class="o">(</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">rebuild</span><span class="o">(</span><span class="n">gs</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">interp</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">Task</span><span class="o">])</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">KVStore</span><span class="o">[</span><span class="kt">Task</span><span class="o">]]</span> <span class="k">=</span>
    <span class="n">gs</span><span class="o">.</span><span class="n">toList</span>
      <span class="o">.</span><span class="n">parTraverse</span><span class="o">(</span><span class="n">key</span> <span class="k">=&gt;</span> <span class="n">interp</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">s</span><span class="o">))))</span>
      <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">collect</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">v</span> <span class="o">}.</span><span class="n">toMap</span><span class="o">)</span>
      <span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">m</span> <span class="k">=&gt;</span>
        <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">Task</span><span class="o">]</span> <span class="o">{</span>
          <span class="k">override</span> <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
            <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Option</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="n">pure</span><span class="o">[</span><span class="kt">Task</span><span class="o">]</span>
            <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="n">interp</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span>
          <span class="o">}</span>

          <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">interp</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
        <span class="o">}</span>
      <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>Our <code class="highlighter-rouge">Monoid</code> type is just a simple <code class="highlighter-rouge">Set[String]</code> here, as the <code class="highlighter-rouge">extract</code> function will only extract the <code class="highlighter-rouge">get</code> operations inside the <code class="highlighter-rouge">Set</code>.
Then with the <code class="highlighter-rouge">rebuild</code> we build up our new interpreter.
First we want to precompute all the values of the program.
To do so, we just run all the operations in parallel and put them into a <code class="highlighter-rouge">Map</code>, while discarding values where the <code class="highlighter-rouge">get</code> operation returned <code class="highlighter-rouge">None</code>.
Now when we have that precomputed <code class="highlighter-rouge">Map</code>, we’ll create a new interpreter with it, that will check if the key given to <code class="highlighter-rouge">get</code> operation is in the precomputed <code class="highlighter-rouge">Map</code> instead of performing an actual request.
We can then lift the value into a <code class="highlighter-rouge">Task[Option[String]]</code>.
For all the <code class="highlighter-rouge">put</code> operations, we’ll simply run the interpreter.</p>

<p>Now we should have a great optimizer for <code class="highlighter-rouge">KVStore</code> programs interpreted into a <code class="highlighter-rouge">Task</code>.
Let’s see how we did by interpreting into a silly implementation that only prints whenever you use one of the operations:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">TestInterpreter</span> <span class="k">extends</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">Task</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span>

    <span class="n">println</span><span class="o">(</span><span class="s">"Hit network for "</span> <span class="o">+</span> <span class="n">key</span><span class="o">)</span>

    <span class="nc">Option</span><span class="o">(</span><span class="n">key</span> <span class="o">+</span> <span class="s">"!"</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"Put something: "</span> <span class="o">+</span> <span class="n">a</span><span class="o">)</span>

    <span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now let’s run our program with this interpreter and the optimizations!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">monadicProgram</span><span class="o">(</span><span class="nc">TestInterpreter</span><span class="o">).</span><span class="n">runAsync</span>
<span class="c1">// Hit network for Mice
// Hit network for Cats
// Hit network for Dogs
// Put something: Mice!
// Put something: Cats!
</span></code></pre></div></div>

<p>And it works, we’ve now got a principled way to write programs that can then be potentially optimized.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Designing a way to completely separate the problem description from the actual problem solution is fairly difficult. The tagless final encoding allows us one such fairly simple way.
Using the technique described in this blog post, we should be able to have even more control over the problem solution by inspecting the structure of our program statically.
We’ve seen a few roadblocks along the way, such as the lack of Rank-N types in Scala, but we might be able to come up with a macro for that in the future, making it even more ergonomic.
Another thing we haven’t covered here, are programs with multiple algebras, which is quite a bit more complex as you can surely imagine, maybe that will be the topic of a follow up blog post.</p>

<p>The code is published <a href="https://github.com/LukaJCB/sphynx">right here</a>, but might still change after getting a feeling for which API feels best.</p>

<p>What kind of problems and techniques would you like to see with regards to tagless final?
Would love to hear from you in the comments!</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 27 Dec 2017 00:00:00 +0100</pubDate>
        <link>https://typelevel.org/blog/2017/12/27/optimizing-final-tagless.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2017/12/27/optimizing-final-tagless.html</guid>
      </item>
    
      <item>
        <title>Announcement: cats 1.0.0</title>
        
          <dc:creator>kailuowang</dc:creator>
                
        <description><![CDATA[<p>The <a href="https://github.com/typelevel/cats">cats</a> maintainer team is proud to announce the <strong>cats 1.0.0</strong> release.
Cats has been striving to provide functional programming abstractions that are core, modular, approachable and efficient. 
Cats 1.0.0 marks the point where we believe that our API is robust and stable enough to start guarantee backward binary compatibility going forward until Cats 2.0. We expect the Cats 1.x series to be fully backwards compatible for at least one year. This is a major milestone towards
our goal of providing a solid foundation for an ecosystem of pure, typeful functional libraries.</p>

<h2 id="migration">Migration</h2>

<p>The vast majority of changes since 1.0.0-RC1 are API compatible, with scalafix scripts ready for those that do not.
 <a href="https://github.com/typelevel/cats/blob/master/CHANGES.md">Here is the change list and migration guide</a>.</p>

<h2 id="binary-compatibility">Binary compatibility</h2>
<p>After 1.0.0 release, we’ll use the <em>MAJOR.MINOR.PATCH</em> <a href="https://semver.org/">Semantic Versioning 2.0.0</a> going forward, which is different from the <em>EPOCH.MAJOR.MINOR</em> scheme common among Java and Scala libraries (including the Scala lang).  In this semantic versioning, backward breaking change is ONLY allowed between <em>MAJOR</em> versions. We will maintain backward binary compatibility between <em>PATCH</em> and <em>MINOR</em> versions. For example, when we release cats 1.1.0, it will be backward binary compatible with the previous 1.0.x versions. I.E. the new JAR will be a drop-in replacement for the old one. This is critical when your application has a diamond dependency on Cats - depending on two or more libraries that all depend on Cats. If one library upgrades to the new 1.1.0 Cats before the other one does, your application still runs thanks to this backward binary compatibility.</p>

<p>We will also consider using organization and package name for <em>MAJOR</em> versioning with binary breaking changes in the future. But that decision is yet to be made.</p>

<h2 id="community">Community</h2>
<p>Cats is built for the FP Scala community by the FP Scala community. We can’t thank enough to our <a href="https://github.com/typelevel/cats/graphs/contributors">190 (and growing) contributors</a> and our users who provided feedbacks and suggestions.<br />
Congratulations to all of us. Let’s celebrate this exciting milestone together.</p>

<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Mon, 25 Dec 2017 00:00:00 +0100</pubDate>
        <link>https://typelevel.org/blog/2017/12/25/cats-1.0.0.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2017/12/25/cats-1.0.0.html</guid>
      </item>
    
      <item>
        <title>Who implements the typeclass instance?</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>The typeclass pattern in Scala invites you to place
implementation-specific knowledge directly in the typeclass instances,
with the interface defined as the typeclass’s abstract interface.</p>

<p>However, GADTs permit a different organization of code. It is even
possible to define a typeclass that seems to do nothing at all, yet
still permits full type-safe typeclass usage.</p>

<p>The possibilities between these two extremes form a design space. If
you wish to practice ad-hoc polymorphism in Scala, this space is well
worth exploring.</p>

<h2 id="a-glorified-overloader">A glorified overloader</h2>

<p>Refactoring a set of overloads into a typeclass is a fine way to get
some free flexibility and dynamism, because expressing overloads as a
typeclass gives you free fixes for common overload problems.</p>

<ol>
  <li>Methods calling the overloaded method do not themselves need to be
overloaded just to avoid suppressing the flexibility of the
overload beneath.  (See <code class="highlighter-rouge">addThree</code> and <code class="highlighter-rouge">zipAdd</code> below for
examples.)</li>
  <li>Return-type overloading works, even in Scala, where it does not
when attempting to write overloads in the Java style, i.e. multiple
methods with the same name.</li>
  <li>Overloads may be defined as recursive type rules, admitting a
combinatorial explosion or even infinite “effective overloads”.</li>
</ol>

<p>Let’s make a quick example of something like a typical overload.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">OverAdd</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
  
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">s</span><span class="s">"$x$y"</span>
  
  <span class="k">def</span> <span class="n">add</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">r</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">l</span> <span class="o">++</span> <span class="n">r</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This mechanically translates to a newly introduced type, some implicit
instances of that type, and a function to let us call <code class="highlighter-rouge">add</code> the same
way we used to.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// typeclasses are often defined with trait, but this is not required
</span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Adder</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">addImpl</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">)</span>

<span class="c1">// easier if all implicits are in this block
</span><span class="k">object</span> <span class="nc">Adder</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">addInts</span><span class="k">:</span> <span class="kt">Adder</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Adder</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">)</span>
  
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">addStrings</span><span class="k">:</span> <span class="kt">Adder</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Adder</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"$x$y"</span><span class="o">)</span>
    
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">addVects</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">Adder</span><span class="o">[</span><span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nc">Adder</span><span class="o">((</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">l</span> <span class="o">++</span> <span class="n">r</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// and to tie it back together
</span><span class="k">def</span> <span class="n">add</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">adder</span><span class="k">:</span> <span class="kt">Adder</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">adder</span><span class="o">.</span><span class="n">addImpl</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="overloaded-wrapping-without-overloading">Overloaded wrapping without overloading</h2>

<p>While a bit more ceremonious, this allows us to write some nice
functions more easily. Here’s a function to add three values.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">addThree</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Adder</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">m</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">r</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">add</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">add</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">r</span><span class="o">))</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">addThree</code> supports all three “overloads” of <code class="highlighter-rouge">add</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">addThree</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">6</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">addThree</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"ba"</span><span class="o">,</span> <span class="s">"cus"</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">abacus</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">addThree</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div></div>

<p>With the overload style, we need three variants of this function, too,
each with the exact same body. The typeclass version need only be
written once, and automatically supports new overloads, that is, new
instances of <code class="highlighter-rouge">Adder</code>.</p>

<p>Same with this function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">zipAdd</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Adder</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">r</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">l</span> <span class="n">zip</span> <span class="n">r</span> <span class="n">map</span> <span class="o">{</span><span class="k">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">add</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)}</span>
</code></pre></div></div>

<p>Functions like <code class="highlighter-rouge">addThree</code> and <code class="highlighter-rouge">zipAdd</code> are called <em>derived
combinators</em>. The more that you can do in derived combinators, the
more abstract and orthogonal your program will be.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   +=============+            |   +=============+
   |   derived   |  (open     |   |  primitive  |  (closed
   | combinators |    set)    |   | combinators |      set)
   +=============+            |   +=============+
                              |
   +----------+               |    +----------+
   | addThree |---→---→---→---→---→| Adder    |
   +----------+       calls   |    | -addImpl |    +===========+
    ↑                       |→---→ +----------+    | Instances |
    | +--------+            | |                    +===========+
    | | zipAdd |---→---→---→- |
    | +--------+    calls     |  +------+ +---------+ +-------+
    ↑        ↑                |  | Ints | | Strings | | Vects |
    |   calls|                |  +------+ +---------+ +-------+
    |      +-----+            |      |
    |      | ??? |            |      |
    ↑      +-----+            |      |
    |  (derived combinators          ↓
    |   can derive from each other)  ---→---→---→
    |                                           |
    ↑          -------------------------------  |
    |          To evaluate `addThree(1, 2, 3)`  |
    |          -------------------------------  ↓
    |          1. Fetch `Adder` implicitly      |
    |-←---←---←---←---←---←---←---←---←---←---←-|
               2. Pass to `addThree`
               3. `addThree` uses the abstract interface to
                  invoke the primitive `add` combinator on what,
                  to it, is an abstract type, `A`.
</code></pre></div></div>

<h2 id="infinite-overloads-via-recursion">Infinite overloads via recursion</h2>

<p>Making derived combinators easier to write is very useful, but
typeclasses go further by letting you describe overloading rules that
would be impossible with normal overloading.</p>

<p>Given that I can add <code class="highlighter-rouge">Int</code> and <code class="highlighter-rouge">Int</code> together, I should be able to add
<code class="highlighter-rouge">(Int, Int)</code> and <code class="highlighter-rouge">(Int, Int)</code> to get <code class="highlighter-rouge">(Int, Int)</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="n">addIntPairs</span><span class="k">:</span> <span class="kt">Adder</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span>
  <span class="nc">Adder</span><span class="o">{</span><span class="k">case</span> <span class="o">((</span><span class="n">x1</span><span class="o">,</span> <span class="n">x2</span><span class="o">),</span> <span class="o">(</span><span class="n">y1</span><span class="o">,</span> <span class="n">y2</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="o">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">y1</span><span class="o">,</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">y2</span><span class="o">)}</span>
    
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">add</span><span class="o">((</span><span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">),</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">8</span><span class="o">))</span>
<span class="n">res3</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="mi">5</span><span class="o">,</span><span class="mi">15</span><span class="o">)</span>
</code></pre></div></div>

<p>But I should also be able to add pairs of <code class="highlighter-rouge">String</code>. And <code class="highlighter-rouge">(Int,
String)</code> pairs. And <code class="highlighter-rouge">(String, Vector[Boolean])</code> pairs. And pairs of
pairs of pairs.</p>

<p>Typeclasses let you declare newly supported types recursively, with an
implicit argument list to the <code class="highlighter-rouge">implicit def</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">addPairs</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Adder</span>, <span class="kt">B:</span> <span class="kt">Adder</span><span class="o">]</span>
    <span class="k">:</span> <span class="kt">Adder</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
  <span class="nc">Adder</span><span class="o">{</span><span class="k">case</span> <span class="o">((</span><span class="n">a1</span><span class="o">,</span> <span class="n">b1</span><span class="o">),</span> <span class="o">(</span><span class="n">a2</span><span class="o">,</span> <span class="n">b2</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="o">(</span><span class="n">add</span><span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="n">a2</span><span class="o">),</span> <span class="n">add</span><span class="o">(</span><span class="n">b1</span><span class="o">,</span> <span class="n">b2</span><span class="o">))</span>
  <span class="o">}</span>
</code></pre></div></div>

<h2 id="surely-this-must-be-going-somewhere-new">Surely this must be going somewhere new</h2>

<p>If you’re familiar with type classes, all this must be old hat. But
this time, we’re going to expand the boundaries of the typeclass
design space, by exploiting <em>GADT pattern matching</em>.</p>

<p>We could have designed the <code class="highlighter-rouge">Adder</code> type class to include <code class="highlighter-rouge">addThree</code> as
a primitive combinator, and implemented it afresh for each of the four
instances we’ve defined so far, as well as any future instances
someone might define. Thinking orthogonally, however, shows us that
there’s a more primitive concept which strictly generalizes it: if we
primitively define a two-value adder, we can use it to add three
items, simply by using it twice.</p>

<p>This has a direct impact on how we structure the functions related to
<code class="highlighter-rouge">Adder</code>. The primitives must be split up, their separate
implementations appearing directly in the implicit instances. Derived
combinators may occur anywhere that is convenient to us: outside the
typeclass for full flexibility of location, or within the typeclass
for possible overrides for performance.</p>

<p>But how much of the primitive implementations must occur in the
instances, really?</p>

<h2 id="empty-tags-as-instances">Empty tags as instances</h2>

<p>There is a progression of design refinements here.</p>

<ol>
  <li>Ad hoc overloads, Java-style, impossible to abstract over.</li>
  <li>Flip into a typeclass.</li>
  <li>Refine the primitive/derived distinction to minimize code in
instances.</li>
</ol>

<p>For some typeclasses, <em>no</em> code needs to be put in the instances. For
example, if we want to support only <code class="highlighter-rouge">Int</code>, <code class="highlighter-rouge">String</code>, and <code class="highlighter-rouge">Vector</code>,
here is a perfectly sensible typeclass definition.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ISAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

<span class="nc">object</span> <span class="nc">ISAdder</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">object</span> <span class="nc">AddInts</span> <span class="k">extends</span> <span class="nc">ISAdder</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">implicit</span> <span class="k">object</span> <span class="nc">AddStrs</span> <span class="k">extends</span> <span class="nc">ISAdder</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
  
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AddVects</span><span class="o">[</span><span class="kt">E</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">ISAdder</span><span class="o">[</span><span class="kt">Vector</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span>
  
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">addVects</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">Vector</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nc">AddVects</span><span class="o">()</span>
<span class="o">}</span>
</code></pre></div></div>

<p>If the instances cannot add values of the types indicated by the type
parameters, surely that code must exist somewhere! And it has a place,
in the definition of <code class="highlighter-rouge">add</code>.</p>

<p>If you recall, this method merely called <code class="highlighter-rouge">addImpl</code> on the typeclass
instance before. Now there is no such thing; the instances are empty.</p>

<p>Well, they are not quite empty; they contain a type.  So we can define
<code class="highlighter-rouge">add</code>, with complete type safety, as follows.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">isadd</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">adder</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">adder</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">ISAdder</span><span class="o">.</span><span class="nc">AddInts</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="k">case</span> <span class="nc">ISAdder</span><span class="o">.</span><span class="nc">AddStrings</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"$x$y"</span>
    <span class="k">case</span> <span class="nc">ISAdder</span><span class="o">.</span><span class="nc">AddVects</span><span class="o">()</span> <span class="k">=&gt;</span>
      <span class="n">x</span> <span class="o">++</span> <span class="n">y</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>More specifically, they contain a runtime tag, which allows
information about the type of <code class="highlighter-rouge">A</code> to be extracted with a pattern
match. For example, determining that <code class="highlighter-rouge">adder</code> is <code class="highlighter-rouge">AddInts</code> reveals that
<code class="highlighter-rouge">A = Int</code>, because that’s what the <code class="highlighter-rouge">extends</code> clause says.  This is
<em>GADT pattern matching</em>.</p>

<p>The <code class="highlighter-rouge">Vector</code> case is a little tricky here, because we can only
determine that <code class="highlighter-rouge">A</code> is <code class="highlighter-rouge">Vector[e]</code> <em>for some unknown e</em>, but that’s
enough information to invoke <code class="highlighter-rouge">++</code> and get a result also of <code class="highlighter-rouge">Vector[e]</code>
for the same <code class="highlighter-rouge">e</code>.</p>

<p>You can see this in action by using a <a href="https://groups.google.com/d/msg/scala-user/JlCsy48poIU/DjsQDnzeZboJ">variable type
pattern</a>
to assign the name <code class="highlighter-rouge">e</code> (a lowercase type parameter is required for
this usage), so you can refer to it in types.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">case</span> <span class="k">_:</span> <span class="kt">ISAdder.AddVects</span><span class="o">[</span><span class="kt">e</span><span class="o">]</span> <span class="k">=&gt;</span>
      <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">e</span><span class="o">])</span> <span class="o">++</span> <span class="n">y</span>
</code></pre></div></div>

<h2 id="the-lowercase-e-names-a-gadt-skolem">The lowercase <code class="highlighter-rouge">e</code> names a GADT skolem</h2>

<p>In the <code class="highlighter-rouge">AddVects[e]</code> pattern immediately above, <code class="highlighter-rouge">e</code> is a <em>variable
type pattern</em>. This is a type that exists only in the scope of the
<code class="highlighter-rouge">case</code>.</p>

<p>It’s <em>existential</em> because we don’t know what it is, only that it is
<em>some type</em> and we don’t get to pick here what that is. In this way,
it is no different from a type parameter’s treatment by the
implementation, which is
<a href="/blog/2016/01/28/existential-inside.html">existential on the inside</a>.</p>

<p>It’s a <em>GADT skolem</em> because it was bound by the pattern matching
mechanism to a “fresh” type, unequal to any other. Recall the way
<code class="highlighter-rouge">AddVects</code> was defined:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">AddVects</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="k">extends</span> <span class="nc">ISAdder</span><span class="o">[</span><span class="kt">Vector</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span>
</code></pre></div></div>

<p>Matching <code class="highlighter-rouge">ISAdder</code> with <code class="highlighter-rouge">AddVects</code> doesn’t tell us anything about
bounds on the type passed to <code class="highlighter-rouge">AddVects</code> at construction time. This
isn’t true of all
<a href="/blog/2016/09/19/variance-phantom.html#a-gadt-skolem">GADT skolems</a>,
but is only natural for this one.</p>

<p><code class="highlighter-rouge">scalac</code> will create this GADT skolem <em>regardless of whether we give
it a name</em>. In the pattern <code class="highlighter-rouge">case AddVects()</code>, it’s still known that
<code class="highlighter-rouge">A = Vector[e]</code> for some <code class="highlighter-rouge">e</code>; the only difference is that you haven’t
bound the <code class="highlighter-rouge">e</code> name, so you can’t actually refer to this <em>unspeakable</em>
type.</p>

<p>Usually, you do not need to assign names such as <code class="highlighter-rouge">e</code> to such types;
<code class="highlighter-rouge">_</code> is sufficient.  However, if you have problems getting <code class="highlighter-rouge">scalac</code> to
apply all the type equalities it ought to know about, a good first
step is to assign names to any skolems and try type
ascriptions. You’ll need a variable type pattern in other situations
that don’t infer, too. By contrast, with the <code class="highlighter-rouge">e</code> name bound, we can
confirm that <code class="highlighter-rouge">x: Vector[e]</code> in the above example, and <code class="highlighter-rouge">y</code> is
sufficiently well-typed for the whole expression to type-check.</p>

<h2 id="porting-addpairs-and-other-recursive-cases">Porting <code class="highlighter-rouge">addPairs</code> and other recursive cases</h2>

<p>Suppose we add support for pairs to <code class="highlighter-rouge">ISAdder</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AddPairs</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span>
    <span class="k">val</span> <span class="n">fst</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span>
    <span class="k">val</span> <span class="n">snd</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="o">)</span> <span class="k">extends</span> <span class="nc">ISAdder</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>
</code></pre></div></div>

<p>This <em>should</em> permit us to pattern-match in <code class="highlighter-rouge">isadd</code> to make complex
determinations about the <code class="highlighter-rouge">A</code> type given to <code class="highlighter-rouge">isadd</code>. This <em>ought to be</em>
a big win for GADT-style typeclasses, allowing “short-circuiting”
patterns that work in an obvious way.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// this pattern means A=(Int, String)
</span><span class="k">case</span> <span class="nc">AddPairs</span><span class="o">(</span><span class="nc">AddInts</span><span class="o">,</span> <span class="nc">AddStrs</span><span class="o">)</span> <span class="k">=&gt;</span>

<span class="c1">// this pattern means A=(ea, Vector[eb])
// where ea and eb are GADT skolems
</span><span class="k">case</span> <span class="nc">AddPairs</span><span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="k">_:</span> <span class="kt">AddVects</span><span class="o">[</span><span class="kt">eb</span><span class="o">])</span> <span class="k">=&gt;</span>

<span class="c1">// here, A=(ea, eb) (again, GADT skolems)
// calling `isadd` recursively is the most
// straightforward implementation
</span><span class="k">case</span> <span class="nc">AddPairs</span><span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="n">snd</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="o">(</span><span class="n">f1</span><span class="o">,</span> <span class="n">s1</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span>
  <span class="k">val</span> <span class="o">(</span><span class="n">f2</span><span class="o">,</span> <span class="n">s2</span><span class="o">)</span> <span class="k">=</span> <span class="n">y</span>
  <span class="o">(</span><span class="n">isadd</span><span class="o">(</span><span class="n">f1</span><span class="o">,</span> <span class="n">f2</span><span class="o">)(</span><span class="n">fst</span><span class="o">),</span> <span class="n">isadd</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">)(</span><span class="n">snd</span><span class="o">))</span>
</code></pre></div></div>

<p>The final <code class="highlighter-rouge">case</code>’s body is fine. <code class="highlighter-rouge">scalac</code> effectively introduces
skolems <code class="highlighter-rouge">ea</code> and <code class="highlighter-rouge">eb</code> so that <code class="highlighter-rouge">A = (ea, eb)</code>, <code class="highlighter-rouge">fst: Adder[ea]</code>, and so
on, and everything lines up nicely. We are not so lucky with the other
cases.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">....</span><span class="n">scala</span><span class="k">:</span><span class="err">76</span><span class="kt">:</span> <span class="kt">pattern</span> <span class="k">type</span> <span class="kt">is</span> <span class="kt">incompatible</span> <span class="kt">with</span> <span class="kt">expected</span> <span class="k">type</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">ISAdder.AddInts.type</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span>
      <span class="k">case</span> <span class="nc">AddPairs</span><span class="o">(</span><span class="nc">AddInts</span><span class="o">,</span> <span class="nc">AddStrs</span><span class="o">)</span> <span class="k">=&gt;</span>
                    <span class="o">^</span>
<span class="o">....</span><span class="n">scala</span><span class="k">:</span><span class="err">76</span><span class="kt">:</span> <span class="kt">pattern</span> <span class="k">type</span> <span class="kt">is</span> <span class="kt">incompatible</span> <span class="kt">with</span> <span class="kt">expected</span> <span class="k">type</span><span class="o">;</span>

 <span class="n">found</span>   <span class="k">:</span> <span class="kt">ISAdder.AddStrs.type</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span>
      <span class="k">case</span> <span class="nc">AddPairs</span><span class="o">(</span><span class="nc">AddInts</span><span class="o">,</span> <span class="nc">AddStrs</span><span class="o">)</span> <span class="k">=&gt;</span>
                             <span class="o">^</span>
<span class="o">....</span><span class="n">scala</span><span class="k">:</span><span class="err">79</span><span class="kt">:</span> <span class="kt">pattern</span> <span class="k">type</span> <span class="kt">is</span> <span class="kt">incompatible</span> <span class="kt">with</span> <span class="kt">expected</span> <span class="k">type</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">ISAdder.AddVects</span><span class="o">[</span><span class="kt">eb</span><span class="o">]</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span>
      <span class="k">case</span> <span class="nc">AddPairs</span><span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="k">_:</span> <span class="kt">AddVects</span><span class="o">[</span><span class="kt">eb</span><span class="o">])</span> <span class="k">=&gt;</span>
                            <span class="o">^</span>
</code></pre></div></div>

<p>This is nonsensical; the underlying code is sound, we just have to go
the long way around so that <code class="highlighter-rouge">scalac</code> doesn’t get confused. Instead of
the above form, you must assign names to the <code class="highlighter-rouge">AddPairs</code> skolems as we
described above, and do a sub-pattern-match.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="n">p</span><span class="k">:</span> <span class="kt">AddPairs</span><span class="o">[</span><span class="kt">ea</span>, <span class="kt">eb</span><span class="o">]</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="o">(</span><span class="n">f1</span><span class="o">,</span> <span class="n">s1</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span>
  <span class="k">val</span> <span class="o">(</span><span class="n">f2</span><span class="o">,</span> <span class="n">s2</span><span class="o">)</span> <span class="k">=</span> <span class="n">y</span>
  <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">fst</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="n">snd</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="nc">AddInts</span><span class="o">,</span> <span class="nc">AddStrs</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="k">_:</span> <span class="kt">AddVects</span><span class="o">[</span><span class="kt">eb</span><span class="o">])</span> <span class="k">=&gt;</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="n">snd</span><span class="o">)</span> <span class="k">=&gt;</span>
</code></pre></div></div>

<p>Note that we had to give up on the <code class="highlighter-rouge">AddPairs</code> pattern entirely,
because</p>

<ol>
  <li>More complex situations require type ascription.</li>
  <li>You cannot ascribe with skolems unless you’ve bound the skolems to
names with variable type patterns.</li>
  <li>You can’t use variable type patterns with the structural
“ADT-style” patterns; you must instead use inelegant and
inconvenient [non-variable] type patterns. (This may be
<a href="https://github.com/typelevel/scala/blob/typelevel-readme/notes/typelevel-4.md#type-arguments-on-patterns-pull5774-paulp">improved in Typelevel Scala 4</a>.)</li>
</ol>

<p>Yet this remains entirely up to shortcomings in the current pattern
matcher implementation. An improved pattern matcher could make the
nice version work, safely and soundly.</p>

<p>As such, I don’t want these shortcomings to discourage you from trying
out the pure type-tagging, “GADT-style” typeclasses. It is simply
nicer for many applications, and you aren’t going to code yourself
into a hole with them, because should you wind up in the buggy
territory we’ve been exploring, there’s still a way out.</p>

<h2 id="same-typeclass-new-primitive-combinators">Same typeclass, new “primitive” combinators</h2>

<p>“Empty” typeclasses like <code class="highlighter-rouge">ISAdder</code> contain no implementations of
primitive combinators, only “tags”. As such, they are in a sense the
purest form of “typeclass”; <em>to classify types</em> is the beginning and
end of what they do!</p>

<p>Every type that is a member of the “class of types” <code class="highlighter-rouge">ISAdder</code> is
either</p>

<ol>
  <li>the type <code class="highlighter-rouge">Int</code>,</li>
  <li>the type <code class="highlighter-rouge">String</code>,</li>
  <li>a type <code class="highlighter-rouge">Vector[e]</code>, where <code class="highlighter-rouge">e</code> is any type, or</li>
  <li>a type <code class="highlighter-rouge">(x, y)</code> where <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> are types that are <em>also</em> in the
<code class="highlighter-rouge">ISAdder</code> class.</li>
</ol>

<p>This is the end of <code class="highlighter-rouge">ISAdder</code>’s definition; in particular, there is
nothing here about “adding two values to get a value”. All that
is said is what types are in the class!</p>

<p>Given this ‘undefinedness’, if we have another function we want to
write over the exact same class-of-types, we can just write it without
making any changes to <code class="highlighter-rouge">ISAdder</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">backwards</span><span class="o">[</span><span class="kt">X</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">X</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">adder</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">X</span><span class="o">])</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=</span> <span class="n">adder</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">AddInts</span> <span class="k">=&gt;</span> <span class="o">-</span><span class="n">x</span>
  <span class="k">case</span> <span class="nc">AddStrs</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">reverse</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">AddVects</span><span class="o">[</span><span class="kt">e</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">reverse</span>
  <span class="k">case</span> <span class="n">p</span><span class="k">:</span> <span class="kt">AddPairs</span><span class="o">[</span><span class="kt">ea</span>, <span class="kt">eb</span><span class="o">]</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">ea</span><span class="o">,</span> <span class="kt">eb</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span>
    <span class="o">(</span><span class="n">backwards</span><span class="o">(</span><span class="n">a</span><span class="o">)(</span><span class="n">p</span><span class="o">.</span><span class="n">fst</span><span class="o">),</span> <span class="n">backwards</span><span class="o">(</span><span class="n">b</span><span class="o">)(</span><span class="n">p</span><span class="o">.</span><span class="n">snd</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Set aside the question of whether the class of “backwards-able” types
ought to remain in lockstep with the class of “addable”
types. Supposing that it <em>should</em>, the class need be defined only
once.</p>

<p>More practically speaking, if you expose the subclasses of a typeclass
to users of your library, they can define primitives “in lockstep”,
too.  The line between primitive and derived combinators is also
blurred: a would-be derived combinator can pattern-match on the
typeclass to supply special cases for improved performance, becoming
“semi-primitive” in the process.  You decide whether these are good
things or not.</p>

<h2 id="hybrid-clopen-typeclasses">Hybrid “clopen” typeclasses</h2>

<p>Pattern-matching typeclass GADTs is subject to the same exhaustiveness
concerns and compiler warnings as pattern-matching ordinary ADTs. If
you eliminate a <code class="highlighter-rouge">case</code> from <code class="highlighter-rouge">def isadd</code>, you’ll see something like</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">....</span><span class="n">scala</span><span class="k">:</span><span class="err">57</span><span class="kt">:</span> <span class="kt">match</span> <span class="kt">may</span> <span class="kt">not</span> <span class="kt">be</span> <span class="kt">exhaustive.</span>
<span class="kt">It</span> <span class="kt">would</span> <span class="kt">fail</span> <span class="kt">on</span> <span class="kt">the</span> <span class="kt">following</span> <span class="kt">input:</span> <span class="kt">AddInts</span>
    <span class="n">adder</span> <span class="k">match</span> <span class="o">{</span>
    <span class="o">^</span>
</code></pre></div></div>

<p>We could unseal <code class="highlighter-rouge">ISAdder</code>, which would eliminate the warning, but
wouldn’t really solve anything. The function would still crash upon
encountering the missing case.</p>

<p>Pattern matches of unsealed hierarchies typically include a “fallback”
case, code used when none of the “special” cases match. However, for
pure typeclasses like <code class="highlighter-rouge">ISAdder</code>, this strategy is a dead end
too. Consider a hypothetical fallback case.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="o">???</span>
</code></pre></div></div>

<p>Each of the other patterns in <code class="highlighter-rouge">isadd</code>, by their success, taught us
something useful about the <code class="highlighter-rouge">A</code> type parameter. For example, <code class="highlighter-rouge">case
AddInts</code> tells us that <code class="highlighter-rouge">A = Int</code>, and accordingly <code class="highlighter-rouge">x: Int</code> and <code class="highlighter-rouge">y:
Int</code>. It also meant that the expected result type of that block is
also <code class="highlighter-rouge">Int</code>. That’s plenty of information to actually implement
“adding”.</p>

<p>By contrast, <code class="highlighter-rouge">case _</code> tells us <em>nothing</em> about the <code class="highlighter-rouge">A</code> type. We don’t
know anything new about <code class="highlighter-rouge">x</code>, <code class="highlighter-rouge">y</code>, or the type of value we ought to
return. All we can do is return either <code class="highlighter-rouge">x</code> or <code class="highlighter-rouge">y</code> without further
combination; while this is a sort of “adding” <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Monoid.html#t:First">in abstract
algebra</a>,
there’s a good chance it’s not really what the caller was expecting.</p>

<p>Instead, we can reformulate a closed typeclass like <code class="highlighter-rouge">ISAdder</code> with one
extension point, where the typeclass is specially encoded in the usual
“embedded implementation” style. It’s closed and open, so
<a href="https://mail.haskell.org/pipermail/haskell-cafe/2014-April/113373.html">“clopen”</a>.</p>

<h2 id="sealed-doesnt-seal-subclasses"><code class="highlighter-rouge">sealed</code> doesn’t seal subclasses</h2>

<p>Our GADT typeclass instances work by embedding type information within
the instances, to be rediscovered at runtime. To support open
extension, we need a data case that contains <em>functions</em> instead of
types. We know how to encode that, because that is how standard,
non-GADT typeclasses work.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ISOAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

<span class="nc">trait</span> <span class="nc">ExtISOAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">extends</span> <span class="nc">ISOAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">addImpl</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">ISOAdder</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">object</span> <span class="nc">AddInts</span> <span class="k">extends</span> <span class="nc">ISOAdder</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">implicit</span> <span class="k">object</span> <span class="nc">AddStrs</span> <span class="k">extends</span> <span class="nc">ISOAdder</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
  
  <span class="k">final</span> <span class="k">class</span> <span class="nc">AddVects</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">ISOAdder</span><span class="o">[</span><span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
  
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">addVects</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">ISOAdder</span><span class="o">[</span><span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">AddVects</span>
    
  <span class="k">def</span> <span class="n">isoadd</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">adder</span><span class="k">:</span> <span class="kt">ISOAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
    <span class="n">adder</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">AddInts</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
      <span class="k">case</span> <span class="nc">AddStrs</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"$x$y"</span>
      <span class="k">case</span> <span class="k">_:</span> <span class="kt">AddVects</span><span class="o">[</span><span class="kt">e</span><span class="o">]</span> <span class="k">=&gt;</span>
        <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">e</span><span class="o">])</span> <span class="o">++</span> <span class="n">y</span>
      <span class="c1">// NB: no unchecked warning here, which makes sense
</span>      <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">ExtISOAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span>
        <span class="n">e</span><span class="o">.</span><span class="n">addImpl</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>By sealing <code class="highlighter-rouge">ISOAdder</code>, we ensure that the pattern match in <code class="highlighter-rouge">isoadd</code>
remains exhaustive. However, one of those cases, <code class="highlighter-rouge">ExtISOAdder</code>, admits
new subclasses, itself! This is fine because no matter how many
subclasses of <code class="highlighter-rouge">ExtISOAdder</code> we make, they’ll still match the last
pattern of <code class="highlighter-rouge">isoadd</code>.</p>

<p>We could also define <code class="highlighter-rouge">ExtISOAdder</code> as a <code class="highlighter-rouge">final case class</code>. The point
is that you can make this “extension point” in your otherwise-closed
typeclass using whatever style you like.</p>

<p>One caveat, though: “clopen” typeclasses cannot have arbitrary new
primitive combinators added to them. They are like ordinary open
typeclasses in that regard. Consider a version of <code class="highlighter-rouge">backwards</code> for
<code class="highlighter-rouge">ISOAdder</code>: what you could do in the <code class="highlighter-rouge">ExtISOAdder</code> case?</p>

<h2 id="whoever-you-like">Whoever you like</h2>

<p>With type parameters vs. members, you can get pretty far with
<a href="/blog/2015/07/13/type-members-parameters.html#when-is-existential-ok">the “rule of thumb”</a>.
Beyond that, even bugs in <code class="highlighter-rouge">scalac</code> typechecking can guide you to the
“right” choice.</p>

<p>There is no similar rule for this design space. It might seem that
typeclass newcomers might have an easier time with the OO-style
“unimplemented method” signposts in the open style, but I have also
seen them lament the loss of flexibility that would be provided by the
GADT style.</p>

<p>Likewise, as an advanced practitioner, your heart will be rent by the
tug-of-war between the boilerplate of the open style and the
pattern-matcher’s finickiness with the GADT style. You may then be
tempted to adopt the hybrid ‘clopen’ style, but this, too, is too
often a form of design excess.</p>

<p>Given all that, the only help I can offer, aside from describing the
design space above, is “pick whichever you like”. You know your
program; if you are not sure which will be nicer, try both!</p>

<p><em>This article was tested with Scala 2.12.4.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 20 Dec 2017 00:00:00 +0100</pubDate>
        <link>https://typelevel.org/blog/2017/12/20/who-implements-typeclass.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2017/12/20/who-implements-typeclass.html</guid>
      </item>
    
      <item>
        <title>There are at least three types of strings</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><a href="https://contributors.scala-lang.org/t/pre-sip-unboxed-wrapper-types/987">Newtype mechanisms</a>
are a great way to introduce wrapper-free, global distinctions of
“different” instances of the same type. But we can do that on a local
level, too,
<a href="https://gist.github.com/jbgi/d6b677d084fafc641fe01f7ffd00591c/70842ca600e53e8c237c681773fe4e16bd679628#file-label-java-L32">by using type parameters</a>.</p>

<p>Consider these two signatures.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">mungeIDs</span><span class="o">(</span><span class="n">uids</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">gids</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span>
             <span class="n">oids</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Magic</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span>, <span class="kt">String</span><span class="o">]</span>

<span class="k">def</span> <span class="n">mungeIDsSafely</span><span class="o">[</span><span class="kt">UID</span> <span class="k">&lt;:</span> <span class="kt">String</span>, <span class="kt">GID</span> <span class="k">&lt;:</span> <span class="kt">String</span>, <span class="kt">OID</span> <span class="k">&lt;:</span> <span class="kt">String</span><span class="o">]</span>
            <span class="o">(</span><span class="n">uids</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">UID</span><span class="o">],</span> <span class="n">gids</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">GID</span><span class="o">],</span>
             <span class="n">oids</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">OID</span><span class="o">])</span><span class="k">:</span> <span class="kt">Magic</span><span class="o">[</span><span class="kt">UID</span>, <span class="kt">GID</span>, <span class="kt">OID</span><span class="o">]</span> 
</code></pre></div></div>

<p>The second function is a strictly more general interface; the first,
concrete signature can be implemented by calling the second function,
passing <code class="highlighter-rouge">[String, String, String]</code> as the type arguments. There is no
need to even have the first signature; anywhere in your program where
you pass three <code class="highlighter-rouge">List[String]</code>s as arguments to <code class="highlighter-rouge">mungeIDsSafely</code>, the
proper type arguments will be inferred.</p>

<p>Yet, assuming you don’t wish <code class="highlighter-rouge">mungeIDs</code> to be oracular (i.e. a source
of UIDs, GIDs, and OIDs), the second signature is probably much more
reliable, because type parameters are quite as
<a href="/blog/2017/02/13/more-types-than-classes.html#it-must-not-necessarily-be-anything">mysterious</a>
as the opaque abstract type members of the newtype mechanism.</p>

<ol>
  <li><code class="highlighter-rouge">mungeIDsSafely</code> can’t invent new IDs, not even with <code class="highlighter-rouge">null</code>.</li>
  <li>It can’t combine them to produce new IDs.</li>
  <li>It <em>can</em> treat the three list arguments as <code class="highlighter-rouge">List[String]</code>. However,
it cannot convert any <code class="highlighter-rouge">String</code> back into an ID; any UIDs, GIDs, or
OIDs that appear in the result <code class="highlighter-rouge">Magic[UID, GID, OID]</code> must have
come from one of the argument lists, directly. (That’s not to say
that <code class="highlighter-rouge">mungeIDsSafely</code> can’t <em>use</em> the string-nature to make that
decision; for example, it could always choose the
smallest-as-string UID to put into the resulting <code class="highlighter-rouge">Magic</code>. But, that
UID is <em>still</em> enforced to be a proper element of the <code class="highlighter-rouge">uids</code>
argument, and cannot be gotten from anywhere else.</li>
  <li>Perhaps most importantly, it cannot mix up UIDs, GIDs, and
OIDs. Even though, “really”, they’re all strings!</li>
</ol>

<p>It is entirely irrelevant that you cannot subclass <code class="highlighter-rouge">String</code> in Scala,
Java, or whatever.
<a href="/blog/2017/02/13/more-types-than-classes.html">There are more types than classes</a>.</p>

<p>Given the advantages, it’s very unfortunate that the signature of
<code class="highlighter-rouge">mungeIDsSafely</code> is so much noisier than that of <code class="highlighter-rouge">mungeIDs</code>.  At least
you have the small consolation of eliminating more useless unit tests.</p>

<p>This is a good first approximation at moving away from the dangers of
concreteness in Scala, and has the advantage of working in Java, too
(sort of; the <code class="highlighter-rouge">null</code> prohibition is sadly relaxed).</p>

<h2 id="non-supertype-constraints">Non-supertype constraints</h2>

<p>In Scala, you can also use implicits to devise arbitrary constraints,
similar to typeclasses in Haskell, and sign your functions using
implicits instead, for much finer-grained control, improved safety,
and types-as-documentation.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// a typeclass for "IDish types" (imagine instances)
</span><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">IDish</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

<span class="nc">def</span> <span class="n">mungeIDsTCey</span><span class="o">[</span><span class="kt">UID:</span> <span class="kt">IDish</span>, <span class="kt">GID:</span> <span class="kt">IDish</span>, <span class="kt">OID:</span> <span class="kt">IDish</span><span class="o">]</span>
            <span class="o">(</span><span class="n">uids</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">UID</span><span class="o">],</span> <span class="n">gids</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">GID</span><span class="o">],</span>
             <span class="n">oids</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">OID</span><span class="o">])</span><span class="k">:</span> <span class="kt">Magic</span><span class="o">[</span><span class="kt">UID</span>, <span class="kt">GID</span>, <span class="kt">OID</span><span class="o">]</span> 
</code></pre></div></div>

<p>Though all three types have the same constraint, <code class="highlighter-rouge">IDish</code>, they are
still distinct types.  And now, the coupling with <code class="highlighter-rouge">String</code> is broken;
as the program author, you get to decide whether you want that or not.</p>

<h2 id="pitfalls-avoided-for-you">Pitfalls avoided for you</h2>

<p>Luckily, Java doesn’t make the mistake of “reified generics”. If it
did, you could ask whether <code class="highlighter-rouge">UID = GID = OID = String</code>, and all your
safety guarantees would be gone. Forcing all generics to be reified
does not grant you any new expressive power; all it does is
permanently close off large swaths of the spectrum of mystery to you,
forbidding you from using the full scope of the design space to
improve the reliability of your well-typed programs.</p>

<p>The same goes for claiming that <code class="highlighter-rouge">null</code> ought to be a default member of
<em>every</em> type, even the abstract ones that ought to be a little more
mysterious; it’s easy to add new capabilities (e.g. Scala’s <code class="highlighter-rouge">&gt;: Null</code>
constraint, if you really <em>must</em> use <code class="highlighter-rouge">null</code>), but taking them away is
much, much harder.</p>

<p>Furthering this spirit of making good programs easier to write and bad
programs harder to write, a useful area of research in Scala might be
making signatures such as that of <code class="highlighter-rouge">mungeIDsSafely</code> nicer, or
signatures such as that of <code class="highlighter-rouge">mungeIDs</code> uglier.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Tue, 05 Sep 2017 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2017/09/05/three-types-of-strings.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2017/09/05/three-types-of-strings.html</guid>
      </item>
    
      <item>
        <title>Announcement: cats 1.0.0-MF</title>
        
          <dc:creator>kailuowang</dc:creator>
                
        <description><![CDATA[<p>The <a href="https://github.com/typelevel/cats">cats</a> maintainer team is proud to announce the <strong>cats 1.0.0-MF</strong> release.</p>

<p><strong>MF</strong> stands for <em>milestone final</em>,
this will be the last release before cats 1.0.0-RC1 which will be followed by cats 1.0 shortly.</p>

<p>The main purpose/focus of this release is to offer a relatively stable API to work with prior to the official 1.0.
It can be deemed as a proposal for the final cats 1.0 API. Please help test it and report any improvements/fixes
needed either in the <a href="https://gitter.im/typelevel/cats-dev">cats-dev gitter channel</a> or as <a href="https://github.com/typelevel/cats/issues/new">github issues</a>.
Post cats 1.0, we will keep API stable and maintain strong binary compatibility.</p>

<p>Highlights of the major new features include but not limited to:</p>

<ul>
  <li><a href="https://github.com/typelevel/cats/pull/1117">#1117</a>: Stack safe <code class="highlighter-rouge">foldLeftM</code> without <code class="highlighter-rouge">Free</code>, by @TomasMikula</li>
  <li><a href="https://github.com/typelevel/cats/pull/1598">#1598</a>: A <code class="highlighter-rouge">ReaderWriterStateT</code> data type, by @iravid</li>
  <li><a href="https://github.com/typelevel/cats/pull/1526">#1526</a> and <a href="https://github.com/typelevel/cats/pull/1596">#1596</a>: <code class="highlighter-rouge">InjectK</code> for free programs, by @tpolecat and @andyscott</li>
  <li><a href="https://github.com/typelevel/cats/pull/1602">#1602</a>: Stack-safe <code class="highlighter-rouge">Coyoneda</code>, by @edmundnoble</li>
  <li><a href="https://github.com/typelevel/cats/pull/1728">#1728</a>: <code class="highlighter-rouge">As</code> class which represents subtyping relationships (<code class="highlighter-rouge">Liskov</code>), by @stew</li>
  <li><a href="https://github.com/typelevel/cats/pull/1178">#1178</a>: <code class="highlighter-rouge">Is</code> constructor for Leibniz equality, by @tel</li>
  <li><a href="https://github.com/typelevel/cats/pull/1748">#1748</a>: Stack-safe <code class="highlighter-rouge">FreeApplicative</code>, by @edmundnoble</li>
  <li><a href="https://github.com/typelevel/cats/pull/1611">#1611</a>: <code class="highlighter-rouge">NonEmptyTraverse</code>. by @LukaJCB</li>
</ul>

<p>Overall 1.0.0-MF has over 120 merged pull requests of API additions, bug fixes, documentation and misc
improvements from 44 contributors. For the complete change list please go to the <a href="https://github.com/typelevel/cats/releases/tag/v1.0.0-MF">release notes</a>.</p>

<h3 id="migration">Migration</h3>
<p>There are more breaking changes in this release - we want to include as many necessary breaking changes as possible in this release
to reach stability. Please follow the <a href="https://github.com/typelevel/cats/blob/master/CHANGES.md#to-migrate-from-090">migration guide</a> from 0.9.0 in the  <a href="https://github.com/typelevel/cats/releases/tag/v1.0.0-MF">release notes</a>.</p>

<h3 id="whats-next">What’s next</h3>

<p>Although we made many improvements to the documentation in this release, it’s still by and large a WIP.
The next release 1.0.0-RC1 will focus documentation and API refinement based on community feedback.
RC1 is scheduled to be released in September. Unless the amount of bug fixes warrants a RC2, it’s likely that
we’ll release cats 1.0.0 within a couple weeks after RC1.</p>

<h3 id="credits">Credits</h3>
<p>Last but not least, many thanks to the contributors that make this release possible:</p>

<ul>
  <li>@alexandru</li>
  <li>@andyscott</li>
  <li>@BenFradet</li>
  <li>@Blaisorblade</li>
  <li>@cb372</li>
  <li>@ceedubs</li>
  <li>@cranst0n</li>
  <li>@DavidGregory084</li>
  <li>@denisftw</li>
  <li>@DieBauer</li>
  <li>@diesalbla</li>
  <li>@djspiewak</li>
  <li>@durban</li>
  <li>@edmundnoble</li>
  <li>@iravid</li>
  <li>@jtjeferreira</li>
  <li>@julien-truffaut</li>
  <li>@jyane</li>
  <li>@kailuowang</li>
  <li>@larsrh</li>
  <li>@Leammas</li>
  <li>@leandrob13</li>
  <li>@LukaJCB</li>
  <li>@markus1189</li>
  <li>@milessabin</li>
  <li>@n4to4</li>
  <li>@oskoi</li>
  <li>@peterneyens</li>
  <li>@PeterPerhac</li>
  <li>@raulraja</li>
  <li>@RawToast</li>
  <li>@sellout</li>
  <li>@stew</li>
  <li>@sullivan-</li>
  <li>@SystemFw</li>
  <li>@takayuky</li>
  <li>@tel</li>
  <li>@TomasMikula</li>
  <li>@tpolecat</li>
  <li>@wedens</li>
  <li>@xavier-fernandez</li>
  <li>@xuwei-k</li>
  <li>@yilinwei</li>
  <li>@zainab-ali</li>
</ul>

<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Fri, 04 Aug 2017 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2017/08/04/cats-1.0-mf.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2017/08/04/cats-1.0-mf.html</guid>
      </item>
    
      <item>
        <title>Validated Configurations with Ciris</title>
        
          <dc:creator>vlovgr</dc:creator>
                
        <description><![CDATA[<p>The need for configuration arises in almost every application, as we want to be able to run in different environments – for example, local, testing, and production environments. Configurations are also used as a way to keep secrets, like passwords and keys, out of source code and version control. By having configurations as untyped structured data in files, we can change and override settings without having to recompile our software.</p>

<p>In this blog post, we’ll take a look at configurations with configuration files, to see how we can make the loading process less error-prone, while overcoming obstacles with boilerplate, testing, and validation. We’ll also identify when it’s suitable to use Scala as a configuration language for improved compile-time safety, convenience, and flexibility; and more specifically, how <a href="https://cir.is">Ciris</a> helps out.</p>

<h3 id="configuration-files">Configuration Files</h3>
<p>Traditionally, configuration files, and libraries like <a href="https://github.com/typesafehub/config">Typesafe Config</a>, have been used to load configurations. This involves writing your configuration file, declaring values and how they’re loaded, and then writing very similar Scala code for loading that configuration. That kind of boilerplate code typically looks something along the lines of the following example.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">com.typesafe.config.</span><span class="o">{</span><span class="nc">Config</span><span class="o">,</span> <span class="nc">ConfigFactory</span><span class="o">}</span>

<span class="c1">// The settings class, wrapping Typesafe Config
</span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Settings</span><span class="o">(</span><span class="n">config</span><span class="k">:</span> <span class="kt">Config</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">object</span> <span class="nc">http</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">apiKey</span> <span class="k">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getString</span><span class="o">(</span><span class="s">"http.api-key"</span><span class="o">)</span>
    <span class="k">def</span> <span class="n">timeoutSeconds</span> <span class="k">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getInt</span><span class="o">(</span><span class="s">"http.timeout-seconds"</span><span class="o">)</span>
    <span class="k">def</span> <span class="n">port</span> <span class="k">=</span> <span class="n">config</span><span class="o">.</span><span class="n">getInt</span><span class="o">(</span><span class="s">"http.port"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// The configuration file, here represented in code
</span><span class="k">val</span> <span class="n">config</span> <span class="k">=</span>
  <span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">parseString</span><span class="o">(</span>
    <span class="s">"""
      |http {
      |  api-key = ${?API_KEY}
      |  timeout-seconds = 10
      |  port = 989
      |}
    """</span><span class="o">.</span><span class="n">stripMargin</span>
  <span class="o">).</span><span class="n">resolve</span><span class="o">()</span>

<span class="k">val</span> <span class="n">settings</span> <span class="k">=</span> <span class="nc">Settings</span><span class="o">(</span><span class="n">config</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">show</span><span class="o">(</span><span class="n">settings</span><span class="o">)</span>
<span class="c1">// Settings(Config(SimpleConfigObject({"http":{"port":989,"timeout-seconds":10}})))
</span></code></pre></div></div>

<p>This is a tedious, error-prone process that rarely sees any testing efforts. <a href="https://github.com/pureconfig/pureconfig">PureConfig</a> (and other libraries, like <a href="https://github.com/47deg/case-classy">Case Classy</a>) were created to remove that boilerplate. Using macros and conventions, they inspect your configuration model (nested case classes) and generate the necessary configuration loading code. This eliminates a lot of errors typically associated with configuration loading. Following is an example of how you can load that very same configuration with PureConfig.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">HttpSettings</span><span class="o">(</span>
  <span class="n">apiKey</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
  <span class="n">timeoutSeconds</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
  <span class="n">port</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">)</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Settings</span><span class="o">(</span><span class="n">http</span><span class="k">:</span> <span class="kt">HttpSettings</span><span class="o">)</span>

<span class="k">val</span> <span class="n">settings</span> <span class="k">=</span> <span class="n">pureconfig</span><span class="o">.</span><span class="n">loadConfig</span><span class="o">[</span><span class="kt">Settings</span><span class="o">](</span><span class="n">config</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">show</span><span class="o">(</span><span class="n">settings</span><span class="o">)</span>
<span class="c1">// Left(ConfigReaderFailures(KeyNotFound("http.api-key", None, Set()), List()))
</span></code></pre></div></div>

<h3 id="encoding-validation">Encoding Validation</h3>
<p>In both previous examples, we do not check whether our configurations are valid to use with our application. In the case of Typesafe Config, we hit a runtime exception if the key is missing or if the type conversion fails, and in PureConfig’s case, we will instead get a <code class="highlighter-rouge">ConfigReaderFailures</code>. But in neither case do we care what values are being loaded, as long as they can be converted to the appropriate types. For example, we might require a key of certain length and that it only contains certain characters, the timeout needs to be positive, and the port must be a non-system port number (value in the inclusive range between 1024 and 65535).</p>

<p>You could write an additional validation step to ensure the configuration is valid after it has been loaded – which can be tedious to write and requires testing. One could also argue that the types of the configuration values are too permissive: why use <code class="highlighter-rouge">String</code> for the key if you do not accept all <code class="highlighter-rouge">String</code> values? And why use an <code class="highlighter-rouge">Int</code> for timeout and port, if you only allow a limited subset of values?</p>

<p>We could write these custom types ourselves, including the validation logic, and tell PureConfig how to load them – which would be tedious to write for many types and would require testing. Another alternative is to use <a href="https://github.com/fthomas/refined">refined</a>, which allows you to do type-level refinements (apply predicates) to types. I found this approach so useful that I wrote a small integration between PureConfig and refined at the end of last year (see <a href="https://blog.vlovgr.se/posts/2016-12-24-refined-configuration.html">blog post</a>), so that PureConfig can now load refined’s types.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">eu.timepit.refined.api.Refined</span>
<span class="k">import</span> <span class="nn">eu.timepit.refined.numeric.Interval</span>
<span class="k">import</span> <span class="nn">eu.timepit.refined.pureconfig._</span>
<span class="k">import</span> <span class="nn">eu.timepit.refined.string.MatchesRegex</span>
<span class="k">import</span> <span class="nn">eu.timepit.refined.types.numeric.PosInt</span>
<span class="k">import</span> <span class="nn">eu.timepit.refined.W</span>

<span class="k">type</span> <span class="kt">ApiKey</span> <span class="o">=</span> <span class="nc">String</span> <span class="nc">Refined</span> <span class="nc">MatchesRegex</span><span class="o">[</span><span class="kt">W.`</span><span class="err">"</span><span class="o">[</span><span class="kt">a-zA-Z0-</span><span class="err">9</span><span class="o">]{</span><span class="err">25</span>,<span class="err">40</span><span class="o">}</span><span class="err">"</span><span class="kt">`.T</span><span class="o">]</span>

<span class="k">type</span> <span class="kt">NonSystemPort</span> <span class="o">=</span> <span class="nc">Int</span> <span class="nc">Refined</span> <span class="nc">Interval</span><span class="o">.</span><span class="nc">Closed</span><span class="o">[</span><span class="kt">W.`</span><span class="err">1024</span><span class="kt">`.T</span>, <span class="kt">W.`</span><span class="err">65535</span><span class="kt">`.T</span><span class="o">]</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">HttpSettings</span><span class="o">(</span>
  <span class="n">apiKey</span><span class="k">:</span> <span class="kt">ApiKey</span><span class="o">,</span>
  <span class="n">timeoutSeconds</span><span class="k">:</span> <span class="kt">PosInt</span><span class="o">,</span>
  <span class="n">port</span><span class="k">:</span> <span class="kt">NonSystemPort</span>
<span class="o">)</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Settings</span><span class="o">(</span><span class="n">http</span><span class="k">:</span> <span class="kt">HttpSettings</span><span class="o">)</span>

<span class="k">val</span> <span class="n">settings</span> <span class="k">=</span> <span class="n">pureconfig</span><span class="o">.</span><span class="n">loadConfig</span><span class="o">[</span><span class="kt">Settings</span><span class="o">](</span><span class="n">config</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">show</span><span class="o">(</span><span class="n">settings</span><span class="o">)</span>
<span class="c1">// Left(
//   ConfigReaderFailures(
//     KeyNotFound("http.api-key", None, Set()),
//     List(
//       CannotConvert(
//         "989",
//         "eu.timepit.refined.api.Refined[Int,eu.timepit.refined.boolean.And[eu.timepit.refined.boolean.Not[eu.timepit.refined.numeric.Less[Int(1024)]],eu.timepit.refined.boolean.Not[eu.timepit.refined.numeric.Greater[Int(65535)]]]]",
//         "Left predicate of (!(989 &lt; 1024) &amp;&amp; !(989 &gt; 65535)) failed: Predicate (989 &lt; 1024) did not fail.",
//         None,
//         "http.port"
//       )
//     )
//   )
// )
</span></code></pre></div></div>

<p>As you can see in the example above, refined already contains type aliases for many common refinement types, like <code class="highlighter-rouge">PosInt</code> (for <code class="highlighter-rouge">Int</code> values greater than zero). You can also easily define your own predicates, like the one for the key and port. The <code class="highlighter-rouge">W</code> here is a shorthand for <a href="https://github.com/milessabin/shapeless">shapeless</a>’ <code class="highlighter-rouge">Witness</code>: a way to encode literal-based singleton types (essentially, values on the type-level). If you’re using <a href="https://typelevel.org/scala/">Typelevel Scala</a> with the <code class="highlighter-rouge">-Yliteral-types</code> flag, you can write values directly in the type declaration, without having to use <code class="highlighter-rouge">Witness</code>.</p>

<p>If you’re not convinced configurations need to be validated, I can recommend reading the paper <a href="https://www.usenix.org/system/files/conference/osdi16/osdi16-xu.pdf">Early Detection of Configuration Errors to Reduce Failure Damage</a>, and to read through the slides of Leif Wickland’s (one of the authors behind PureConfig) recent presentation <a href="http://leifwickland.github.io/presentations/configBomb/">Defusing the Configuration Time Bomb</a> on the subject.</p>

<p>In many ways, think of configurations as user input – would you happily accept any values provided to your application from its users? Probably not: you would validate the input, and sanitize it if possible. Think about configurations in the same way, except that the user here might happen to be a developer of the application. The key here, as discussed in the paper linked above, is to check that your configuration is valid as soon as possible, ideally at compile-time, or as soon as the application starts. We want to avoid situations where we’re running the application and suddenly discover that configuration values are invalid or cannot be loaded – or worse, continue running with an invalid configuration, not to discover issues until much later on.</p>

<h3 id="improving-compile-time-safety">Improving Compile-time Safety</h3>
<p>We’ve now got a way to encode validation in the types of our configurations, and a boilerplate-free way of loading values of those types from configuration files – is there still room for improvement? To answer that question, we first need to ask why we are using configuration files in the first place.</p>

<p>Whether you thought about it or not, the main reason for using configuration files is so that we can change settings without having to recompile the software. In my experience, most developers default to using configuration files, and almost always change values by pushing commits to a version control repository. This is followed by a new release of the software, either manually or via a <a href="https://www.agilealliance.org/glossary/continuous-integration">continuous integration</a> system. In scenarios like this, and in general when it’s easy to change and release software (particularly when employing <a href="https://www.agilealliance.org/glossary/continuous-deployment/">continuous deployment</a> practices), configuration files are not used for the benefit of being able to change values without recompile.</p>

<p>In such cases, why are we not writing the configurations directly in source code? Christopher Vogt has written an excellent <a href="https://medium.com/@cvogt/scala-as-a-configuration-language-f075b058a660">blog post</a> (and given a <a href="https://www.youtube.com/watch?v=ox4IhIL6ojg">presentation</a>) on the subject. The tricky part here is managing values which need to be dynamic in the environment (like the port to bind) and are secret (like passwords and keys). Depending on your requirements and preferences, you more or less have two alternatives.</p>

<ul>
  <li>
    <p>If you know which environments your application will run in, and what the configuration values will be in those environments, you can just include the configurations in your application code (if it has no secrets), or store, compile, and bundle the configuration separately. If you have a requirement that secrets shouldn’t touch persistent storage, this might not be a feasible alternative. You might also appreciate the fact that all code relating to your application is in the same version control repository and gets compiled together, in which case this approach might not be suitable.</p>
  </li>
  <li>
    <p>Alternatively, you can include the configuration in your application, but load secrets and values which need to be dynamic from the environment during runtime. This is necessary when configuration values cannot be determined beforehand – because you do not know what environment your application will run in, or if you use a vault (like <a href="https://github.com/fugue/credstash">credstash</a>, for example) or a configuration service (like <a href="https://zookeeper.apache.org">ZooKeeper</a>, for example) – or if you prefer having your configuration together with your application code and in the same version control repository.</p>
  </li>
</ul>

<p>In this post, we’ll only focus on the latter case. While it’s possible to not use any libraries in the latter case, loading values from the environment typically means dealing with: different environments and configuration sources, type conversions, error handling, and validation. This is where <a href="https://cir.is">Ciris</a> comes in: a small library, dependency-free at its core, helping you to deal with all of that more easily.</p>

<h3 id="introducing-ciris">Introducing Ciris</h3>
<p>Imagine for the moment that no part of your configuration is secret and that your application only ever runs in one environment. You can then just write your configuration in code.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">eu.timepit.refined.auto._</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Config</span><span class="o">(</span>
  <span class="n">apiKey</span><span class="k">:</span> <span class="kt">ApiKey</span><span class="o">,</span>
  <span class="n">timeoutSeconds</span><span class="k">:</span> <span class="kt">PosInt</span><span class="o">,</span>
  <span class="n">port</span><span class="k">:</span> <span class="kt">NonSystemPort</span>
<span class="o">)</span>

<span class="k">val</span> <span class="n">config</span> <span class="k">=</span>
  <span class="nc">Config</span><span class="o">(</span>
    <span class="n">apiKey</span> <span class="k">=</span> <span class="s">"RacrqvWjuu4KVmnTG9b6xyZMTP7jnX"</span><span class="o">,</span>
    <span class="n">timeoutSeconds</span> <span class="k">=</span> <span class="mi">10</span><span class="o">,</span>
    <span class="n">port</span> <span class="k">=</span> <span class="mi">4000</span>
  <span class="o">)</span>
</code></pre></div></div>

<p>You then realize that it’s a bad idea to put the key in the source code, because source code can easily get into the wrong hands. You decide that you’ll instead read an environment variable for the key. Since you want to make sure that your configuration is valid, you have used refinement types, so you’ll have to make sure to check that the key conforms to the predicate. You would also welcome a helpful error message if the key is missing or invalid. This sounds like more work than it should be, so let’s see how <a href="https://cir.is">Ciris</a> can help us.</p>

<p>Ciris method for loading configurations is <code class="highlighter-rouge">loadConfig</code> and it works in two steps: first define what to load, and then how to load the configuration. For reading a key from an environment variable, you can use <code class="highlighter-rouge">env[ApiKey]("API_KEY")</code> which reads the environment variable <code class="highlighter-rouge">API_KEY</code> as an <code class="highlighter-rouge">ApiKey</code>. Ciris has a refined integration in a separate module, so you just need to add an appropriate import. Loading the configuration is then just a function accepting the loaded values as arguments.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">ciris._</span>
<span class="k">import</span> <span class="nn">ciris.refined._</span>

<span class="k">val</span> <span class="n">config</span> <span class="k">=</span>
  <span class="n">loadConfig</span><span class="o">(</span>
    <span class="n">env</span><span class="o">[</span><span class="kt">ApiKey</span><span class="o">](</span><span class="s">"API_KEY"</span><span class="o">)</span>
  <span class="o">)</span> <span class="o">{</span> <span class="n">apiKey</span> <span class="k">=&gt;</span>
    <span class="nc">Config</span><span class="o">(</span>
      <span class="n">apiKey</span> <span class="k">=</span> <span class="n">apiKey</span><span class="o">,</span>
      <span class="n">timeoutSeconds</span> <span class="k">=</span> <span class="mi">10</span><span class="o">,</span>
      <span class="n">port</span> <span class="k">=</span> <span class="mi">4000</span>
    <span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">show</span><span class="o">(</span><span class="n">config</span><span class="o">)</span>
<span class="c1">// Left(ConfigErrors(MissingKey(API_KEY, Environment)))
</span></code></pre></div></div>

<p>Ciris deals with type conversions, error handling, and error accumulation, so you can focus on your configuration. The <code class="highlighter-rouge">loadConfig</code> method returns an <code class="highlighter-rouge">Either[ConfigErrors, T]</code> instance back, where <code class="highlighter-rouge">T</code> is the result of your configuration loading function. You can retrieve the accumulated error messages by using <code class="highlighter-rouge">messages</code> on <code class="highlighter-rouge">ConfigErrors</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">show</span> <span class="o">{</span> <span class="n">config</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">messages</span><span class="o">)</span> <span class="o">}</span>
<span class="c1">// Left(Vector("Missing environment variable [API_KEY]"))
</span></code></pre></div></div>

<p>If we decided that the port needs to be dynamic as well, we can simply make that change. In the example below, we are using <code class="highlighter-rouge">prop</code> to read the <code class="highlighter-rouge">http.port</code> system property for the port to use. As you can see, you are free to mix configuration sources as you please. While we are reading environment variables and system properties in these examples, you could just as well use sources for some configuration services or vaults.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">config</span> <span class="k">=</span>
  <span class="n">loadConfig</span><span class="o">(</span>
    <span class="n">env</span><span class="o">[</span><span class="kt">ApiKey</span><span class="o">](</span><span class="s">"API_KEY"</span><span class="o">),</span>
    <span class="n">prop</span><span class="o">[</span><span class="kt">NonSystemPort</span><span class="o">](</span><span class="s">"http.port"</span><span class="o">)</span>
  <span class="o">)</span> <span class="o">{</span> <span class="o">(</span><span class="n">apiKey</span><span class="o">,</span> <span class="n">port</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nc">Config</span><span class="o">(</span>
      <span class="n">apiKey</span> <span class="k">=</span> <span class="n">apiKey</span><span class="o">,</span>
      <span class="n">timeoutSeconds</span> <span class="k">=</span> <span class="mi">10</span><span class="o">,</span>
      <span class="n">port</span> <span class="k">=</span> <span class="n">port</span>
    <span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">show</span> <span class="o">{</span> <span class="n">config</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">messages</span><span class="o">)</span> <span class="o">}</span>
<span class="c1">// Left(
//   Vector(
//     "Missing environment variable [API_KEY]",
//     "Missing system property [http.port]"
//   )
// )
</span></code></pre></div></div>

<p>You might recognize the similarities between <code class="highlighter-rouge">loadConfig</code> and <code class="highlighter-rouge">ValidatedNel</code> with an <code class="highlighter-rouge">Apply</code> instance from <a href="https://typelevel.org/cats/">Cats</a>. That’s because it’s more or less how <code class="highlighter-rouge">loadConfig</code> works behind the scenes, except Ciris has its own custom implementation in order to be dependency-free in the core module.</p>

<h4 id="multiple-environments">Multiple Environments</h4>
<p>We still have to deal with multiple environments in our configuration, assuming there are differences between configurations, or how they are loaded, in the different environments. There are several ways you can do this with Ciris – one way is to define an enumeration with <a href="https://github.com/lloydmeta/enumeratum">enumeratum</a> and load values of that enumeration. Let’s say we want to use a default configuration when running the application locally, but want to keep the key and port dynamic in the other environments (testing and production). We start by defining an enumeration of the different environments.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">_root_.enumeratum._</span>

<span class="k">object</span> <span class="nc">environments</span> <span class="o">{</span>
  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">AppEnvironment</span> <span class="k">extends</span> <span class="nc">EnumEntry</span>
  <span class="k">object</span> <span class="nc">AppEnvironment</span> <span class="k">extends</span> <span class="nc">Enum</span><span class="o">[</span><span class="kt">AppEnvironment</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">object</span> <span class="nc">Local</span> <span class="k">extends</span> <span class="nc">AppEnvironment</span>
    <span class="k">case</span> <span class="k">object</span> <span class="nc">Testing</span> <span class="k">extends</span> <span class="nc">AppEnvironment</span>
    <span class="k">case</span> <span class="k">object</span> <span class="nc">Production</span> <span class="k">extends</span> <span class="nc">AppEnvironment</span>

    <span class="k">val</span> <span class="n">values</span> <span class="k">=</span> <span class="n">findValues</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We can use the <code class="highlighter-rouge">withValue</code> method to define a requirement on a configuration value in order to be able to load our configuration. It works just like <code class="highlighter-rouge">loadConfig</code>, except it wraps your <code class="highlighter-rouge">loadConfig</code> statements (think of it as <code class="highlighter-rouge">flatMap</code>, while <code class="highlighter-rouge">loadConfig</code> is <code class="highlighter-rouge">map</code>). If no environment was specified in the environment variable <code class="highlighter-rouge">APP_ENV</code> or if it was set to <code class="highlighter-rouge">Local</code>, we will use a default configuration. We’ll load the configuration just like before for any other valid environments (testing and production).</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">environments._</span>
<span class="k">import</span> <span class="nn">ciris.enumeratum._</span>

<span class="k">val</span> <span class="n">config</span> <span class="k">=</span>
  <span class="n">withValue</span><span class="o">(</span><span class="n">env</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">AppEnvironment</span><span class="o">]](</span><span class="s">"APP_ENV"</span><span class="o">))</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">AppEnvironment</span><span class="o">.</span><span class="nc">Local</span><span class="o">)</span> <span class="o">|</span> <span class="nc">None</span> <span class="k">=&gt;</span>
      <span class="n">loadConfig</span> <span class="o">{</span>
        <span class="nc">Config</span><span class="o">(</span>
          <span class="n">apiKey</span> <span class="k">=</span> <span class="s">"RacrqvWjuu4KVmnTG9b6xyZMTP7jnX"</span><span class="o">,</span>
          <span class="n">timeoutSeconds</span> <span class="k">=</span> <span class="mi">10</span><span class="o">,</span>
          <span class="n">port</span> <span class="k">=</span> <span class="mi">4000</span>
        <span class="o">)</span>
      <span class="o">}</span>

    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="n">loadConfig</span><span class="o">(</span>
        <span class="n">env</span><span class="o">[</span><span class="kt">ApiKey</span><span class="o">](</span><span class="s">"API_KEY"</span><span class="o">),</span>
        <span class="n">prop</span><span class="o">[</span><span class="kt">NonSystemPort</span><span class="o">](</span><span class="s">"http.port"</span><span class="o">)</span>
      <span class="o">)</span> <span class="o">{</span> <span class="o">(</span><span class="n">apiKey</span><span class="o">,</span> <span class="n">port</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nc">Config</span><span class="o">(</span>
          <span class="n">apiKey</span> <span class="k">=</span> <span class="n">apiKey</span><span class="o">,</span>
          <span class="n">timeoutSeconds</span> <span class="k">=</span> <span class="mi">10</span><span class="o">,</span>
          <span class="n">port</span> <span class="k">=</span> <span class="n">port</span>
        <span class="o">)</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">show</span><span class="o">(</span><span class="n">config</span><span class="o">)</span>
<span class="c1">// Right(Config(RacrqvWjuu4KVmnTG9b6xyZMTP7jnX, 10, 4000))
</span></code></pre></div></div>

<p>An alternative to the above is to have multiple entrypoints (<code class="highlighter-rouge">main</code> methods) in your application, each running the application with different configuration loading code (or using a default configuration) for the respective environment. Depending on how packaging and running of your application looks like across different environments, this may or may not be a suitable solution. Note that it’s very much possible to mix these approaches, and you should strive to find what works best in your case.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Runs the application with the provided configuration
</span><span class="k">def</span> <span class="n">runApplication</span><span class="o">(</span><span class="n">config</span><span class="k">:</span> <span class="kt">Config</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span> <span class="cm">/* omitted */</span> <span class="o">}</span>

<span class="k">object</span> <span class="nc">Local</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="n">runApplication</span> <span class="o">{</span>
      <span class="nc">Config</span><span class="o">(</span>
        <span class="n">apiKey</span> <span class="k">=</span> <span class="s">"RacrqvWjuu4KVmnTG9b6xyZMTP7jnX"</span><span class="o">,</span>
        <span class="n">timeoutSeconds</span> <span class="k">=</span> <span class="mi">10</span><span class="o">,</span>
        <span class="n">port</span> <span class="k">=</span> <span class="mi">4000</span>
      <span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">TestingOrProduction</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="n">runApplication</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">config</span> <span class="k">=</span>
        <span class="n">loadConfig</span><span class="o">(</span>
          <span class="n">env</span><span class="o">[</span><span class="kt">ApiKey</span><span class="o">](</span><span class="s">"API_KEY"</span><span class="o">),</span>
          <span class="n">prop</span><span class="o">[</span><span class="kt">NonSystemPort</span><span class="o">](</span><span class="s">"http.port"</span><span class="o">)</span>
        <span class="o">)</span> <span class="o">{</span> <span class="o">(</span><span class="n">apiKey</span><span class="o">,</span> <span class="n">port</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="nc">Config</span><span class="o">(</span>
            <span class="n">apiKey</span> <span class="k">=</span> <span class="n">apiKey</span><span class="o">,</span>
            <span class="n">timeoutSeconds</span> <span class="k">=</span> <span class="mi">10</span><span class="o">,</span>
            <span class="n">port</span> <span class="k">=</span> <span class="n">port</span>
          <span class="o">)</span>
        <span class="o">}</span>

      <span class="n">config</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span>
        <span class="n">errors</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="n">s</span><span class="s">"Unable to load configuration: ${errors.messages}"</span><span class="o">),</span>
        <span class="n">identity</span>
      <span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="testing-configurations">Testing Configurations</h4>
<p>Writing your configurations in Scala means you have the flexibility to work with them as you want. You’re no longer limited to what can be done with configuration files. Sharing configurations between your application and tests is also very straightforward – simply make the configuration loading function (and the default configuration) available for the tests.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This can now be accessed from the tests
</span><span class="k">val</span> <span class="n">defaultConfig</span> <span class="k">=</span>
  <span class="nc">Config</span><span class="o">(</span>
    <span class="n">apiKey</span> <span class="k">=</span> <span class="s">"RacrqvWjuu4KVmnTG9b6xyZMTP7jnX"</span><span class="o">,</span>
    <span class="n">timeoutSeconds</span> <span class="k">=</span> <span class="mi">10</span><span class="o">,</span>
    <span class="n">port</span> <span class="k">=</span> <span class="mi">4000</span>
  <span class="o">)</span>

<span class="c1">// This can now be accessed from the tests
</span><span class="k">val</span> <span class="n">configWith</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">apiKey</span><span class="k">:</span> <span class="kt">ApiKey</span><span class="o">,</span> <span class="n">port</span><span class="k">:</span> <span class="kt">NonSystemPort</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nc">Config</span><span class="o">(</span>
      <span class="n">apiKey</span> <span class="k">=</span> <span class="n">apiKey</span><span class="o">,</span>
      <span class="n">timeoutSeconds</span> <span class="k">=</span> <span class="mi">10</span><span class="o">,</span>
      <span class="n">port</span> <span class="k">=</span> <span class="n">port</span>
    <span class="o">)</span>

<span class="k">val</span> <span class="n">config</span> <span class="k">=</span>
  <span class="n">withValue</span><span class="o">(</span><span class="n">env</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">AppEnvironment</span><span class="o">]](</span><span class="s">"APP_ENV"</span><span class="o">))</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">AppEnvironment</span><span class="o">.</span><span class="nc">Local</span><span class="o">)</span> <span class="o">|</span> <span class="nc">None</span> <span class="k">=&gt;</span>
      <span class="n">loadConfig</span><span class="o">(</span><span class="n">defaultConfig</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="n">loadConfig</span><span class="o">(</span>
        <span class="n">env</span><span class="o">[</span><span class="kt">ApiKey</span><span class="o">](</span><span class="s">"API_KEY"</span><span class="o">),</span>
        <span class="n">prop</span><span class="o">[</span><span class="kt">NonSystemPort</span><span class="o">](</span><span class="s">"http.port"</span><span class="o">)</span>
      <span class="o">)(</span><span class="n">configWith</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>If you really want to unit test the configuration loading as well, you can do so with minor rewrites. Currently, we depend on some fixed configuration sources for environment variables and system properties (technically, system properties are mutable), but if we instead pass sources (<code class="highlighter-rouge">ConfigSource</code>s) as arguments, we can read values from those sources using the <code class="highlighter-rouge">read</code> method.</p>

<p>The <code class="highlighter-rouge">read</code> method normally looks for an implicit <code class="highlighter-rouge">ConfigSource</code> to read from, which would have been perfect if we only used a single source. But since we have multiple sources here, we instead use <code class="highlighter-rouge">read</code> to redefine <code class="highlighter-rouge">env</code> and <code class="highlighter-rouge">prop</code> to read from the provided sources. <code class="highlighter-rouge">ConfigReader[T]</code> captures the ability to convert from <code class="highlighter-rouge">String</code> to <code class="highlighter-rouge">T</code>, where the <code class="highlighter-rouge">String</code> value has been read from a <code class="highlighter-rouge">ConfigSource</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">config</span><span class="o">(</span>
  <span class="n">envs</span><span class="k">:</span> <span class="kt">ConfigSource</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span>
  <span class="n">props</span><span class="k">:</span> <span class="kt">ConfigSource</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">ConfigErrors</span>, <span class="kt">Config</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="c1">// Custom env which reads from envs
</span>  <span class="k">def</span> <span class="n">env</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">ConfigReader</span><span class="o">](</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">read</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">key</span><span class="o">)(</span><span class="n">envs</span><span class="o">,</span> <span class="nc">ConfigReader</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>

  <span class="c1">// Custom prop which reads from props
</span>  <span class="k">def</span> <span class="n">prop</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">ConfigReader</span><span class="o">](</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">read</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">key</span><span class="o">)(</span><span class="n">props</span><span class="o">,</span> <span class="nc">ConfigReader</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>

  <span class="n">withValue</span><span class="o">(</span><span class="n">env</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">AppEnvironment</span><span class="o">]](</span><span class="s">"APP_ENV"</span><span class="o">))</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">AppEnvironment</span><span class="o">.</span><span class="nc">Local</span><span class="o">)</span> <span class="o">|</span> <span class="nc">None</span> <span class="k">=&gt;</span>
      <span class="n">loadConfig</span><span class="o">(</span><span class="n">defaultConfig</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="n">loadConfig</span><span class="o">(</span>
        <span class="n">env</span><span class="o">[</span><span class="kt">ApiKey</span><span class="o">](</span><span class="s">"API_KEY"</span><span class="o">),</span>
        <span class="n">prop</span><span class="o">[</span><span class="kt">NonSystemPort</span><span class="o">](</span><span class="s">"http.port"</span><span class="o">)</span>
      <span class="o">)(</span><span class="n">configWith</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We’ll then define a couple of helper methods for creating <code class="highlighter-rouge">ConfigSource</code>s from key-value pairs. The <code class="highlighter-rouge">ConfigSource</code> type parameter is the type of keys the source can read, which is <code class="highlighter-rouge">String</code> for both environment variables and system properties. The <code class="highlighter-rouge">ConfigKeyType</code> is basically the name of the key that can be read, for example <code class="highlighter-rouge">environment variable</code>. Below we’re using predefined instances in the <code class="highlighter-rouge">ConfigKeyType</code> companion object.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">envs</span><span class="o">(</span><span class="n">entries</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">String</span><span class="o">)*)</span><span class="k">:</span> <span class="kt">ConfigSource</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">ConfigSource</span><span class="o">.</span><span class="n">fromMap</span><span class="o">(</span><span class="nc">ConfigKeyType</span><span class="o">.</span><span class="nc">Environment</span><span class="o">)(</span><span class="n">entries</span><span class="o">.</span><span class="n">toMap</span><span class="o">)</span>

<span class="k">def</span> <span class="n">props</span><span class="o">(</span><span class="n">entries</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">String</span><span class="o">)*)</span><span class="k">:</span> <span class="kt">ConfigSource</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">ConfigSource</span><span class="o">.</span><span class="n">fromMap</span><span class="o">(</span><span class="nc">ConfigKeyType</span><span class="o">.</span><span class="nc">Property</span><span class="o">)(</span><span class="n">entries</span><span class="o">.</span><span class="n">toMap</span><span class="o">)</span>
</code></pre></div></div>

<p>We can test our <code class="highlighter-rouge">config</code> method using different combinations of environment variables and system properties. Note that <code class="highlighter-rouge">envs</code> and <code class="highlighter-rouge">props</code> have the same type, so if you want to avoid using them interchangeably, you can define custom wrapper types for them. We’ll leave that out here for sake of simplicity. I’ve found that it’s not very common to read values from more than one <code class="highlighter-rouge">ConfigSource</code>, but as it’s definitely possible, it can be worth making sure you do not mix them up.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">show</span> <span class="o">{</span> <span class="n">config</span><span class="o">(</span><span class="n">envs</span><span class="o">(),</span> <span class="n">props</span><span class="o">())</span> <span class="o">}</span>
<span class="c1">// Right(Config(RacrqvWjuu4KVmnTG9b6xyZMTP7jnX, 10, 4000))
</span>
<span class="n">show</span> <span class="o">{</span>
  <span class="n">config</span><span class="o">(</span>
    <span class="n">envs</span><span class="o">(</span><span class="s">"APP_ENV"</span> <span class="o">-&gt;</span> <span class="s">"Local"</span><span class="o">),</span>
    <span class="n">props</span><span class="o">()</span>
  <span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Right(Config(RacrqvWjuu4KVmnTG9b6xyZMTP7jnX, 10, 4000))
</span>
<span class="n">show</span> <span class="o">{</span>
  <span class="n">config</span><span class="o">(</span>
    <span class="n">envs</span><span class="o">(</span><span class="s">"APP_ENV"</span> <span class="o">-&gt;</span> <span class="s">"QA"</span><span class="o">),</span>
    <span class="n">props</span><span class="o">()</span>
  <span class="o">).</span><span class="n">left</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">messages</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Left(
//   Vector(
//     "Environment variable [APP_ENV] with value [QA] cannot be converted to type [$line34.$read$$iw$$iw$$iw$$iw$$iw$$iw$$iw$$iw$$iw$$iw$$iw$$iw$environments$AppEnvironment]"
//   )
// )
</span>
<span class="n">show</span> <span class="o">{</span>
  <span class="n">config</span><span class="o">(</span>
    <span class="n">envs</span><span class="o">(</span><span class="s">"APP_ENV"</span> <span class="o">-&gt;</span> <span class="s">"Production"</span><span class="o">),</span>
    <span class="n">props</span><span class="o">()</span>
  <span class="o">).</span><span class="n">left</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">messages</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Left(
//   Vector(
//     "Missing environment variable [API_KEY]",
//     "Missing system property [http.port]"
//   )
// )
</span>
<span class="n">show</span> <span class="o">{</span>
  <span class="n">config</span><span class="o">(</span>
    <span class="n">envs</span><span class="o">(</span>
      <span class="s">"APP_ENV"</span> <span class="o">-&gt;</span> <span class="s">"Production"</span><span class="o">,</span>
      <span class="s">"API_KEY"</span> <span class="o">-&gt;</span> <span class="s">"changeme"</span>
    <span class="o">),</span>
    <span class="n">props</span><span class="o">()</span>
  <span class="o">).</span><span class="n">left</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">messages</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Left(
//   Vector(
//     "Environment variable [API_KEY] with value [changeme] cannot be converted to type [eu.timepit.refined.api.Refined[String,eu.timepit.refined.string.MatchesRegex[java.lang.String(\"[a-zA-Z0-9]{25,40}\")]]]: Predicate failed: \"changeme\".matches(\"[a-zA-Z0-9]{25,40}\").",
//     "Missing system property [http.port]"
//   )
// )
</span>
<span class="n">show</span> <span class="o">{</span>
  <span class="n">config</span><span class="o">(</span>
    <span class="n">envs</span><span class="o">(</span>
      <span class="s">"APP_ENV"</span> <span class="o">-&gt;</span> <span class="s">"Production"</span><span class="o">,</span>
      <span class="s">"API_KEY"</span> <span class="o">-&gt;</span> <span class="s">"X9aKACPtircCrrFKYhwPr7fXx8srow"</span>
    <span class="o">),</span>
    <span class="n">props</span><span class="o">()</span>
  <span class="o">).</span><span class="n">left</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">messages</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Left(Vector("Missing system property [http.port]"))
</span>
<span class="n">show</span> <span class="o">{</span>
  <span class="n">config</span><span class="o">(</span>
    <span class="n">envs</span><span class="o">(</span>
      <span class="s">"APP_ENV"</span> <span class="o">-&gt;</span> <span class="s">"Production"</span><span class="o">,</span>
      <span class="s">"API_KEY"</span> <span class="o">-&gt;</span> <span class="s">"X9aKACPtircCrrFKYhwPr7fXx8srow"</span>
    <span class="o">),</span>
    <span class="n">props</span><span class="o">(</span><span class="s">"http.port"</span> <span class="o">-&gt;</span> <span class="s">"900"</span><span class="o">)</span>
  <span class="o">).</span><span class="n">left</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">messages</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Left(
//   Vector(
//     "System property [http.port] with value [900] cannot be converted to type [eu.timepit.refined.api.Refined[Int,eu.timepit.refined.numeric.Interval.Closed[Int(1024),Int(65535)]]]: Left predicate of (!(900 &lt; 1024) &amp;&amp; !(900 &gt; 65535)) failed: Predicate (900 &lt; 1024) did not fail."
//   )
// )
</span>
<span class="n">show</span> <span class="o">{</span>
  <span class="n">config</span><span class="o">(</span>
    <span class="n">envs</span><span class="o">(</span>
      <span class="s">"APP_ENV"</span> <span class="o">-&gt;</span> <span class="s">"Production"</span><span class="o">,</span>
      <span class="s">"API_KEY"</span> <span class="o">-&gt;</span> <span class="s">"X9aKACPtircCrrFKYhwPr7fXx8srow"</span>
    <span class="o">),</span>
    <span class="n">props</span><span class="o">(</span><span class="s">"http.port"</span> <span class="o">-&gt;</span> <span class="s">"4000"</span><span class="o">)</span>
  <span class="o">)</span>
<span class="o">}</span>
<span class="c1">// Right(Config(X9aKACPtircCrrFKYhwPr7fXx8srow, 10, 4000))
</span></code></pre></div></div>

<p>Finally, when running the application, simply provide the actual <code class="highlighter-rouge">ConfigSource</code>s for environment variables and system properties.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">show</span> <span class="o">{</span> <span class="n">config</span><span class="o">(</span><span class="nc">ConfigSource</span><span class="o">.</span><span class="nc">Environment</span><span class="o">,</span> <span class="nc">ConfigSource</span><span class="o">.</span><span class="nc">Properties</span><span class="o">)</span> <span class="o">}</span>
<span class="c1">// Right(Config(RacrqvWjuu4KVmnTG9b6xyZMTP7jnX, 10, 4000))
</span></code></pre></div></div>

<h3 id="conclusion">Conclusion</h3>
<p>In this blog post, we’ve seen how we can make the configuration loading process, with configuration files, less error-prone, by eliminating the boilerplate code with <a href="https://github.com/pureconfig/pureconfig">PureConfig</a>, and encoding validation with <a href="https://github.com/fthomas/refined">refined</a> – seeing how the two libraries can work together seamlessly.</p>

<p>We’ve also identified cases where we can use Scala as a configuration language, seeing that it’s particularly suitable in cases where it’s easy to change and deploy software. We’ve introduced the challenge of loading configuration values from the environment and seen how <a href="https://cir.is">Ciris</a> can help you with that, letting you focus on the configuration. We’ve seen that Scala configurations can provide more compile-time safety and flexibility than traditional configurations with configuration files.</p>

<p>If you’re looking for more information on Ciris, the project’s website (<a href="https://cir.is">https://cir.is</a>) is a good start.<br />
There’s also a <a href="https://cir.is/docs/basics">usage guide</a> and <a href="https://cir.is/api">API documentation</a> which expands on what’s been discussed here.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 21 Jun 2017 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2017/06/21/ciris.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2017/06/21/ciris.html</guid>
      </item>
    
      <item>
        <title>Compile time dimensional analysis with Libra</title>
        
          <dc:creator>zainabali</dc:creator>
                
        <description><![CDATA[<h2 id="dimensional-analysis">Dimensional analysis</h2>

<p>When we code, we code in numbers - doubles, floats and ints.  Those numbers always represent real world quantities.</p>

<p>For example, the number of people in a room can be represented as an integer, as can the number of chairs.
Adding people and chairs together gives a nonsensical result, but dividing the number of people by the number of chairs gives a useful indicator of how full up the room is.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">numberOfPeople</span> <span class="k">=</span> <span class="mi">9</span>
<span class="k">val</span> <span class="n">numberOfChairs</span> <span class="k">=</span> <span class="mi">10</span>
<span class="n">numberOfPeople</span> <span class="o">+</span> <span class="n">numberOfChairs</span> <span class="c1">// this is a bug
</span><span class="n">numberOfPeople</span><span class="o">.</span><span class="n">toDouble</span> <span class="o">/</span> <span class="n">numberOfChairs</span><span class="o">.</span><span class="n">toDouble</span> <span class="c1">// this is useful
</span></code></pre></div></div>

<p>This is actually a form of dimensional analysis.  We’re mentally assigning the dimension <code class="highlighter-rouge">Person</code> to the quantity of people, and <code class="highlighter-rouge">Chair</code> to the quantity of chairs.  Dimensional analysis can be summarized in two laws.</p>

<ol>
  <li>Quantities can only be added or subtracted to quantities of the same dimension</li>
  <li>Quantities of different dimensions can be multiplied or divided</li>
</ol>

<h3 id="why-is-it-important">Why is it important?</h3>

<p>Ignoring the laws can result in serious problems. 
Take the Mars Climate Orbiter, a $200 million space probe which successfully reached Mars after a year long voyage, but suddenly crashed into the Martian atmosphere on arrival.  Most components on the orbiter were using metric units, however a single component was sending instructions in Imperial units.  The other components did not detect this, and instead began a sudden descent causing the orbiter to burn up.  This was a simple unit conversion error!  It was a basic mistake that could have been easily avoided.  It should have been picked up during testing, or in the runtime validation layer.</p>

<p>In fact, it could even have been caught at compile time.</p>

<h3 id="compile-time-dimensional-analysis">Compile time dimensional analysis</h3>

<p>We’re going to use a similar problem to demonstrate compile time dimensional analysis.
To fit with the theme of rocket physics, we will tackle a rocket launch towards the distant constellation of Libra.
We’ll begin by working through our calculation in doubles before adding compile time safety with dependent types and finally supporting compile time dimensional analysis with typeclass induction.</p>

<h2 id="destination-alpha-librae">Destination: Alpha Librae</h2>

<p>The star that we’re aiming for is Alpha Librae.  This is pretty far, so we can only send one very small person.  We have been given the following quantities to work with:</p>

<ul>
  <li>rocket mass of a small person - 40kg</li>
  <li>fuel mass of a lot of fuel - 10<sup>4</sup>kg</li>
  <li>exhaust speed of a decent fuel - 10<sup>6</sup>ms<sup>-1</sup></li>
  <li>distance to Alpha Librae - 77 ly</li>
</ul>

<p>We want to calculate when the rocket will arrive.</p>

<p>To do so, we’re going to make use of a formula known as the <em>Ideal Rocket Equation</em>.
This calculates the speed of a rocket in ideal conditions.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">rocketSpeed</span> <span class="k">=</span> <span class="n">exhaustSpeed</span> <span class="o">*</span> <span class="n">log</span><span class="o">((</span><span class="n">rocketMass</span> <span class="o">+</span> <span class="n">fuelMass</span><span class="o">)</span> <span class="o">/</span> <span class="n">rocketMass</span><span class="o">)</span>
</code></pre></div></div>
<p>Once we have the speed, we can work out the travel time.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">time</span> <span class="k">=</span> <span class="n">distance</span> <span class="o">/</span> <span class="n">rocketSpeed</span>
</code></pre></div></div>

<h3 id="plugging-the-numbers-in">Plugging the numbers in</h3>

<p>Let’s do what we’re used to doing and use doubles:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">rocketSpeed</span> <span class="k">=</span> <span class="mf">1000000.0</span> <span class="o">*</span> <span class="n">log</span><span class="o">((</span><span class="mf">40.0</span> <span class="o">+</span> <span class="mf">10000.0</span><span class="o">)</span> <span class="o">/</span> <span class="mf">40.0</span><span class="o">)</span>
<span class="c1">// rocketSpeed: Double = 5525452.939131783
</span>
<span class="k">val</span> <span class="n">time</span> <span class="k">=</span> <span class="mf">77.0</span> <span class="o">/</span> <span class="n">rocketSpeed</span>
<span class="c1">// time: Double = 1.39355091515989E-5
</span></code></pre></div></div>

<p>Fantastic! We can get to Libra in less than a day!</p>

<p>Unfortunately, this time estimate is too far off to be valid.  We can’t get to Libra that quickly at light speed, let alone rocket speed.  We’ve clearly made a mistake somewhere.  Instead of pouring over our code to find out where that is, let’s try and use the compiler.</p>

<h3 id="using-types">Using types</h3>

<p>We can add some type safety to this problem by using a case class to represent each quantity.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">A</code> represents the quantity dimension. So given the following dimensions:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Kilogram</span>
<span class="k">type</span> <span class="kt">Metre</span>
<span class="k">type</span> <span class="kt">Second</span>
<span class="k">type</span> <span class="kt">MetresPerSecond</span>
<span class="k">type</span> <span class="kt">C</span>
<span class="k">type</span> <span class="kt">LightYear</span>
<span class="k">type</span> <span class="kt">Year</span>
</code></pre></div></div>

<p>We can create quantities:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">rocketMass</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">Kilogram</span><span class="o">](</span><span class="mf">40.0</span><span class="o">)</span>
<span class="k">val</span> <span class="n">fuelMass</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">Kilogram</span><span class="o">](</span><span class="mf">10000.0</span><span class="o">)</span>
<span class="k">val</span> <span class="n">exhaust</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">MetresPerSecond</span><span class="o">](</span><span class="mf">1000000.0</span><span class="o">)</span>
<span class="k">val</span> <span class="n">distance</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">LightYear</span><span class="o">](</span><span class="mf">77.0</span><span class="o">)</span>
</code></pre></div></div>

<p>It’s important to note that these are <em>types</em>, not classes.  We never instantiate a <code class="highlighter-rouge">MetresPerSecond</code> - we’re just using it to differentiate between <code class="highlighter-rouge">Quantity[MetresPerSecond]</code> and <code class="highlighter-rouge">Quantity[Year]</code> at the type level.</p>

<p>So how does this change the code?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">rocketSpeed</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">MetresPerSecond</span><span class="o">](</span><span class="n">exhaust</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">log</span><span class="o">((</span><span class="n">rocketMass</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">fuelMass</span><span class="o">.</span><span class="n">value</span><span class="o">)</span> <span class="o">/</span> <span class="n">rocketMass</span><span class="o">.</span><span class="n">value</span><span class="o">))</span>
<span class="c1">// rocketSpeed: Quantity[Types.MetresPerSecond] = Quantity(5525452.939131783)
</span>
<span class="k">val</span> <span class="n">time</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">Year</span><span class="o">](</span><span class="n">distance</span><span class="o">.</span><span class="n">value</span> <span class="o">/</span> <span class="n">rocketSpeed</span><span class="o">.</span><span class="n">value</span><span class="o">)</span>
<span class="c1">// time: Quantity[Types.Year] = Quantity(1.39355091515989E-5)
</span></code></pre></div></div>

<p>In short, it doesn’t. The code might be clearer, but we don’t know what the bug is.  This is because the compiler isn’t doing anything with the types we’ve added.</p>

<h3 id="operating-on-quantities">Operating on quantities</h3>

<p>We can encode our first law of addition at compile time by creating a function to add quantities:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">add</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">q0</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">q1</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">(</span><span class="n">q0</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">q1</span><span class="o">.</span><span class="n">value</span><span class="o">)</span>
</code></pre></div></div>

<p>This ensures that quantities can only be added to other quantities of the same type.  Trying to add quantities of different types will result in a compilation error.</p>

<p>A quantity can also be multiplied by a dimensionless scalar value to give a quantity of the same dimension.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">times</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">q</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">v</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">v</span><span class="o">)</span>
</code></pre></div></div>

<p>It would be great if we could divide quantities too.  Writing a divide function is more difficult:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">divide</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">Magic</span><span class="o">](</span><span class="n">q0</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">q1</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">Magic</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Quantity</span><span class="o">[</span><span class="kt">Magic</span><span class="o">](</span><span class="n">q0</span><span class="o">.</span><span class="n">value</span> <span class="o">/</span> <span class="n">q1</span><span class="o">.</span><span class="n">value</span><span class="o">)</span>
</code></pre></div></div>

<p>There’s a clear problem with trying to do this.  When we divide a quantity by another, we don’t know what the <code class="highlighter-rouge">Magic</code> output type should be.
The output type is dependent on what the input types are (for example, dividing <code class="highlighter-rouge">Metre</code> by <code class="highlighter-rouge">Second</code> should give <code class="highlighter-rouge">MetresPerSecond</code>).  The compiler needs a way of working out what the output is, provided that it knows the input types.</p>

<h3 id="dependent-types">Dependent types</h3>

<p>What we actually want is a dependent type.  A division operation should occur at the type level, taking two input types and supplying a dependent output type.
We can create the trait <code class="highlighter-rouge">Divide</code> with a dependent output type:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Divide</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Out</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We also need to define an <code class="highlighter-rouge">Aux</code> type alias.  This is known as the Aux pattern and makes it easier to refer to all three types at once.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Divide</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Aux</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">Out0</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Divide</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">Out0</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We can create instances of this divide typeclass with different output types, so the output type is dependent on the value of the divide typeclass instance.</p>

<p>When dividing, the compiler looks for this implicit typeclass instance and returns a quantity corresponding to the output type.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">divide</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">q0</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">q1</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Divide</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">d.Out</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Quantity</span><span class="o">[</span><span class="kt">d.Out</span><span class="o">](</span><span class="n">q0</span><span class="o">.</span><span class="n">value</span> <span class="o">/</span> <span class="n">q1</span><span class="o">.</span><span class="n">value</span><span class="o">)</span>
</code></pre></div></div>

<p>So given that we want to divide <code class="highlighter-rouge">A</code> by <code class="highlighter-rouge">B</code>, the compiler will look for a value of <code class="highlighter-rouge">Divide[A, B]</code> and find the <code class="highlighter-rouge">Out</code> type of it.  If no instance exists, the code doesn’t compile.</p>

<p>We’ll need some more types to represent the result of a division:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">LightYearSecondsPerMetre</span>
<span class="k">type</span> <span class="kt">MetresPerSecondPerC</span>
<span class="k">type</span> <span class="kt">Dimensionless</span>
</code></pre></div></div>

<p>And we’ll need to write instances for all combinations of dimensions.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="n">kgDivideKg</span><span class="k">:</span> <span class="kt">Divide.Aux</span><span class="o">[</span><span class="kt">Kilogram</span>, <span class="kt">Kilogram</span>, <span class="kt">Dimensionless</span><span class="o">]</span> <span class="k">=</span> 
  <span class="k">new</span> <span class="nc">Divide</span><span class="o">[</span><span class="kt">Kilogram</span>, <span class="kt">Kilogram</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">Dimensionless</span> <span class="o">}</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">lyDivideC</span><span class="k">:</span> <span class="kt">Divide.Aux</span><span class="o">[</span><span class="kt">LightYear</span>, <span class="kt">C</span>, <span class="kt">Year</span><span class="o">]</span> <span class="k">=</span> 
  <span class="k">new</span> <span class="nc">Divide</span><span class="o">[</span><span class="kt">LightYear</span>, <span class="kt">C</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">Year</span> <span class="o">}</span>
	
<span class="k">implicit</span> <span class="k">val</span> <span class="n">lyDivideMps</span><span class="k">:</span> <span class="kt">Divide.Aux</span><span class="o">[</span><span class="kt">LightYear</span>, <span class="kt">MetresPerSecond</span>, <span class="kt">LightYearSecondsPerMetre</span><span class="o">]</span> <span class="k">=</span> 
  <span class="k">new</span> <span class="nc">Divide</span><span class="o">[</span><span class="kt">LightYear</span>, <span class="kt">MetresPerSecond</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">LightYearSecondsPerMetre</span> <span class="o">}</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">mpsDivideC</span><span class="k">:</span> <span class="kt">Divide.Aux</span><span class="o">[</span><span class="kt">MetresPerSecond</span>, <span class="kt">C</span>, <span class="kt">MetresPerSecondPerC</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Divide</span><span class="o">[</span><span class="kt">MetresPerSecond</span>, <span class="kt">C</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">MetresPerSecondPerC</span> <span class="o">}</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">mpsDivideMpsPerC</span><span class="k">:</span> <span class="kt">Divide.Aux</span><span class="o">[</span><span class="kt">MetresPerSecond</span>, <span class="kt">MetresPerSecondPerC</span>, <span class="kt">C</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Divide</span><span class="o">[</span><span class="kt">MetresPerSecond</span>, <span class="kt">MetresPerSecondPerC</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="n">C</span> <span class="o">}</span>
</code></pre></div></div>

<p>And so on.</p>

<p>Unfortunately, there are an infinite number of combinations, so there are an infinite number of instances.
Nevertheless, let’s plough on with the ones we’ve written.  We can modify our rocket equation to use <code class="highlighter-rouge">add</code>, <code class="highlighter-rouge">times</code> and <code class="highlighter-rouge">divide</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">rocketSpeed</span> <span class="k">=</span> <span class="n">times</span><span class="o">(</span><span class="n">exhaust</span><span class="o">,</span> <span class="n">log</span><span class="o">(</span><span class="n">divide</span><span class="o">(</span><span class="n">add</span><span class="o">(</span><span class="n">rocketMass</span><span class="o">,</span> <span class="n">fuelMass</span><span class="o">),</span> <span class="n">rocketMass</span><span class="o">).</span><span class="n">value</span><span class="o">))</span>
<span class="c1">// rocketSpeed: Quantity[Types.MetresPerSecond] = Quantity(5525452.939131783)
</span>
<span class="k">val</span> <span class="n">time</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">Year</span><span class="o">]</span> <span class="k">=</span> <span class="n">divide</span><span class="o">(</span><span class="n">distance</span><span class="o">,</span> <span class="n">rocketSpeed</span><span class="o">)</span>
<span class="c1">// &lt;console&gt;:31: error: type mismatch;
//  found   : Quantity[lyDivideMps.Out]
//     (which expands to)  Quantity[MoreTypes.LightYearSecondsPerMetre]
//  required: Quantity[Types.Year]
//        val time: Quantity[Year] = divide(distance, rocketSpeed)
//                                         ^
</span></code></pre></div></div>

<p>Great!  We’ve caught our bug!  The result was in <code class="highlighter-rouge">LightYearSecondsPerMetre</code>, not <code class="highlighter-rouge">Year</code>.  We made a unit conversion error, just like the Mars orbiter.</p>

<p>We can now fix this by adding a conversion:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">metresPerSecondPerC</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">MetresPerSecondPerC</span><span class="o">]</span> <span class="k">=</span> <span class="n">divide</span><span class="o">(</span><span class="nc">Quantity</span><span class="o">[</span><span class="kt">MetresPerSecond</span><span class="o">](</span><span class="mf">300000000.0</span><span class="o">),</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">C</span><span class="o">](</span><span class="mf">1.0</span><span class="o">))</span>
<span class="c1">// metresPerSecondPerC: Quantity[MoreTypes.MetresPerSecondPerC] = Quantity(3.0E8)
</span>
<span class="k">val</span> <span class="n">speedInC</span> <span class="k">=</span> <span class="n">divide</span><span class="o">(</span><span class="n">rocketSpeed</span><span class="o">,</span> <span class="n">metresPerSecondPerC</span><span class="o">)</span>
<span class="c1">// speedInC: Quantity[mpsDivideMpsPerC.Out] = Quantity(0.018418176463772612)
</span>
<span class="k">val</span> <span class="n">time</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">Year</span><span class="o">]</span> <span class="k">=</span> <span class="n">divide</span><span class="o">(</span><span class="n">distance</span><span class="o">,</span> <span class="n">speedInC</span><span class="o">)</span>
<span class="c1">// time: Quantity[Types.Year] = Quantity(4180.65274547967)
</span></code></pre></div></div>

<p>It seems like it’s going to take a lot longer than we hoped to get to Libra.  Perhaps it’s unwise to send a person.</p>

<h2 id="automatic-derivation">Automatic derivation</h2>

<p>We found the bug, but we needed to explicitly write out typeclass instances for every combination of dimensions.
This might have worked for our small problem, but it just doesn’t scale in the long run.
We need to figure out a way of deriving the typeclass instances automatically.
To attempt this, we first need to generalize what a combination of dimensions actually is.</p>

<h3 id="representing-dimensions">Representing dimensions</h3>

<p>We can represent a combination of dimensions as a heterogeneous list (HList) of base dimensions.  HLists are defined in <a href="https://github.com/milessabin/shapeless">shapeless</a>, a cornerstone of most functional libraries, and can be thought of as a type level list.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">LightYearSeconds</span> <span class="o">=</span> <span class="nc">LightYear</span> <span class="o">::</span> <span class="nc">Second</span> <span class="o">::</span> <span class="nc">HNil</span>
</code></pre></div></div>

<p>This is good for multiples of dimensions, such as <code class="highlighter-rouge">LightYearSeconds</code>, but doesn’t represent combinations created from division, such as <code class="highlighter-rouge">MetresPerSecond</code>.
To do this, we need some way of representing integer exponents as types. We can represent integers as types using Singleton types.  We actually need these singleton types in type position.  This is supported by a new feature present in <a href="https://typelevel.org/scala/">Typelevel Scala</a>, called <a href="http://docs.scala-lang.org/sips/pending/42.type.html">literal types</a>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scalaOrganization</span> <span class="o">:=</span> <span class="s">"org.typelevel"</span>
<span class="n">scalacOptions</span> <span class="o">+=</span> <span class="s">"-Yliteral-types"</span>
</code></pre></div></div>

<p>We need to represent a key value pair of dimension and integer exponent. We could use a <code class="highlighter-rouge">Tuple</code> for this, but will use a shapeless <code class="highlighter-rouge">FieldType</code> instead.  This is similar to a <code class="highlighter-rouge">Tuple</code>, but is more compatible with some of shapeless’s typeclasses.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">MetresPerSecond</span> <span class="o">=</span> <span class="nc">FieldType</span><span class="o">[</span><span class="kt">Metre</span>, <span class="err">1</span><span class="o">]</span> <span class="o">::</span> <span class="nc">FieldType</span><span class="o">[</span><span class="kt">Second</span>, <span class="kt">-</span><span class="err">1</span><span class="o">]</span> <span class="o">::</span> <span class="nc">HNil</span>
</code></pre></div></div>

<p>It’s important to note that the number <code class="highlighter-rouge">1</code> above is a type, not a value.  Because it’s a type, the compiler can work with it.</p>

<h3 id="operations-on-singleton-types">Operations on Singleton types</h3>

<p>When we multiply and divide dimensions, we want to add or subtract from these exponents.</p>

<p>We can use a library called <a href="https://github.com/fthomas/singleton-ops">singleton ops</a> to do this.  This provides us with type level integer operations using the <code class="highlighter-rouge">OpInt</code> typeclass:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">OpInt</span><span class="o">.</span><span class="nc">Aux</span><span class="o">[</span><span class="err">1</span> <span class="kt">+</span> <span class="err">2</span>, <span class="err">3</span><span class="o">]</span>
<span class="nc">OpInt</span><span class="o">.</span><span class="nc">Aux</span><span class="o">[</span><span class="err">3</span> <span class="kt">*</span> <span class="err">2</span>, <span class="err">6</span><span class="o">]</span>
</code></pre></div></div>
<p>It also provides a convenient alias for integer singleton types</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">XInt</span> <span class="o">=</span> <span class="nc">Singleton</span> <span class="k">with</span> <span class="nc">Int</span>
</code></pre></div></div>

<p>The type <code class="highlighter-rouge">1</code>, for example, is a subtype of <code class="highlighter-rouge">XInt</code>.</p>

<h3 id="deriving-typeclass-instances">Deriving typeclass instances</h3>

<p>We now need to automatically derive typeclass instances of <code class="highlighter-rouge">Divide</code>.
To do this, we’re going to derive instances for <code class="highlighter-rouge">Invert</code> and <code class="highlighter-rouge">Multiply</code> operations first.
Deriving <code class="highlighter-rouge">Divide</code> then becomes much simpler.</p>

<p>The technique we’re going to use to automatically derive instances is known as typeclass induction.</p>

<h3 id="typeclass-induction">Typeclass Induction</h3>

<p>Aaron Levin gave a great introduction to induction in his talk earlier at the <a href="https://typelevel.org/event/2017-06-summit-copenhagen/">Typelevel Summit</a>.  In summary, you can derive an implicit typeclass instance for all cases by:</p>

<ol>
  <li>Providing it for the base case</li>
  <li>Providing it for the n + 1 case, given that the n case is provided</li>
</ol>

<p>This is similar to the mathematical method of proof by induction.</p>

<h3 id="invert">Invert</h3>

<p>We’re first going to derive inductive typeclass instances for the <code class="highlighter-rouge">Invert</code> operation.
Inverting a quantity raises it to the exponent of <code class="highlighter-rouge">-1</code>.  This means that the exponents of all dimensions must be negated.</p>

<p>For example, the inverse of <code class="highlighter-rouge">FieldType[Metre, 1] :: HNil</code> is <code class="highlighter-rouge">FieldType[Metre, -1] :: HNil</code>.
<code class="highlighter-rouge">Invert</code> takes one input type and returns one output type:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Invert</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
	<span class="k">type</span> <span class="kt">Out</span>
<span class="o">}</span>
<span class="k">object</span> <span class="nc">Invert</span> <span class="o">{</span>
	<span class="k">type</span> <span class="kt">Aux</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Out0</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Invert</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">Out0</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>To inductively derive typeclass instances for inverting, we need to prove that:</p>

<ol>
  <li>We can derive an instance for <code class="highlighter-rouge">HNil</code> (the base case)</li>
  <li>We can derive an instance for a non-empty HList (the n + 1 case), provided there is an existing instance for its tail (the n case)</li>
</ol>

<p>The base case operates on <code class="highlighter-rouge">HNil</code></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">baseCase</span><span class="k">:</span> <span class="kt">Invert.Aux</span><span class="o">[</span><span class="kt">HNil</span>, <span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Invert</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">HNil</span> <span class="o">}</span>
</code></pre></div></div>

<p>The inductive case assumes that the tail has an instance, and derives an instance for the head by negating the exponent:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">inductiveCase</span><span class="o">[</span><span class="kt">D</span>, <span class="kt">Exp</span> <span class="k">&lt;:</span> <span class="kt">XInt</span>, <span class="kt">NExp</span> <span class="k">&lt;:</span> <span class="kt">XInt</span>, <span class="kt">Tail</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, 
  <span class="kt">OutTail</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span>
    <span class="k">implicit</span> <span class="n">negateEv</span><span class="k">:</span> <span class="kt">OpInt.Aux</span><span class="o">[</span><span class="kt">Negate</span><span class="o">[</span><span class="kt">Exp</span><span class="o">]</span>, <span class="kt">NExp</span><span class="o">],</span>
    <span class="n">tailEv</span><span class="k">:</span> <span class="kt">Invert.Aux</span><span class="o">[</span><span class="kt">Tail</span>, <span class="kt">OutTail</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">Invert.Aux</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">D</span>, <span class="kt">Exp</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">Tail</span>, <span class="kt">FieldType</span><span class="o">[</span><span class="kt">D</span>, <span class="kt">NExp</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">OutTail</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Invert</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">D</span>, <span class="kt">Exp</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">Tail</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">FieldType</span><span class="o">[</span><span class="kt">D</span>, <span class="kt">NExp</span><span class="o">]</span> <span class="o">::</span> <span class="nc">OutTail</span>
<span class="o">}</span>
</code></pre></div></div>

<p>When the compiler looks for the implicit instance for <code class="highlighter-rouge">FieldType[Metre, 1] :: HNil</code>:</p>
<ul>
  <li>It finds that the <code class="highlighter-rouge">inductiveCase</code> method has a return type which fits the signature</li>
  <li>It can find the required evidence <code class="highlighter-rouge">negateEv</code> for negating <code class="highlighter-rouge">1</code> from singleton ops</li>
  <li>It requires evidence of an implicit instance for the tail <code class="highlighter-rouge">HNil</code></li>
  <li>It finds that <code class="highlighter-rouge">baseCase</code> provides this evidence</li>
</ul>

<p>So in hunting for implicit typeclass instance for the whole list, the compiler goes and finds instances for the tail (the n case), right up until the base.  If we provide an inductive proof with a <code class="highlighter-rouge">baseCase</code> and an <code class="highlighter-rouge">inductiveCase</code>, we fit the bill for what the compiler needs.</p>

<h3 id="multiply">Multiply</h3>

<p>Now that we’ve tested a basic example of induction, we can go on to a more complex one.</p>

<p>We want to multiply two HLists of dimensions together. This means that the exponents should be added.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Multiply</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Out</span>
<span class="o">}</span>
<span class="k">object</span> <span class="nc">Multiply</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Aux</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">Out0</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Multiply</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">Out0</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This is harder to make inductive because there are two input lists involved.  Luckily, we only need to recurse over one of them, as we can pick dimensions from the other using shapeless’s <code class="highlighter-rouge">Selector</code>.  We will recurse over the left list and can pick elements from the right list.</p>

<p>Our base case can be the same:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">baseCase</span><span class="k">:</span> <span class="kt">Multiply.Aux</span><span class="o">[</span><span class="kt">HNil</span>, <span class="kt">HNil</span>, <span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Multiply</span><span class="o">[</span><span class="kt">HNil</span>, <span class="kt">HNil</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">HNil</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We can define the inductive case using the following logic:</p>
<ol>
  <li>Pick the exponent in the right list corresponding to the head dimension in the left list</li>
  <li>Add the left and right exponents together</li>
  <li>Filter the term from the right list to get the remaining elements</li>
  <li>Look for a typeclass instance for the left list tail and the remaining elements in the right list</li>
</ol>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">inductiveCase</span><span class="o">[</span><span class="kt">D</span>, <span class="kt">R</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">LExp</span> <span class="k">&lt;:</span> <span class="kt">XInt</span> , <span class="kt">RExp</span> <span class="k">&lt;:</span> <span class="kt">XInt</span>, 
  <span class="kt">OutExp</span> <span class="k">&lt;:</span> <span class="kt">XInt</span>, <span class="kt">RTail</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">LTail</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">OutTail</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span>
  <span class="k">implicit</span> <span class="n">pickEv</span><span class="k">:</span> <span class="kt">Selector.Aux</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">D</span>, <span class="kt">RExp</span><span class="o">],</span>
  <span class="n">addEv</span><span class="k">:</span> <span class="kt">OpInt.Aux</span><span class="o">[</span><span class="kt">LExp</span> <span class="kt">+</span> <span class="kt">RExp</span>, <span class="kt">OutExp</span><span class="o">],</span>
  <span class="n">filterEv</span><span class="k">:</span> <span class="kt">FilterNot.Aux</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">FieldType</span><span class="o">[</span><span class="kt">D</span>, <span class="kt">RExp</span><span class="o">]</span>, <span class="kt">RTail</span><span class="o">],</span>
  <span class="n">tailEv</span><span class="k">:</span> <span class="kt">Multiply.Aux</span><span class="o">[</span><span class="kt">LTail</span>, <span class="kt">RTail</span>, <span class="kt">OutTail</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">Multiply.Aux</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">D</span>, <span class="kt">LExp</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">LTail</span>, <span class="kt">R</span>, <span class="kt">FieldType</span><span class="o">[</span><span class="kt">D</span>, <span class="kt">OutExp</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">OutTail</span><span class="o">]</span> <span class="k">=</span> 
  <span class="k">new</span> <span class="nc">Multiply</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">D</span>, <span class="kt">LExp</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">LTail</span>, <span class="kt">R</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">FieldType</span><span class="o">[</span><span class="kt">D</span>, <span class="kt">OutExp</span><span class="o">]</span> <span class="o">::</span> <span class="nc">OutTail</span>
<span class="o">}</span>
</code></pre></div></div>
<p>When the compiler looks for an implicit instance of multiply for <code class="highlighter-rouge">FieldType[Metre, -1] :: HNil</code> and <code class="highlighter-rouge">FieldType[Metre, 3] :: HNil</code>:</p>

<ul>
  <li>It finds that the <code class="highlighter-rouge">inductiveCase</code> has a return type which fits the signature</li>
  <li>Given that the head of the left list is <code class="highlighter-rouge">Metre</code>, it selects the exponent for <code class="highlighter-rouge">Metre</code> from the right list</li>
  <li>It can find the evidence <code class="highlighter-rouge">addEv</code> to add the exponents <code class="highlighter-rouge">-1</code> and <code class="highlighter-rouge">3</code></li>
  <li>It filters <code class="highlighter-rouge">Metre</code> from the right list to get <code class="highlighter-rouge">HNil</code></li>
  <li>It requires evidence of an instance for  <code class="highlighter-rouge">HNil</code> and <code class="highlighter-rouge">HNil</code></li>
  <li>This is provided by the base case</li>
</ul>

<p>The compiler can now find instances of <code class="highlighter-rouge">Multiply</code>, as long as a dimension appears in both the left and right lists.
This can be extended to when a dimension doesn’t appear by writing a few more inductive cases.</p>

<h3 id="divide">Divide</h3>

<p>The reason we went to the effort of writing <code class="highlighter-rouge">Invert</code> and <code class="highlighter-rouge">Multiply</code> was to divide.
Dividing a numerator by a denominator is as simple as inverting the denominator and multiplying it by the numerator.
We can write this in a single non-inductive instance:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">divide</span><span class="o">[</span><span class="kt">L</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">R</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">RInverted</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, 
  <span class="kt">Divided</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span>
  <span class="k">implicit</span> <span class="n">invertEv</span><span class="k">:</span> <span class="kt">Invert.Aux</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">RInverted</span><span class="o">],</span>
  <span class="n">multiplyEv</span><span class="k">:</span> <span class="kt">Multiply.Aux</span><span class="o">[</span><span class="kt">L</span>, <span class="kt">RInverted</span>, <span class="kt">Divided</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">Divide.Aux</span><span class="o">[</span><span class="kt">L</span>, <span class="kt">R</span>, <span class="kt">Divided</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Divide</span><span class="o">[</span><span class="kt">L</span>, <span class="kt">R</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="nc">Divided</span>
<span class="o">}</span>
</code></pre></div></div>
<p>That’s far simpler than the work we’ve done before - we’re just building on the typeclasses we wrote to do this.</p>

<h3 id="automatically-derived-instances">Automatically derived instances</h3>

<p>We can now have compile time dimensional analysis without writing out divide instances for every combination of dimensions:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">rocketMass</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">Kilogram</span>, <span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">](</span><span class="mf">40.0</span><span class="o">)</span>
<span class="k">val</span> <span class="n">fuelMass</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">Kilogram</span>, <span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">](</span><span class="mf">10000.0</span><span class="o">)</span>
<span class="k">val</span> <span class="n">exhaust</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">Metre</span>, <span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">FieldType</span><span class="o">[</span><span class="kt">Second</span>, <span class="kt">-</span><span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">](</span><span class="mf">1000000.0</span><span class="o">)</span>
<span class="k">val</span> <span class="n">distance</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">LightYear</span>, <span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">](</span><span class="mf">77.0</span><span class="o">)</span>

<span class="k">val</span> <span class="n">rocketSpeed</span> <span class="k">=</span> <span class="n">times</span><span class="o">(</span><span class="n">exhaust</span><span class="o">,</span> <span class="n">log</span><span class="o">(</span><span class="n">divide</span><span class="o">(</span><span class="n">add</span><span class="o">(</span><span class="n">rocketMass</span><span class="o">,</span> <span class="n">fuelMass</span><span class="o">),</span> <span class="n">rocketMass</span><span class="o">).</span><span class="n">value</span><span class="o">))</span>
<span class="k">val</span> <span class="n">time</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">Year</span>, <span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span> <span class="n">divide</span><span class="o">(</span><span class="n">distance</span><span class="o">,</span> <span class="n">rocketSpeed</span><span class="o">)</span>
<span class="c1">// error: type mismatch; found: FieldType[LightYear, 1] :: FieldType[Metre, -1] :: FieldType[Second, 1] :: HNil; required: FieldType[Year, 1] :: HNil
</span></code></pre></div></div>
<p>Yay! We’ve solved the problem!  It looks a lot more verbose than what we started with, but we can tidy this up by using extension methods:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">final</span> <span class="k">class</span> <span class="nc">DoubleOps</span><span class="o">(</span><span class="k">val</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">ly</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">LightYear</span>,<span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">(</span><span class="n">d</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">kg</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">Kilogram</span>, <span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">(</span><span class="n">d</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">yr</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">Year</span>, <span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]</span>     <span class="k">=</span> <span class="nc">Quantity</span><span class="o">(</span><span class="n">d</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">mps</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">Metre</span>, <span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">FieldType</span><span class="o">[</span><span class="kt">Second</span>, <span class="kt">-</span><span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">(</span><span class="n">d</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">c</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">LightYear</span>, <span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">FieldType</span><span class="o">[</span><span class="kt">Year</span>, <span class="kt">-</span><span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">(</span><span class="n">d</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>
<p>We can also add symbolic infix operators for <code class="highlighter-rouge">add</code>, <code class="highlighter-rouge">times</code> and <code class="highlighter-rouge">divide</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="o">+(</span><span class="n">q</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">(</span><span class="n">value</span> <span class="o">+</span> <span class="n">q</span><span class="o">.</span><span class="n">value</span><span class="o">)</span>
  <span class="k">def</span> <span class="o">*(</span><span class="n">v</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">(</span><span class="n">value</span> <span class="o">+</span> <span class="n">v</span><span class="o">)</span>
  <span class="k">def</span> <span class="o">/[</span><span class="kt">B</span><span class="o">](</span><span class="n">q</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Divide</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">d.Out</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Quantity</span><span class="o">(</span><span class="n">value</span> <span class="o">/</span> <span class="n">q</span><span class="o">.</span><span class="n">value</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="weve-reached-libra">We’ve reached Libra!</h2>

<p>We started with doubles:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">rocketSpeed</span> <span class="k">=</span> <span class="mf">1000000.0</span> <span class="o">*</span> <span class="n">log</span><span class="o">((</span><span class="mf">40.0</span> <span class="o">+</span> <span class="mf">10000.0</span><span class="o">)</span> <span class="o">/</span> <span class="mf">40.0</span><span class="o">)</span>
<span class="k">val</span> <span class="n">time</span> <span class="k">=</span> <span class="mf">77.0</span> <span class="o">/</span> <span class="n">rocketSpeed</span>
</code></pre></div></div>
<p>And we finished with compile time dimensional analysis:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">rocketSpeed</span> <span class="k">=</span> <span class="mf">1000000.0</span><span class="o">.</span><span class="n">mps</span> <span class="o">*</span> <span class="n">log</span><span class="o">(((</span><span class="mf">40.0</span><span class="o">.</span><span class="n">kg</span> <span class="o">+</span><span class="mf">10000.0</span><span class="o">.</span><span class="n">kg</span><span class="o">)</span> <span class="o">/</span><span class="mf">40.0</span><span class="o">.</span><span class="n">kg</span><span class="o">).</span><span class="n">value</span><span class="o">)</span>
<span class="k">val</span> <span class="n">speedConversion</span> <span class="k">=</span> <span class="mf">300000000.0</span><span class="o">.</span><span class="n">mps</span> <span class="o">/</span> <span class="mf">1.</span><span class="n">c</span> 
<span class="k">val</span> <span class="n">speedInC</span> <span class="k">=</span> <span class="n">rocketSpeed</span> <span class="o">/</span> <span class="n">speedConversion</span>
<span class="k">val</span> <span class="n">time</span> <span class="k">=</span> <span class="mf">77.0</span><span class="o">.</span><span class="n">ly</span> <span class="o">/</span> <span class="n">speedInC</span>
<span class="c1">//time: Quantity[FieldType[Year, 1] :: HNil] = Quantity(4180.65274634)
</span></code></pre></div></div>

<p>The code isn’t more verbose - if anything, it’s more explanatory and just as easy to work with.</p>

<h2 id="rolling-this-out-to-more-problems">Rolling this out to more problems</h2>

<p>All we need to provide for the business logic of our rocket launch problem are the dimensions and <code class="highlighter-rouge">DoubleOps</code>.
We could roll this out to any other problem.  Let’s say we wanted to do a currency conversion between <code class="highlighter-rouge">GBP</code> and <code class="highlighter-rouge">DKK</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">exchangeRate</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">DKK</span>, <span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">FieldType</span><span class="o">[</span><span class="kt">GBP</span>, <span class="kt">-</span><span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span> 
   <span class="n">currentExchangeRate</span><span class="o">()</span> 
<span class="nc">Val</span> <span class="n">krone</span><span class="k">:</span> <span class="kt">Quantity</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">DKK</span>, <span class="err">1</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span> <span class="mf">10.</span><span class="n">gbp</span> <span class="o">*</span> <span class="n">exchangeRate</span>
</code></pre></div></div>

<p>We get dimensional analysis for any problem domain out of the box!</p>

<p>Most of the code we’ve written is library code.  In fact, it’s Libra code!  <a href="https://to-ithaca.github.io/libra/">Libra</a> is a dimensional analysis library based on typelevel induction.  It performs compile time dimensional analysis to any problem domain.  It also uses <a href="https://github.com/non/spire">spire</a> for its numeric typeclasses, so can be used for far more than just doubles.</p>

<h2 id="conclusion">Conclusion</h2>

<p>It’s been a long way from the humble <code class="highlighter-rouge">Double</code>.  We started with basic types, explored dependent types, took a look at Typelevel Scala along the way, before finally ending up performing typelevel induction.  As a result, we’ve managed to achieve compile time dimensional analysis for any problem. If you’re curious about typelevel induction take a look at <a href="https://github.com/to-ithaca/libra">the Libra codebase</a> for more examples.  Enjoy!</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Tue, 13 Jun 2017 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2017/06/13/libra.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2017/06/13/libra.html</guid>
      </item>
    
      <item>
        <title>An IO monad for cats</title>
        
          <dc:creator>djspiewak</dc:creator>
                
        <description><![CDATA[<p>Haskell is a pure language.  Every Haskell expression is <em>referentially transparent</em>, meaning that you can substitute that expression with its evaluated result without changing the program.  Or, put into code:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- this program</span>
<span class="n">f</span> <span class="n">expr</span> <span class="n">expr</span> <span class="c1">-- apply function f to arguments expr, expr</span>

<span class="c1">-- is equivalent to this one, which factors out `expr`</span>
<span class="kr">let</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">expr</span> <span class="c1">-- introduce a new variable `x` with the value of `expr`</span>
<span class="kr">in</span>
  <span class="n">f</span> <span class="n">x</span> <span class="n">x</span>
</code></pre></div></div>

<p>And this is true for <em>all</em> expressions <code class="highlighter-rouge">e</code>, and all functions <code class="highlighter-rouge">f</code>.  These could be complex expressions which describe ways of manipulating network channels or window buffers, or something trivial like a numeric literal.  You can <em>always</em> substitute the expression with its value.</p>

<p>This is not true in Scala, simply because Scala allows <em>unrestricted</em> side-effects.  Unlike Haskell, Scala puts no limitations on where and when we can use things like mutable state (<code class="highlighter-rouge">var</code>s) or evaluated external effects like <code class="highlighter-rouge">println</code> or <code class="highlighter-rouge">launchTheMissiles</code>.  Since there are no restrictions on where and when we can do evil, the Scala equivalent to the above just doesn’t work:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
<span class="c1">// isn't really equivalent to!
</span><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">e</span>
<span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div></div>

<p>The reason it isn’t equivalent comes from the different sorts of expressions that we could find in <code class="highlighter-rouge">e</code>.  For example, what if <code class="highlighter-rouge">e</code> is <code class="highlighter-rouge">println("hi!")</code>.  If we make that substitution, our snippet looks like the following:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"hi"</span><span class="o">),</span> <span class="n">println</span><span class="o">(</span><span class="s">"hi"</span><span class="o">))</span>
<span class="c1">// isn't really equivalent to!
</span><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">println</span><span class="o">(</span><span class="s">"hi"</span><span class="o">)</span>
<span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div></div>

<p>Clearly these are not the same two programs.  The first prints <code class="highlighter-rouge">"hi"</code> twice, while the second only prints it once.  This is a violation of referential transparency, and it’s why we sometimes say that Scala is an <em>impure</em> language.  Any expression which is not referentially transparent must contain <em>side-effects</em>, by definition.</p>

<p>Now of course, we found this problem by using a side-effecting function: namely, <code class="highlighter-rouge">println</code>.  Haskell clearly has the ability to print to standard output, so how does it avoid this issue?  If we build the same program in Haskell, can we violate referential transparency?</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="p">(</span><span class="n">putStrLn</span> <span class="s">"hi"</span><span class="p">)</span> <span class="p">(</span><span class="n">putStrLn</span> <span class="s">"hi"</span><span class="p">)</span>
<span class="c1">-- is equivalent to</span>
<span class="kr">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">putStrLn</span> <span class="s">"hi"</span> <span class="kr">in</span> <span class="n">f</span> <span class="n">x</span> <span class="n">x</span>
</code></pre></div></div>

<p>As it turns out, this is still referentially transparent!  These two programs still have the same meaning.  This is possible only because <em>neither</em> program actually prints anything!</p>

<p>In Haskell, effects are treated as first-class values.  The <code class="highlighter-rouge">putStrLn</code> function doesn’t print to standard out, it returns a value (of type <code class="highlighter-rouge">IO ()</code>) which describes <em>how</em> to print to standard out, but stops short of actually <em>doing</em> it.  These sorts of values can be composed using the monadic operators (in Scala, <code class="highlighter-rouge">flatMap</code> and <code class="highlighter-rouge">pure</code>), allowing Haskell programmers to build up expressions composed of sequences of dependent effects, all of which are merely <em>descriptions</em> of the side-effects which will eventually be performed by the runtime.  Ultimately, the description which comprises your <em>whole</em> program is the return result from the <code class="highlighter-rouge">main</code> function.  The Haskell runtime runs the <code class="highlighter-rouge">main</code> function to get this description of all your effects, and then runs the effects per your instructions.</p>

<p>This is kind of a clever trick.  It allows Haskell to simultaneously be pure <em>and</em> still have excellent support for manipulating effects and interacting with the “real world”.  But why is it relevant to Scala?  After all, Scala is an impure language.  We don’t <em>need</em> to go through this complex rigmarole of describing our effects and composing those descriptions; the language lets us <em>just do it!</em>  So why wouldn’t we just, you know, evaluate the effects that we need evaluated?</p>

<p>The answer is that we want to reason about <em>where</em> and <em>when</em> our effects are evaluated.  And of course, we want to be able to leverage laws and abstractions which assume equational semantics for expressions (i.e. referential transparency).  Cats is full of these sorts of abstractions, and cats-laws provides a vast set of laws which describe them.  But all of these abstractions and all of these laws break down the <em>moment</em> you introduce some sort of side-effecting expression.  Because, much like our referential transparency example from earlier, these abstractions <em>assume</em> that you can substitute expressions with their evaluated results, and that’s just not true in the presence of side-effects.</p>

<p>What we need is a data type which allows us to encapsulate Scala-style side-effects in the form of a <em>pure</em> value, on which referential transparency holds and which we can compose using other well-defined abstractions, such as <code class="highlighter-rouge">Monad</code>.  Scalaz defines two such data types which meet these criteria: <code class="highlighter-rouge">scalaz.effect.IO</code> and <code class="highlighter-rouge">scalaz.concurrent.Task</code>.  But in practice, nearly everyone uses <code class="highlighter-rouge">Task</code> instead of <code class="highlighter-rouge">IO</code> because of its support for <em>asynchronous</em> effects.</p>

<p>Cats does not define any such abstraction, and what’s worse is the cats <em>ecosystem</em> also doesn’t really provide any such abstraction.  There are two <code class="highlighter-rouge">Task</code> implementations that are relatively commonly used with cats – namely, <code class="highlighter-rouge">monix.eval.Task</code> and <code class="highlighter-rouge">fs2.Task</code> – but these are not part of cats per se, nor are they deeply integrated into its abstraction hierarchy.  Additionally, the proliferation of broadly equivalent options has led to confusion in the ecosystem, with middleware authors often forced to choose a solution for their end-users, and end-users uncertain as to which choice is “right”.</p>

<h2 id="introducing-cats-effect">Introducing cats-effect</h2>

<p>The <a href="https://github.com/typelevel/cats-effect">cats-effect</a> project aims to change all of that.  The goal of cats-effect is to provide an “easy default” <code class="highlighter-rouge">IO</code> type for the cats ecosystem, deeply integrated with cats-core, with all of the features and performance that are required for real world production use.  Additionally, cats-effect defines a set of abstractions in the form of several typeclasses which describe what it means to <em>be</em> a pure effect type.  These abstractions are extremely useful both in enabling MTL-style program composition and to ensure that other pre-existing <code class="highlighter-rouge">Task</code> implementations remain first-class citizens of the ecosystem.  <code class="highlighter-rouge">IO</code> does not overshadow <code class="highlighter-rouge">monix.eval.Task</code> or <code class="highlighter-rouge">fs2.Task</code>; it <em>complements</em> them by providing a set of abstractions and laws which allow users to write safe, parametric code which supports each of them equally.</p>

<p>One important sidebar here: cats-effect does <em>not</em> provide any concurrency primitives.  <code class="highlighter-rouge">scalaz.concurrent.Task</code> and <code class="highlighter-rouge">monix.eval.Task</code> are both notable for providing functions such as <code class="highlighter-rouge">both</code>, which takes two <code class="highlighter-rouge">Task</code>s and runs them in parallel, returning a <code class="highlighter-rouge">Task</code> of a tuple of the results.  The <code class="highlighter-rouge">cats.effect.IO</code> type does not provide any such function, and while it would be possible to define such a function (and others like it!), we strongly encourage users to instead consider full-on streaming frameworks such as <strong>fs2</strong> or <strong>Monix</strong> for their concurrency needs, as these frameworks are able to provide a much sounder foundation for such functions.  See <a href="https://gist.github.com/djspiewak/a775b73804c581f4028fea2e98482b3c">here</a> for a rough outline of why this is.  Also note that some <code class="highlighter-rouge">Task</code> implementations, such as Monix’s, can and do provide parallelism on a sound foundation by enriching their internal algebraic structures.  Thus, <code class="highlighter-rouge">monix.eval.Task</code> is actually quite different from <code class="highlighter-rouge">cats.effect.IO</code>, despite having a similar core set of operations.</p>

<h2 id="enough-talk">Enough Talk…</h2>

<p>What does this look like in practice?  Well, ideally, as convenient as possible!  Let’s look at our println example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">putStrLn</span><span class="o">(</span><span class="n">line</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="n">line</span><span class="o">)</span> <span class="o">}</span>

<span class="n">f</span><span class="o">(</span><span class="n">putStrLn</span><span class="o">(</span><span class="s">"hi!"</span><span class="o">),</span> <span class="n">putStrLn</span><span class="o">(</span><span class="s">"hi!"</span><span class="o">))</span>

<span class="c1">// is equivalent to
</span>
<span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">putStrLn</span><span class="o">(</span><span class="s">"hi!"</span><span class="o">)</span>
<span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div></div>

<p>Great!  We can write Haskell fanfic in Scala.  😛</p>

<p>The notable element here is the use of the <code class="highlighter-rouge">IO.apply</code> constructor to wrap the <code class="highlighter-rouge">println</code> effect in a <em>pure</em> <code class="highlighter-rouge">IO</code> value.  This pattern can be applied to any side-effect.  You can think of this sort of like an FFI that converts impure code (like <code class="highlighter-rouge">println</code>) into pure code (like <code class="highlighter-rouge">putStrLn</code>).  The goal of this API was to be as simple and straightforward as possible.  If you have a curly brace block of impure side-effecting code, you can wrap it in a composable and pure abstraction by just adding two characters: <code class="highlighter-rouge">IO</code>.  You can wrap arbitrarily large or small blocks of code, potentially involving complex allocations, JNI calls, resource semantics, etc; but it is generally considered a best practice to wrap side-effects into the smallest composable units that make sense and do all of your sequentialization using <code class="highlighter-rouge">flatMap</code> and <code class="highlighter-rouge">for</code>-comprehensions.</p>

<p>For example, here’s a program that performs some simple user interaction in the shell:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">val</span> <span class="n">program</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Welcome to Scala!  What's your name?"</span><span class="o">)</span> <span class="o">}</span>
  <span class="n">name</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="nc">Console</span><span class="o">.</span><span class="n">readLine</span> <span class="o">}</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Well hello, $name!"</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>We could have just as easily written this program in the following way:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">program</span> <span class="k">=</span> <span class="nc">IO</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">"Welcome to Scala!  What's your name?"</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">name</span> <span class="k">=</span> <span class="nc">Console</span><span class="o">.</span><span class="n">readLine</span>
  <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Well hello, $name!"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>But this gives us less flexibility for composition.  Remember that even though <code class="highlighter-rouge">program</code> is a pure and referentially transparent value, its <em>definition</em> is not, which is to say that <code class="highlighter-rouge">IO { expr }</code> is not the same as <code class="highlighter-rouge">val x = expr; IO { x }</code>.  Anything inside the <code class="highlighter-rouge">IO {</code> … <code class="highlighter-rouge">}</code> block is not referentially transparent, and so should be treated with extreme care and suspicion.  The less of our program we have inside these blocks, the better!</p>

<p>As a sidebar that is actually kinda cool, we can implement a <code class="highlighter-rouge">readString</code> <code class="highlighter-rouge">IO</code> action that wraps <code class="highlighter-rouge">Console.readLine</code> <em>as a <code class="highlighter-rouge">val</code>!</em></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">readString</span> <span class="k">=</span> <span class="nc">IO</span> <span class="o">{</span> <span class="nc">Console</span><span class="o">.</span><span class="n">readLine</span> <span class="o">}</span>
</code></pre></div></div>

<p>This is totally valid!  We don’t need to worry about the difference between <code class="highlighter-rouge">def</code> and <code class="highlighter-rouge">val</code> anymore, because <code class="highlighter-rouge">IO</code> is referentially transparent.  So you use <code class="highlighter-rouge">def</code> when you need parameters, and you use <code class="highlighter-rouge">val</code> when you don’t, and you don’t have to think about evaluation semantics.  No more subtle bugs caused by accidentally memoizing your effects!</p>

<p>Of course, if <code class="highlighter-rouge">program</code> is referentially transparent, then clearly repeated values of <code class="highlighter-rouge">program</code> cannot possibly run the effects it represents multiple times.  For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">program</span>
<span class="n">program</span>
<span class="n">program</span>

<span class="c1">// must be the same as!
</span>
<span class="n">program</span>
</code></pre></div></div>

<p>If this weren’t the case, then we would be in trouble when trying to construct examples like the Haskell one from earlier.  But there is an implication here that is quite profound: <code class="highlighter-rouge">IO</code> cannot eagerly evaluate its effects, and similarly cannot memoize its results!  If <code class="highlighter-rouge">IO</code> were to eagerly evaluate or to memoize, then we could no longer replace references to the expression with the expression itself, since that would result in a <em>different</em> <code class="highlighter-rouge">IO</code> instance to be evaluated separately.</p>

<p>This is precisely why <code class="highlighter-rouge">scala.concurrent.Future</code> is <em>not</em> a suitable type for encapsulating effects in this way: constructing a <code class="highlighter-rouge">Future</code> that will eventually side-effect is itself a side-effect!  <code class="highlighter-rouge">Future</code> evaluates eagerly (sort of, see below) and memoizes its results, meaning that a <code class="highlighter-rouge">println</code> inside of a given <code class="highlighter-rouge">Future</code> will only evaluate <em>once</em>, even if the <code class="highlighter-rouge">Future</code> is sequenced multiple times.  This in turn means that <code class="highlighter-rouge">val x = Future(...); f(x, x)</code> is not the same program as <code class="highlighter-rouge">f(Future(...), Future(...))</code>, which is the very definition of a violation of referential transparency.</p>

<p>Coming back to <code class="highlighter-rouge">IO</code>…  If <code class="highlighter-rouge">program</code> does not evaluate eagerly, then clearly there must be some mechanism for asking it to evaluate.  After all, Scala is not like Haskell: we don’t return a value of type <code class="highlighter-rouge">IO[Unit]</code> from our <code class="highlighter-rouge">main</code> function.  <code class="highlighter-rouge">IO</code> provides an FFI of sorts for wrapping side-effecting code into pure <code class="highlighter-rouge">IO</code> values, so it must also provide an FFI for going in the opposite direction: taking a pure <code class="highlighter-rouge">IO</code> value and evaluating its constituent actions as side-effects.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">program</span><span class="o">.</span><span class="n">unsafeRunSync</span><span class="o">()</span>    <span class="c1">// uh oh!
</span></code></pre></div></div>

<p>This function is called <code class="highlighter-rouge">unsafeRunSync()</code>.  Given an <code class="highlighter-rouge">IO[A]</code>, the <code class="highlighter-rouge">unsafeRunSync()</code> function will give you a value of type <code class="highlighter-rouge">A</code>.  You should only call this function <em>once</em>, ideally at the very end of your program!  (i.e. in your <code class="highlighter-rouge">main</code> function)  Just as with <code class="highlighter-rouge">IO.apply</code>, any expression involving <code class="highlighter-rouge">unsafeRunSync()</code> is not referentially transparent.  For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">program</span><span class="o">.</span><span class="n">unsafeRunSync</span><span class="o">()</span>
<span class="n">program</span><span class="o">.</span><span class="n">unsafeRunSync</span><span class="o">()</span>
</code></pre></div></div>

<p>The above will run <code class="highlighter-rouge">program</code> <em>twice</em>.  So clearly, referential transparency is out the window whenever we do this, and we cannot expect the normal laws and abstractions to remain sound in the presence of this function.</p>

<h3 id="a-sidebar-on-futures-eager-evaluation">A sidebar on <code class="highlighter-rouge">Future</code>’s eager evaluation</h3>

<p>As Viktor Klang is fond of pointing out, <code class="highlighter-rouge">Future</code> doesn’t <em>need</em> to evaluate eagerly.  It is possible to define an <code class="highlighter-rouge">ExecutionContext</code> in which <code class="highlighter-rouge">Future</code> defers its evaluation until some indefinitely later point.  However, this is not the default mode of operation for 99% of all <code class="highlighter-rouge">Future</code>s ever constructed; most people just use <code class="highlighter-rouge">ExecutionContext.global</code> and leave it at that.  Additionally, if someone hands me an arbitrary <code class="highlighter-rouge">Future</code>, perhaps as a return value from a function, I really have no idea whether or not that <code class="highlighter-rouge">Future</code> is secretly running without my consent.  In other words, the referential transparency (or lack thereof) of functions that I write using <code class="highlighter-rouge">Future</code> is dependent on the runtime configuration of some other function which is hidden from me.  That’s not referential transparency anymore.  Because we cannot be <em>certain</em> that <code class="highlighter-rouge">Future</code> is deferring its evaluation, we must defensively assume that it is not.</p>

<p>This, in a nutshell, is precisely why <code class="highlighter-rouge">Future</code> is not appropriate for functional programming.  <code class="highlighter-rouge">IO</code> provides a pair of functions (<code class="highlighter-rouge">fromFuture</code> and <code class="highlighter-rouge">unsafeToFuture</code>) for interacting with <code class="highlighter-rouge">Future</code>-using APIs, but in general, you should try to stick with <code class="highlighter-rouge">IO</code> as much as possible when manipulating effects.</p>

<h2 id="asynchrony-and-the-jvm">Asynchrony and the JVM</h2>

<p>Scala runs on three platforms: the JVM, JavaScript and LLVM.  For the moment, we’ll just focus on the first two.  The JVM has support for multiple threads, but those threads are <em>native</em> (i.e. kernel) threads, meaning that they are relatively expensive to create and maintain in the runtime.  They are a very limited resource, sort of like file handles or heap space, and you can’t just write programs which require an unbounded number of them.  The exact upper bound on the JVM varies from platform to platform, and varies considerably depending on your GC configuration, but a general rule of thumb is “a few thousand”, where “few” is a small number.  In practice, you’re going to want <em>far</em> less threads than that if you want to avoid thrashing your GC, and most applications will divide themselves into a bounded “main” thread pool (usually bounded to exactly the number of CPUs) on which all CPU-bound tasks are performed and most of the program runs, as well as a set of unbounded “blocking” thread pools on which blocking IO actions (such as anything in <code class="highlighter-rouge">java.io</code>) are run.  When you add NIO worker pools into the mix, the final number of threads in a practical production service is usually around 30-40 on an 8 CPU machine, growing roughly linearly as you add CPUs.  Clearly, this is not a very large number.</p>

<p>On JavaScript runtimes (such as <code class="highlighter-rouge">node</code> or in the browser), the situation is even worse: you have exactly one thread!  JavaScript simply doesn’t have multi-threading in any (real) form, and so it’s like the JVM situation, but 30-40x more constraining.</p>

<p>For this reason, we need to be very careful when writing Scala to treat threads as an extremely scarce resource.  <em>Blocking</em> threads (using mechanisms such as <code class="highlighter-rouge">wait</code>, <code class="highlighter-rouge">join</code> or <code class="highlighter-rouge">CountDownLatch</code>) should be considered absolutely anathema, since it selfishly wastes a very finite and very critical resource, leading to thread starvation and deadlocks.</p>

<p>This is very different from how things are in Haskell though!  The Haskell runtime is implemented around the concept of <em>green threads</em>, which is to say, <em>emulated</em> concurrency by means of a runtime dispatch lock.  Haskell basically creates a global bounded thread pool in the runtime with the same number of threads as your machine has CPUs.  On top of that pool, it runs dispatch trampolines that schedule and evict expression evaluation, effectively emulating an arbitrarily large number of “fake” threads atop a small fixed set of “real” threads.  So when you write code in Haskell, you generally just assume that threads are extremely cheap and you can have as many of them as you want.  Under these circumstances, blocking a thread is not really a big deal (as long as you don’t do it in FFI native code), so there’s no reason to go out of your way to avoid it in abstractions like <code class="highlighter-rouge">IO</code>.</p>

<p>This presents a bit of a dilemma for cats-effect: we want to provide a <em>practical</em> pure abstraction for encapsulating effects, but we need to run on the JVM and on JavaScript which means we need to provide a way to avoid thread blocking.  So, the <code class="highlighter-rouge">IO</code> implementation in cats-effect is going to <em>necessarily</em> end up looking very, very different from the one in Haskell, providing a very different set of operations.</p>

<p>Specifically, <code class="highlighter-rouge">cats.effect.IO</code> provides an additional constructor, <code class="highlighter-rouge">async</code>, which allows the construction of <code class="highlighter-rouge">IO</code> instances from callback-driven APIs.  This is generally referred to as “asynchronous” control flow, as opposed to “synchronous” control flow (represented by the <code class="highlighter-rouge">apply</code> constructor).  To see how this works, we’re going to need a bit of setup.</p>

<p>Consider the following somewhat-realistic NIO API (translated to Scala):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Response</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">onError</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
  <span class="k">def</span> <span class="n">onSuccess</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>
<span class="c1">// defined trait Response
</span>
<span class="k">trait</span> <span class="nc">Channel</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">sendBytes</span><span class="o">(</span><span class="n">chunk</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">],</span> <span class="n">handler</span><span class="k">:</span> <span class="kt">Response</span><span class="o">[</span><span class="kt">Unit</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span>
  <span class="k">def</span> <span class="n">receiveBytes</span><span class="o">(</span><span class="n">handler</span><span class="k">:</span> <span class="kt">Response</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>
<span class="c1">// defined trait Channel
</span></code></pre></div></div>

<p>This is an asynchronous API.  Neither of the functions <code class="highlighter-rouge">sendBytes</code> or <code class="highlighter-rouge">receiveBytes</code> attempt to block on completion.  Instead, they <em>schedule</em> their operations via some underlying mechanism.  This interface could be implemented on top of <code class="highlighter-rouge">java.io</code> (which is a synchronous API) through the use of an internal thread pool, but most NIO implementations are actually going to delegate their scheduling all the way down to the kernel layer, avoiding the consumption of a precious thread while waiting for the underlying IO – which, in the case of network sockets, may be a very long wait indeed!</p>

<p>Wrapping this sort of API in a referentially transparent and uniform fashion is a very important feature of <code class="highlighter-rouge">IO</code>, <em>precisely</em> because of Scala’s underlying platform constraints.  Clearly, <code class="highlighter-rouge">sendBytes</code> and <code class="highlighter-rouge">receiveBytes</code> both represent side-effects, but they’re different than <code class="highlighter-rouge">println</code> and <code class="highlighter-rouge">readLine</code> in that they don’t produce their results in a sequentially returned value.  Instead, they take a callback, <code class="highlighter-rouge">Response</code>, which will eventually be notified (likely on some other thread!) when the result is available.  The <code class="highlighter-rouge">IO.async</code> constructor is designed for precisely these situations:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">send</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Channel</span><span class="o">,</span> <span class="n">chunk</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">IO</span> <span class="n">async</span> <span class="o">{</span> <span class="n">cb</span> <span class="k">=&gt;</span>
    <span class="n">c</span><span class="o">.</span><span class="n">sendBytes</span><span class="o">(</span><span class="n">chunk</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Response</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">onError</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span> <span class="k">=</span> <span class="n">cb</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">t</span><span class="o">))</span>
      <span class="k">def</span> <span class="n">onSuccess</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">Unit</span><span class="o">)</span> <span class="k">=</span> <span class="n">cb</span><span class="o">(</span><span class="nc">Right</span><span class="o">(()))</span>
    <span class="o">})</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// send: (c: Channel, chunk: Array[Byte])cats.effect.IO[Unit]
</span>
<span class="k">def</span> <span class="n">receive</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Channel</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">IO</span> <span class="n">async</span> <span class="o">{</span> <span class="n">cb</span> <span class="k">=&gt;</span>
    <span class="n">c</span><span class="o">.</span><span class="n">receiveBytes</span><span class="o">(</span><span class="k">new</span> <span class="nc">Response</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">onError</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span> <span class="k">=</span> <span class="n">cb</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">t</span><span class="o">))</span>
      <span class="k">def</span> <span class="n">onSuccess</span><span class="o">(</span><span class="n">chunk</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">])</span> <span class="k">=</span> <span class="n">cb</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">chunk</span><span class="o">))</span>
    <span class="o">})</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// receive: (c: Channel)cats.effect.IO[Array[Byte]]
</span></code></pre></div></div>

<p>Obviously, this is a little more daunting than the <code class="highlighter-rouge">println</code> examples from earlier, but that’s mostly the fault of the anonymous inner class syntactic ceremony.  The <code class="highlighter-rouge">IO</code> interaction is actually quite simple!</p>

<p>The <code class="highlighter-rouge">async</code> constructor takes a function which is handed a <em>callback</em> (represented above by <code class="highlighter-rouge">cb</code> in both cases).  This callback is <em>itself</em> a function of type <code class="highlighter-rouge">Either[Throwable, A] =&gt; Unit</code>, where <code class="highlighter-rouge">A</code> is the type produced by the <code class="highlighter-rouge">IO</code>.  So when our <code class="highlighter-rouge">Response</code> comes back as <code class="highlighter-rouge">onSuccess</code> in the <code class="highlighter-rouge">send</code> example, we invoke the callback with a <code class="highlighter-rouge">Right(())</code> since we’re trying to produce an <code class="highlighter-rouge">IO[Unit]</code>.  When the <code class="highlighter-rouge">Response</code> comes back as <code class="highlighter-rouge">onSuccess</code> in the <code class="highlighter-rouge">receive</code> example, we invoke the callback with <code class="highlighter-rouge">Right(chunk)</code>, since the <code class="highlighter-rouge">IO</code> produces an <code class="highlighter-rouge">Array[Byte]</code>.</p>

<p>Now remember, <code class="highlighter-rouge">IO</code> is still a monad, and <code class="highlighter-rouge">IO</code> values constructed with <code class="highlighter-rouge">async</code> are perfectly capable of all of the things that “normal”, synchronous <code class="highlighter-rouge">IO</code> values are, which means that you can use these values inside <code class="highlighter-rouge">for</code>-comprehensions and other conventional composition!  This is incredibly, unbelievably nice in practice, because it takes your complex, nested, callback-driven code and flattens it into simple, easy-to-read sequential composition.  For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">c</span><span class="k">:</span> <span class="kt">Channel</span> <span class="o">=</span> <span class="kc">null</span> <span class="c1">// pretend this is an actual channel
</span>
<span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">send</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="s">"SYN"</span><span class="o">.</span><span class="n">getBytes</span><span class="o">)</span>
  <span class="n">response</span> <span class="k">&lt;-</span> <span class="n">receive</span><span class="o">(</span><span class="n">c</span><span class="o">)</span>

  <span class="k">_</span> <span class="k">&lt;-</span> <span class="k">if</span> <span class="o">(</span><span class="n">response</span> <span class="o">==</span> <span class="s">"ACK"</span><span class="o">.</span><span class="n">getBytes</span><span class="o">)</span>   <span class="c1">// pretend == works on Array[Byte]
</span>    <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"found the guy!"</span><span class="o">)</span> <span class="o">}</span>
  <span class="k">else</span>
    <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"no idea what happened, but it wasn't good"</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>This is kind of amazing.  There’s no thread blocking at all in the above (other than the <code class="highlighter-rouge">println</code> blocking on standard output).  The <code class="highlighter-rouge">receive</code> could take quite a long time to come back to us, and our thread is free to do other things in the interim.  Everything is driven by callbacks under the surface, and asynchronous actions can be manipulated just as easily as synchronous ones.</p>

<p>Of course, this is an even bigger win on JavaScript, where nearly everything is callback-based, and gigantic, deeply nested chunks of code are not unusual.  <code class="highlighter-rouge">IO</code> allows you to flatten those deeply nested chunks of code into a nice, clean, linear and sequential formulation.</p>

<h2 id="thread-shifting">Thread Shifting</h2>

<p>Now there is a caveat here.  When our <code class="highlighter-rouge">Response</code> handler is invoked by <code class="highlighter-rouge">Channel</code>, it is very likely that the callback will be run on a thread which is part of a different thread pool than our main program.  Remember from earlier where I described how <em>most</em> well-designed Java services are organized:</p>

<ul>
  <li>A bounded thread pool set to <em>num CPUs</em> in size for any non-IO actions</li>
  <li>A set of unbounded thread pools for blocking IO</li>
  <li>Some bounded internal thread worker pools for NIO polling</li>
</ul>

<p>We definitely want to run nearly everything on that first pool (which is probably <code class="highlighter-rouge">ExecutionContext.global</code>), but we’re probably going to receive the <code class="highlighter-rouge">Response</code> callback on one of the third pools.  So how can we force the rest of our program (including those <code class="highlighter-rouge">println</code>s) back onto the main pool?</p>

<p>The answer is the <code class="highlighter-rouge">shift</code> function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent._</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">ec</span> <span class="k">=</span> <span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span>

<span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">send</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="s">"SYN"</span><span class="o">.</span><span class="n">getBytes</span><span class="o">)</span>
  <span class="n">response</span> <span class="k">&lt;-</span> <span class="n">receive</span><span class="o">(</span><span class="n">c</span><span class="o">).</span><span class="n">shift</span>    <span class="c1">// there's no place like home!
</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="k">if</span> <span class="o">(</span><span class="n">response</span> <span class="o">==</span> <span class="s">"ACK"</span><span class="o">.</span><span class="n">getBytes</span><span class="o">)</span>   <span class="c1">// pretend == works on Array[Byte]
</span>    <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"found the guy!"</span><span class="o">)</span> <span class="o">}</span>
  <span class="k">else</span>
    <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"no idea what happened, but it wasn't good"</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">shift</code>’s functionality is a little complicated, but generally speaking, you should think of it as a “force this <code class="highlighter-rouge">IO</code> onto this <em>other</em> thread pool” function.  Of course, when <code class="highlighter-rouge">receive</code> executes, most of its work isn’t done on any thread at all (since it is simply registering a hook with the kernel), and so that work isn’t thread shifted to any pool, main or otherwise.  But when <code class="highlighter-rouge">receive</code> gets back to us with the network response, the callback will be handled and then <em>immediately</em> thread-shifted back onto the main pool, which is passed implicitly as a parameter to <code class="highlighter-rouge">shift</code> (you can also pass this explicitly if you like).  This thread-shifting means that all of the subsequent actions within the <code class="highlighter-rouge">for</code>-comprehension – which is to say, the <em>continuation</em> of <code class="highlighter-rouge">receive(c)</code> – will be run on the <code class="highlighter-rouge">ec</code> thread pool, rather than whatever worker pool is used internally by <code class="highlighter-rouge">Channel</code>.  This is an <em>extremely</em> common use-case in practice, and <code class="highlighter-rouge">IO</code> attempts to make it as straightforward as possible.</p>

<p>Another possible application of thread shifting is ensuring that a blocking <code class="highlighter-rouge">IO</code> action is relocated from the main, CPU-bound thread pool onto one of the pools designated for blocking IO.  An example of this would be any interaction with <code class="highlighter-rouge">java.io</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.io.</span><span class="o">{</span><span class="nc">BufferedReader</span><span class="o">,</span> <span class="nc">FileReader</span><span class="o">}</span>
<span class="c1">// import java.io.{BufferedReader, FileReader}
</span>
<span class="k">def</span> <span class="n">readLines</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Vector</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">IO</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">reader</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">name</span><span class="o">))</span>
  <span class="k">var</span> <span class="n">back</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">.</span><span class="n">empty</span>

  <span class="k">try</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">line</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="kc">null</span>
    <span class="k">do</span> <span class="o">{</span>
      <span class="n">line</span> <span class="k">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">readLine</span><span class="o">()</span>
      <span class="n">back</span> <span class="o">:+</span> <span class="n">line</span>
    <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="n">reader</span><span class="o">.</span><span class="n">close</span><span class="o">()</span>
  <span class="o">}</span>

  <span class="n">back</span>
<span class="o">}</span>
<span class="c1">// readLines: (name: String)cats.effect.IO[Vector[String]]
</span></code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Name, pls."</span><span class="o">)</span> <span class="o">}</span>
  <span class="n">name</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="nc">Console</span><span class="o">.</span><span class="n">readLine</span> <span class="o">}</span>
  <span class="n">lines</span> <span class="k">&lt;-</span> <span class="n">readLines</span><span class="o">(</span><span class="s">"names.txt"</span><span class="o">)</span>

  <span class="k">_</span> <span class="k">&lt;-</span> <span class="k">if</span> <span class="o">(</span><span class="n">lines</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">name</span><span class="o">))</span>
    <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"You're on the list, boss."</span><span class="o">)</span> <span class="o">}</span>
  <span class="k">else</span>
    <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Get outa here!"</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>Clearly, <code class="highlighter-rouge">readLines</code> is blocking the underlying thread while it waits for the disk to return the file contents to us, and for a large file, we might be blocking the thread for quite a long time!  Now if we’re treating our thread pools with respect (as described above), then we probably have a pair of <code class="highlighter-rouge">ExecutionContext</code>(s) sitting around in our code somewhere:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.util.concurrent.Executors</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nc">Main</span> <span class="k">=</span> <span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span>
<span class="k">val</span> <span class="nc">BlockingFileIO</span> <span class="k">=</span> <span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">fromExecutor</span><span class="o">(</span><span class="nc">Executors</span><span class="o">.</span><span class="n">newCachedThreadPool</span><span class="o">())</span>
</code></pre></div></div>

<p>We want to ensure that <code class="highlighter-rouge">readLines</code> runs on the <code class="highlighter-rouge">BlockingFileIO</code> pool, while everything else in the <code class="highlighter-rouge">for</code>-comprehension runs on <code class="highlighter-rouge">Main</code>.  How can we achieve this?</p>

<p>With <code class="highlighter-rouge">shift</code>!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Name, pls."</span><span class="o">)</span> <span class="o">}</span>
  <span class="n">name</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="nc">Console</span><span class="o">.</span><span class="n">readLine</span> <span class="o">}</span>
  <span class="n">lines</span> <span class="k">&lt;-</span> <span class="n">readLines</span><span class="o">(</span><span class="s">"names.txt"</span><span class="o">).</span><span class="n">shift</span><span class="o">(</span><span class="nc">BlockingFileIO</span><span class="o">).</span><span class="n">shift</span><span class="o">(</span><span class="nc">Main</span><span class="o">)</span>

  <span class="k">_</span> <span class="k">&lt;-</span> <span class="k">if</span> <span class="o">(</span><span class="n">lines</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">name</span><span class="o">))</span>
    <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"You're on the list, boss."</span><span class="o">)</span> <span class="o">}</span>
  <span class="k">else</span>
    <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Get outa here!"</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>Now we’re definitely in bizarro land.  <em>Two</em> calls to <code class="highlighter-rouge">shift</code>, one after the other?  Let’s break this apart:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">readLines</span><span class="o">(</span><span class="s">"names.txt"</span><span class="o">).</span><span class="n">shift</span><span class="o">(</span><span class="nc">BlockingFileIO</span><span class="o">)</span>
</code></pre></div></div>

<p>One of the functions of <code class="highlighter-rouge">shift</code> is to take the <code class="highlighter-rouge">IO</code> action it is given and relocate that action onto the given thread pool.  In the case of <code class="highlighter-rouge">receive</code>, this component of <code class="highlighter-rouge">shift</code> was meaningless since <code class="highlighter-rouge">receive</code> didn’t use a thread under the surface (it was asynchronous!).  However, <code class="highlighter-rouge">readLines</code> <em>does</em> use a thread under the surface (hint: it was constructed with <code class="highlighter-rouge">IO.apply</code> rather than <code class="highlighter-rouge">IO.async</code>), and so that work will be relocated onto the <code class="highlighter-rouge">BlockingFileIO</code> pool by the above expression.</p>

<p><em>Additionally</em>, the continuation of this work will also be relocated onto the <code class="highlighter-rouge">BlockingFileIO</code> pool, and that’s definitely not what we want.  The evaluation of the <code class="highlighter-rouge">contains</code> function is definitely CPU-bound, and should be run on the <code class="highlighter-rouge">Main</code> pool.  So we need to <code class="highlighter-rouge">shift</code> a second time, but only the <em>continuation</em> of the <code class="highlighter-rouge">readLines</code> action, not <code class="highlighter-rouge">readLines</code> itself.  As it turns out, we can achieve this just by adding the second <code class="highlighter-rouge">shift</code> call:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">readLines</span><span class="o">(</span><span class="s">"names.txt"</span><span class="o">).</span><span class="n">shift</span><span class="o">(</span><span class="nc">BlockingFileIO</span><span class="o">).</span><span class="n">shift</span><span class="o">(</span><span class="nc">Main</span><span class="o">)</span>
</code></pre></div></div>

<p>Now, <code class="highlighter-rouge">readLines</code> will be run on the <code class="highlighter-rouge">BlockingFileIO</code> pool, but the <em>continuation</em> of <code class="highlighter-rouge">readLines</code> (namely, everything that follows it in the <code class="highlighter-rouge">for</code>-comprehension) will be run on <code class="highlighter-rouge">Main</code>.  This works because <code class="highlighter-rouge">shift</code> creates an asynchronous <code class="highlighter-rouge">IO</code> that schedules the target action on the given thread pool and invokes its continuation <em>from a callback</em>.  The <a href="http://www.scala-lang.org/api/current/scala/concurrent/ExecutionContext.html#execute(runnable:Runnable):Unit">ExecutionContext#execute</a> function should give you an idea of how this works.  This means that the result of the first <code class="highlighter-rouge">shift</code> is an <code class="highlighter-rouge">IO</code> constructed with <code class="highlighter-rouge">async</code>, and cannot <em>itself</em> be thread-shifted (unlike an <code class="highlighter-rouge">IO</code> constructed with <code class="highlighter-rouge">apply</code>), but its continuation <em>can</em> be thread-shifted, which is exactly what happens.</p>

<p>This sort of double-<code class="highlighter-rouge">shift</code> idiom is very common in production service code that makes use of legacy blocking IO libraries such as <code class="highlighter-rouge">java.io</code>.</p>

<h3 id="synchronous-vs-asynchronous-execution">Synchronous vs Asynchronous Execution</h3>

<p>Speaking of asynchrony, readers who have been looking ahead in the class syllabus probably realized that the type signature of <code class="highlighter-rouge">unsafeRunSync()</code> is more than a little suspicious.  Specifically, it promises to give us an <code class="highlighter-rouge">A</code> <em>immediately</em> given an <code class="highlighter-rouge">IO[A]</code>; but if that <code class="highlighter-rouge">IO[A]</code> is an asynchronous action invoked with a callback, how can it achieve this promise?</p>

<p>The answer is that it blocks a thread.  (<em>gasp!!!</em>)  Under the surface, a <code class="highlighter-rouge">CountDownLatch</code> is used to block the calling thread whenever an <code class="highlighter-rouge">IO</code> is encountered that was constructed with <code class="highlighter-rouge">IO.async</code>.  Functionally, this is very similar to the <code class="highlighter-rouge">Await.result</code> function in <code class="highlighter-rouge">scala.concurrent</code>, and it is just as dangerous.  Additionally, it clearly cannot possibly work on JavaScript, since you only have one thread to block!  If you try to call <code class="highlighter-rouge">unsafeRunSync()</code> on JavaScript with an underlying <code class="highlighter-rouge">IO.async</code>, it will just throw an exception rather than deadlock your application.</p>

<p>This is not such a great state of affairs.  I mean, it <em>works</em> if <code class="highlighter-rouge">unsafeRunSync()</code> is being run in test code, or as the last line of your <code class="highlighter-rouge">main</code> function, but sometimes we need to interact with legacy code or with Java APIs that weren’t designed for purity.  Sometimes, we just <em>have</em> to evaluate our <code class="highlighter-rouge">IO</code> actions before “the end of the world”, and when we do that, we don’t want to block any of our precious threads.</p>

<p>So <code class="highlighter-rouge">IO</code> provides an additional function: <code class="highlighter-rouge">unsafeRunAsync</code>.  This function takes a callback (of type <code class="highlighter-rouge">Either[Throwable, A] =&gt; Unit</code>) which it will run when (and if) the <code class="highlighter-rouge">IO[A]</code> completes its execution.  As the name implies, this function is <em>also</em> not referentially transparent, but unlike <code class="highlighter-rouge">unsafeRunSync()</code>, it will not block a thread.</p>

<p>As a sidebar that will be important in a few paragraphs, <code class="highlighter-rouge">IO</code> also defines a <em>safe</em> function called <code class="highlighter-rouge">runAsync</code> which has a very similar signature to <code class="highlighter-rouge">unsafeRunAsync</code>, except it returns an <code class="highlighter-rouge">IO[Unit]</code>.  The <code class="highlighter-rouge">IO[Unit]</code> which is returned from this function <em>will not block</em> if you call <code class="highlighter-rouge">unsafeRunAsync()</code>.  In other words, it is always safe to call <code class="highlighter-rouge">unsafeRunSync()</code> on the results of <code class="highlighter-rouge">runAsync</code>, even on JavaScript.</p>

<p>Another way to look at this is in terms of <code class="highlighter-rouge">unsafeRunAsync</code>.  You can define <code class="highlighter-rouge">unsafeRunAsync</code> in terms of <code class="highlighter-rouge">runAsync</code> and <code class="highlighter-rouge">unsafeRunSync()</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">unsafeRunAsync</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ioa</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">cb</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">Throwable</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
  <span class="n">ioa</span><span class="o">.</span><span class="n">runAsync</span><span class="o">(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="nc">IO</span> <span class="o">{</span> <span class="n">cb</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">}).</span><span class="n">unsafeRunSync</span><span class="o">()</span>
<span class="c1">// unsafeRunAsync: [A](ioa: cats.effect.IO[A])(cb: Either[Throwable,A] =&gt; Unit)Unit
</span></code></pre></div></div>

<p>This isn’t the actual definition, but it would be a valid one, and it would run correctly on every platform.</p>

<h2 id="abstraction-and-lawfulness">Abstraction and Lawfulness</h2>

<p>As mentioned earlier (about 10000 words ago…), the cats-effect project not only provides a concrete <code class="highlighter-rouge">IO</code> type with a lot of nice features, it also provides a set of abstractions characterized by typeclasses and associated laws.  These abstractions collectively define what it means to be a type which encapsulates side-effects in a pure fashion, and they are implemented by <code class="highlighter-rouge">IO</code> as well as several other types (including <code class="highlighter-rouge">fs2.Task</code> and <code class="highlighter-rouge">monix.eval.Task</code>).  The hierarchy looks like this:</p>

<p><img src="/img/media/cats-effect-diagram.png" alt="cats-effect typeclasses" /></p>

<p><code class="highlighter-rouge">Monad</code> and <code class="highlighter-rouge">MonadError</code> are of course a part of cats-core, while everything else is in cats-effect.  <code class="highlighter-rouge">MonadError</code> is functionally equivalent to the familiar <code class="highlighter-rouge">scalaz.Catchable</code> typeclass, which was commonly used in conjunction with <code class="highlighter-rouge">scalaz.concurrent.Task</code>.  It literally means “a monad with error-handling capabilities”.  <code class="highlighter-rouge">IO</code> certainly fits that description, as any exceptions thrown within its <code class="highlighter-rouge">apply</code> method (or within <code class="highlighter-rouge">async</code>) will be caught and may be handled in pure code by means of the <code class="highlighter-rouge">attempt</code> function.  <code class="highlighter-rouge">Sync</code>, <code class="highlighter-rouge">Async</code>, <code class="highlighter-rouge">LiftIO</code> and <code class="highlighter-rouge">Effect</code> are the new typeclasses.</p>

<p><code class="highlighter-rouge">Sync</code> simply describes the <code class="highlighter-rouge">IO.apply</code> function (in the typeclasses, this function is called <code class="highlighter-rouge">delay</code>).  Which is to say, any type constructor <code class="highlighter-rouge">F[_]</code> which has a <code class="highlighter-rouge">Sync[F]</code> has the capability to suspend <em>synchronous</em> side-effecting code.  <code class="highlighter-rouge">Async</code> is very similar to this in that it describes the <code class="highlighter-rouge">async</code> function.  So any type constructor <code class="highlighter-rouge">F[_]</code> which has an <code class="highlighter-rouge">Async[F]</code> can suspend <em>asynchronous</em> side-effecting code.  <code class="highlighter-rouge">LiftIO</code> should be familiar to Haskell veterans, and is broadly useful for defining parametric signatures and composing monad transformer stacks.</p>

<p><code class="highlighter-rouge">Effect</code> is where everything is brought together.  In addition to being able to suspend synchronous and asynchronous side-effecting code, anything that has an <code class="highlighter-rouge">Effect</code> instance may also be <em>asynchronously interpreted</em> into an <code class="highlighter-rouge">IO</code>.  The way this is specified is using the <code class="highlighter-rouge">runAsync</code> function:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">Async</span><span class="o">,</span> <span class="nc">LiftIO</span><span class="o">,</span> <span class="nc">Sync</span><span class="o">}</span>

<span class="k">trait</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">with</span> <span class="nc">Async</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">with</span> <span class="nc">LiftIO</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">runAsync</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">cb</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">Throwable</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<!--    please don't remove; my editor is glitchy :-(
```
-->

<p>What this is saying is that any <code class="highlighter-rouge">Effect</code> must define the ability to evaluate as a side-effect, but of course, we don’t want to have side-effects in our pure and reasonable code.  So how are side-effects <em>purely</em> represented?  With <code class="highlighter-rouge">IO</code>!</p>

<p>From a parametric reasoning standpoint, <code class="highlighter-rouge">IO</code> means “here be effects”, and so any type signature which involves <code class="highlighter-rouge">IO</code> thus also involves side-effects (well, <em>effects</em> anyway), and any type signature which requires side-effects must also involve <code class="highlighter-rouge">IO</code>.  This bit of trickery allows us to reason about <code class="highlighter-rouge">Effect</code> in a way that would have been much harder if we had defined <code class="highlighter-rouge">unsafeRunAsync</code> as a member, and it ensures that downstream projects which write code abstracting over <code class="highlighter-rouge">Effect</code> types can do so without using any <code class="highlighter-rouge">unsafe</code> functions if they so choose (especially when taken together with the <code class="highlighter-rouge">liftIO</code> function).</p>

<h2 id="conclusion">Conclusion</h2>

<p>The lack of a production-ready <code class="highlighter-rouge">Task</code>-like type fully integrated into the cats ecosystem has been a sticking point for a lot of people considering adopting cats.  With the introduction of <a href="https://github.com/typelevel/cats-effect">cats-effect</a>, this should no longer be a problem!  As of right now, the only releases are snapshots with hash-based versions, the latest of which can be found in the maven badge at the top of the readme.  These snapshots are stable versions (in the repeatable-build sense), but they should not be considered stable, production-ready, future-proof software.  We are quickly moving towards a final 0.1 release, which will depend on cats-core and will represent the stable, finalized API.</p>

<p>Once cats releases a final 1.0 version, cats-effect will also release version 1.0 which will depend on the corresponding version of cats-core.  Changes to cats-effect are expected to be extremely rare, and thus the dependency should be considered quite stable for the purposes of upstream compatibility.  Nevertheless, the release and versioning cycle is decoupled from cats-core to account for the possibility that breaking changes may need to be made independent of the cats-core release cycle.</p>

<p>Check out the sources!  Check out the documentation.  Play around with the snapshots, and let us know what you think!  Now is the time to make your opinion heard.  If <code class="highlighter-rouge">IO</code> in its current form doesn’t meet your needs, we want to hear about it!</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Tue, 02 May 2017 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2017/05/02/io-monad-for-cats.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2017/05/02/io-monad-for-cats.html</guid>
      </item>
    
      <item>
        <title>Equivalence versus Equality</title>
        
          <dc:creator>TomasMikula</dc:creator>
                
        <description><![CDATA[<p><em>This is a guest post by Tomas Mikula. It was initially published as a <a href="https://github.com/TomasMikula/hasheq/blob/017f289caac398723501b194cd2b36c4584df638/Equivalence-Equality.md">document</a> in the <a href="https://github.com/TomasMikula/hasheq">hasheq</a>. It has been slightly edited and is being republished here with the permission of the original author.</em></p>

<p>This article describes what we mean when we say that the data structures in this library are <em>equivalence-aware</em> in a <em>type-safe</em> fashion.</p>

<h2 id="equivalence">Equivalence</h2>

<p><em>Set</em> is a data structure that doesn’t contain <em>duplicate</em> elements. An implementation of <em>Set</em> must therefore have a way to compare elements for <em>“sameness”</em>.
A useful notion of sameness is <em>equivalence</em>, i.e. a binary relation that is <em>reflexive</em>, <em>symmetric</em> and <em>transitive</em>.
Any reasonable implementation of <em>Set</em> is equipped with <em>some</em> equivalence relation on its element type.</p>

<p>Here’s the catch: For any type with more than one inhabitant there are <em>multiple</em> valid equivalence relations.
We cannot (in general) pick one that is suitable in all contexts.
For example, are these two binary trees <em>same</em>?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  +            +
 / \          / \
1   +        +   3
   / \      / \
  2   3    1   2
</code></pre></div></div>

<p>It depends on the context. They clearly have different structure, but they are both binary search trees containing the same elements.
For a balancing algorithm, they are different trees, but as an implementation of <em>Set</em>, they represent the same set of integers.</p>

<h2 id="equality">Equality</h2>

<p>Despite the non-uniqueness, there is one equivalence relation that stands out: <em>equality</em>.
Two objects are considered <em>equal</em> when they are <em>indistinguishable</em> to an observer.
Formally, equality is required to have the <em>substitution property:</em></p>

<p>\[ \forall a,b \in A, \forall f \in (A \to B): a=_A b \implies f(a)=_B f(b) \]</p>

<p>(Here, $=_A$ denotes equality on $A$, $=_B$ denotes equality on $B$.)</p>

<p>Equality is the finest equivalence: whenever two elements are <em>equal</em>, they are necessarily <em>equivalent</em> with respect to every equivalence.</p>

<h2 id="choices-in-libraries">Choices in libraries</h2>

<p>Popular Scala libraries take one of these two approaches when dealing with comparing elements for <em>“sameness”</em>.</p>

<p>The current approach of <a href="https://github.com/typelevel/cats/">cats</a> is <em>equality</em>.
Instances of the <code class="highlighter-rouge">cats.Eq[A]</code> typeclass are required to have all the properties of equality, including the substitution property above.
The problem with this approach is that for some types, such as <code class="highlighter-rouge">Set[Int]</code>, equality is too strict to be useful:
Are values <code class="highlighter-rouge">Set(1, 2)</code> and <code class="highlighter-rouge">Set(2, 1)</code> <em>equal</em>?
For that to be true, they have to be indistinguishable by any function.
Let’s try <code class="highlighter-rouge">(_.toList)</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">).</span><span class="n">toList</span> <span class="o">==</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">).</span><span class="n">toList</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</code></pre></div></div>

<p>So, <code class="highlighter-rouge">Set(1, 2)</code> and <code class="highlighter-rouge">Set(2, 1)</code> are clearly <em>not</em> equal.
As a result, we cannot use <code class="highlighter-rouge">Set[Int]</code> in a context where equality is required (without cheating).</p>

<p>On the other hand, <a href="https://github.com/scalaz/scalaz/">scalaz</a> uses unspecified <em>equivalence</em>.
Although the name <code class="highlighter-rouge">scalaz.Equal[A]</code> might suggest <em>equality</em>, instances of this typeclass are only tested for properties of <em>equivalence</em>.
As mentioned above, there are multiple <em>valid</em> equivalence relations for virtually any type.
When there are also multiple <em>useful</em> equivalences for a type, we are at risk of mixing them up (and the fact that they are usually resolved as implicit arguments only makes things worse).</p>

<h2 id="equivalence-aware-sets-aka-setoids">Equivalence-aware sets (a.k.a. setoids)</h2>

<p>Let’s look at how <em>we</em> deal with this issue. We define typeclass <code class="highlighter-rouge">Equiv</code> with an extra type parameter that serves as a <em>“tag”</em> identifying the meaning of the equivalence.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Equiv</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Eq</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">equiv</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="o">}</span>
<span class="c1">// defined trait Equiv
</span></code></pre></div></div>

<p>For the compiler, the “tag” is an opaque type. It only has specific meaning for humans. The only meaning it has for the compiler is that different tags represent (intensionally) different equivalence relations.</p>

<p>An <em>equivalence-aware</em> data structure then carries in its <em>type</em> the tag of the equivalence it uses.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">hasheq._</span>
<span class="c1">// import hasheq._
</span>
<span class="k">import</span> <span class="nn">hasheq.immutable._</span>
<span class="c1">// import hasheq.immutable._
</span>
<span class="k">import</span> <span class="nn">hasheq.std.int._</span>
<span class="c1">// import hasheq.std.int._
</span></code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">HashSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HashSetoid</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>

<p>What on earth is <code class="highlighter-rouge">HashSetoid</code>?
A <a href="https://en.wikipedia.org/wiki/Setoid"><em>setoid</em></a> is an <em>equivalence-aware set</em>.
<code class="highlighter-rouge">HashSetoid</code> is then just a setoid implementated using hash-table.
Let’s look at the definition of <code class="highlighter-rouge">HashSet</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">HashSet</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HashSetoid</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Equality.</span><span class="k">type</span><span class="o">]</span>
</code></pre></div></div>

<p>So <code class="highlighter-rouge">HashSet</code> is just a <code class="highlighter-rouge">HashSetoid</code> whose equivalence is <em>equality</em>.
To create an instance of <code class="highlighter-rouge">HashSet[Int]</code> above, we needed to have an implicit instance of <code class="highlighter-rouge">Equiv[Int, Equality.type]</code> in scope.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">implicitly</span><span class="o">[</span><span class="kt">Equiv</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Equality.</span><span class="k">type</span><span class="o">]]</span>
</code></pre></div></div>

<p>For the compiler, <code class="highlighter-rouge">Equality</code> is just a rather arbitrary singleton object.
It only has the meaning of mathematical <em>equality</em> for us, humans.</p>

<p>There is a convenient type alias provided for <em>equality</em> relation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Equiv</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Equality.</span><span class="k">type</span><span class="o">]</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">implicitly</span><span class="o">[</span><span class="kt">Equal</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span>
</code></pre></div></div>

<p>So how do we deal with the problem of set equality mentioned above, i.e. that <code class="highlighter-rouge">HashSet(1, 2)</code> and <code class="highlighter-rouge">HashSet(2, 1)</code> are not truly <em>equal</em>?
We just don’t provide a definition of equality for <code class="highlighter-rouge">HashSet[Int]</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">Equal</span><span class="o">[</span><span class="kt">HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]]</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">22</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">could</span> <span class="kt">not</span> <span class="kt">find</span> <span class="kt">implicit</span> <span class="kt">value</span> <span class="kt">for</span> <span class="kt">parameter</span> <span class="kt">e:</span> <span class="kt">hasheq.Equal</span><span class="o">[</span><span class="kt">hasheq.immutable.HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span>
       <span class="n">implicitly</span><span class="o">[</span><span class="kt">Equal</span><span class="o">[</span><span class="kt">HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]]</span>
                 <span class="o">^</span>
</code></pre></div></div>

<p>But that means we cannot have a <code class="highlighter-rouge">HashSet[HashSet[Int]]</code>!
(Remember, for a <code class="highlighter-rouge">HashSet[A]</code>, we need an instance of <code class="highlighter-rouge">Equal[A]</code>, and we just showed we don’t have an instance of <code class="highlighter-rouge">Equal[HashSet[Int]]</code>.)</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">HashSet</span><span class="o">(</span><span class="nc">HashSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">22</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">could</span> <span class="kt">not</span> <span class="kt">find</span> <span class="kt">implicit</span> <span class="kt">value</span> <span class="kt">for</span> <span class="kt">parameter</span> <span class="kt">A:</span> <span class="kt">hasheq.Hash</span><span class="o">[</span><span class="kt">hasheq.immutable.HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span>
       <span class="nc">HashSet</span><span class="o">(</span><span class="nc">HashSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
              <span class="o">^</span>
</code></pre></div></div>

<p>But we can have a <code class="highlighter-rouge">HashSetoid[HashSet[Int], E]</code>, where <code class="highlighter-rouge">E</code> is <em>some</em> equivalence on <code class="highlighter-rouge">HashSet[Int]</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">HashSet</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">HashSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSetoid</span><span class="o">[</span><span class="kt">hasheq.immutable.HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>,<span class="kt">hasheq.immutable.Setoid.ContentEquiv</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">hasheq.Equality.</span><span class="k">type</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">HashSetoid</span><span class="o">(</span><span class="nc">HashSetoid</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">))</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">HashSet.of(elems)</code> is like <code class="highlighter-rouge">HashSet(elems)</code>, except it tries to infer the equivalence on the element type, instead of requiring it to be equality.</p>

<p>Notice the <em>equivalence tag</em>: <code class="highlighter-rouge">Setoid.ContentEquiv[Int, Equality.type]</code>.
Its meaning is (again, for humans only) that two setoids are equivalent when they contain the same elements (here, of type <code class="highlighter-rouge">Int</code>), as compared by the given equivalence of elements (here, <code class="highlighter-rouge">Equality</code>).</p>

<p>The remaining question is: How does this work in the presence of <em>multiple useful equivalences?</em></p>

<p>Let’s define another equivalence on <code class="highlighter-rouge">Int</code> (in addition to the provided equality).</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Our "tag" for equivalence modulo 10.
// This trait will never be instantiated.
</span><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Mod10</span>

<span class="c1">// Provide equivalence tagged by Mod10.
</span><span class="k">implicit</span> <span class="k">object</span> <span class="nc">EqMod10</span> <span class="k">extends</span> <span class="nc">Equiv</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Mod10</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">mod10</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">10</span>
    <span class="k">else</span> <span class="n">r</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">equiv</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">mod10</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">==</span> <span class="n">mod10</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// Provide hash function compatible with equivalence modulo 10.
// Note that the HashEq typeclass is also tagged by Mod10.
</span><span class="k">implicit</span> <span class="k">object</span> <span class="nc">HashMod10</span> <span class="k">extends</span> <span class="nc">HashEq</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Mod10</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">hash</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nc">EqMod10</span><span class="o">.</span><span class="n">mod10</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now let’s create a “setoid of sets of integers”, as before.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">HashSet</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">HashSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSetoid</span><span class="o">[</span><span class="kt">hasheq.immutable.HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>,<span class="kt">hasheq.immutable.Setoid.ContentEquiv</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">hasheq.Equality.</span><span class="k">type</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">HashSetoid</span><span class="o">(</span><span class="nc">HashSetoid</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">))</span>
</code></pre></div></div>

<p>This still works, because <code class="highlighter-rouge">HashSet</code> requires an <em>equality</em> on <code class="highlighter-rouge">Int</code>, and there is only one in the implicit scope (the newly defined equivalence <code class="highlighter-rouge">EqMod10</code> is <em>not</em> equality).
Let’s try to create a “setoid of setoids of integers”:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">HashSet</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">HashSet</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">24</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">ambiguous</span> <span class="kt">implicit</span> <span class="kt">values:</span>
 <span class="kt">both</span> <span class="kt">method</span> <span class="kt">hashInstance</span> <span class="kt">in</span> <span class="kt">object</span> <span class="kt">int</span> <span class="kt">of</span> <span class="k">type</span> <span class="o">=&gt;</span> <span class="n">hasheq</span><span class="o">.</span><span class="nc">Hash</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
 <span class="n">and</span> <span class="k">object</span> <span class="nc">HashMod10</span> <span class="n">of</span> <span class="k">type</span> <span class="kt">HashMod10.type</span>
 <span class="k">match</span> <span class="n">expected</span> <span class="k">type</span> <span class="kt">hasheq.HashEq</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Eq</span><span class="o">]</span>
       <span class="nc">HashSet</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">HashSet</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
                            <span class="o">^</span>
</code></pre></div></div>

<p>This fails, because there are now more equivalences on <code class="highlighter-rouge">Int</code> in scope.
(There are now also multiple hash functions, which is what the error message actually says.)
We need to be more specific:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">HashSet</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">HashSet</span><span class="o">.</span><span class="n">of</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Mod10</span><span class="o">](</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSetoid</span><span class="o">[</span><span class="kt">hasheq.immutable.HashSetoid</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Mod10</span><span class="o">]</span>,<span class="kt">hasheq.immutable.Setoid.ContentEquiv</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Mod10</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">HashSetoid</span><span class="o">(</span><span class="nc">HashSetoid</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">))</span>
</code></pre></div></div>

<p>Finally, does it <strong>prevent mixing up equivalences</strong>? Let’s see:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">s1</span> <span class="k">=</span> <span class="nc">HashSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span>  <span class="mi">2</span><span class="o">,</span>  <span class="mi">3</span><span class="o">,</span>         <span class="mi">11</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">13</span>    <span class="o">)</span>
<span class="n">s1</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HashSetoid</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">13</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">11</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">s2</span> <span class="k">=</span> <span class="nc">HashSet</span><span class="o">(</span>    <span class="mi">2</span><span class="o">,</span>  <span class="mi">3</span><span class="o">,</span>  <span class="mi">4</span><span class="o">,</span>  <span class="mi">5</span><span class="o">,</span>         <span class="mi">13</span><span class="o">,</span> <span class="mi">14</span><span class="o">)</span>
<span class="n">s2</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HashSetoid</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">13</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">t1</span> <span class="k">=</span> <span class="nc">HashSet</span><span class="o">.</span><span class="n">of</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Mod10</span><span class="o">](</span><span class="mi">1</span><span class="o">,</span>  <span class="mi">2</span><span class="o">,</span>  <span class="mi">3</span><span class="o">,</span>         <span class="mi">11</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">13</span>    <span class="o">)</span>
<span class="n">t1</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSetoid</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Mod10</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HashSetoid</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">t2</span> <span class="k">=</span> <span class="nc">HashSet</span><span class="o">.</span><span class="n">of</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Mod10</span><span class="o">](</span>    <span class="mi">2</span><span class="o">,</span>  <span class="mi">3</span><span class="o">,</span>  <span class="mi">4</span><span class="o">,</span>  <span class="mi">5</span><span class="o">,</span>         <span class="mi">13</span><span class="o">,</span> <span class="mi">14</span><span class="o">)</span>
<span class="n">t2</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSetoid</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Mod10</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HashSetoid</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>

<p>Combining compatible setoids:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">s1</span> <span class="n">union</span> <span class="n">s2</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSetoid</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">hasheq.Equality.</span><span class="k">type</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HashSetoid</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">13</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">t1</span> <span class="n">union</span> <span class="n">t2</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSetoid</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Mod10</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HashSetoid</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>

<p>Combining incompatible setoids:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">s1</span> <span class="n">union</span> <span class="n">t2</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">26</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">hasheq.immutable.HashSetoid</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Mod10</span><span class="o">]</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSetoid</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">hasheq.Equality.</span><span class="k">type</span><span class="o">]</span>
       <span class="n">s1</span> <span class="n">union</span> <span class="n">t2</span>
                <span class="o">^</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">t1</span> <span class="n">union</span> <span class="n">s2</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">26</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">hasheq.immutable.HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
    <span class="o">(</span><span class="n">which</span> <span class="n">expands</span> <span class="n">to</span><span class="o">)</span>  <span class="n">hasheq</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">HashSetoid</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">hasheq.Equality.</span><span class="k">type</span><span class="o">]</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">hasheq.immutable.HashSetoid</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Mod10</span><span class="o">]</span>
       <span class="n">t1</span> <span class="n">union</span> <span class="n">s2</span>
                <span class="o">^</span>
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>We went one step further in the direction of type-safe equivalence in Scala compared to what is typically seen out in the wild today.
There is nothing very sophisticated about this encoding.
I think the major win is that we can design APIs so that the extra type parameter (the “equivalence tag”) stays unnoticed by the user of the API as long as they only deal with <em>equalities</em>.
As soon as the equivalence tag starts requesting our attention (via an ambiguous implicit or a type error), it is likely that the attention is justified.</p>

<p><em>This article was tested with Scala 2.11.8 and hasheq version 0.3.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 02 Apr 2017 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2017/04/02/equivalence-vs-equality.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2017/04/02/equivalence-vs-equality.html</guid>
      </item>
    
      <item>
        <title>Four ways to escape a cake</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>The mixin style of importing in which classes and traits are defined
within traits, as seen in <code class="highlighter-rouge">scala.reflect.Universe</code>, ScalaTest, and
other Scala styles, seems to be infectious. By that, I mean once you
define something in a trait to be mixed in, to produce another
reusable module that calls that thing, you must define <em>another</em>
trait, and so must anyone using <em>your</em> module, and so on and so forth.
You effectively become “trapped in the cake”.</p>

<p>However, we can use type parameters that represent <strong>singleton types</strong>
to write functions that are polymorphic over these “cakes”, without
being defined as part of them or mixed in themselves. For example, you
can use this to write functions that operate on elements of a
reflection universe, without necessarily passing that universe around
all over the place.</p>

<p>Well, for the most part. Let’s see how far this goes.</p>

<h2 id="our-little-universe">Our little universe</h2>

<p>Let’s set aside the heavyweight real-world examples I mentioned above
in favor of a small example. Then, we should be able to explore the
possibilities in this simpler space.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">LittleUniverse</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">haystack</span><span class="k">:</span> <span class="kt">Haystack</span> <span class="o">=</span> <span class="nc">Haystack</span><span class="o">()</span>

  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Haystack</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">init</span><span class="k">:</span> <span class="kt">Needle</span> <span class="o">=</span> <span class="nc">Needle</span><span class="o">()</span>
    <span class="k">def</span> <span class="n">iter</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Needle</span><span class="o">)</span><span class="k">:</span> <span class="kt">Needle</span> <span class="o">=</span> <span class="n">n</span>
  <span class="o">}</span>
  
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Needle</span><span class="o">()</span>
<span class="o">}</span>
</code></pre></div></div>

<p><em>For brevity, I’ve defined member <code class="highlighter-rouge">class</code>es, but this article equally
applies if you are using abstract <code class="highlighter-rouge">type</code>s instead, as any Functional
programmer of pure, virtuous heart ought to!</em></p>

<p>Suppose we have a universe.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">lu</span><span class="k">:</span> <span class="kt">LittleUniverse</span> <span class="o">=</span> <span class="nc">LittleUniverse</span><span class="o">()</span>
<span class="n">lu</span><span class="k">:</span> <span class="kt">LittleUniverse</span> <span class="o">=</span> <span class="nc">LittleUniverse</span><span class="o">()</span>
</code></pre></div></div>

<p>The thing that Scala does for us is not let <code class="highlighter-rouge">Haystack</code>s and <code class="highlighter-rouge">Needle</code> s
from one universe be confused with those from another.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">anotherU</span> <span class="k">=</span> <span class="nc">LittleUniverse</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">lu</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">anotherU</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">init</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">anotherU.Needle</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">lu.Needle</span>
       <span class="n">lu</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">anotherU</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">init</span><span class="o">)</span>
                                          <span class="o">^</span>
</code></pre></div></div>

<p>The meaning of this error is “you can’t use one universe’s <code class="highlighter-rouge">Haystack</code>
to <code class="highlighter-rouge">iter</code> a <code class="highlighter-rouge">Needle</code> from another universe”.</p>

<p>This doesn’t look very important given the above code, but it’s a
<em>real</em> boon to more complex scenarios. You can set up a lot of
interdependent abstract invariants, verify them all, and have the
whole set represented with the “index” formed by the singleton type,
here <code class="highlighter-rouge">lu.type</code> or <code class="highlighter-rouge">anotherU.type</code>.</p>

<h2 id="working-with-a-universe-on-hand">Working with a universe on hand</h2>

<p>Refactoring in macro-writing style seems to be based upon passing the
universe around everywhere. We can do that.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">twoInits</span><span class="o">(</span><span class="n">u</span><span class="k">:</span> <span class="kt">LittleUniverse</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">u.Needle</span><span class="o">,</span> <span class="kt">u.Needle</span><span class="o">)</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">init</span><span class="o">,</span> <span class="n">u</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">init</span><span class="o">)</span>
  
<span class="k">def</span> <span class="n">stepTwice</span><span class="o">(</span><span class="n">u</span><span class="k">:</span> <span class="kt">LittleUniverse</span><span class="o">)(</span><span class="n">n</span><span class="k">:</span> <span class="kt">u.Needle</span><span class="o">)</span><span class="k">:</span> <span class="kt">u.Needle</span> <span class="o">=</span>
  <span class="n">u</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
</code></pre></div></div>

<p>The most important feature we’re reaching for with these fancy
dependent method types, and the one that we have to <em>keep</em> reaching
for if we want to write sane functions outside the cake, is
<strong>preserving the singleton type index</strong>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">twoInits</span><span class="o">(</span><span class="n">lu</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="o">(</span><span class="kt">lu.Needle</span><span class="o">,</span> <span class="kt">lu.Needle</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="nc">Needle</span><span class="o">(),</span><span class="nc">Needle</span><span class="o">())</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stepTwice</span><span class="o">(</span><span class="n">anotherU</span><span class="o">)(</span><span class="n">anotherU</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">init</span><span class="o">)</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">anotherU.Needle</span> <span class="o">=</span> <span class="nc">Needle</span><span class="o">()</span>
</code></pre></div></div>

<p>These values are ready for continued <code class="highlighter-rouge">iter</code>ing, or whatever else
you’ve come up with, in the confines of their respective
universes. That’s because they’ve “remembered” where they came from.</p>

<p>By contrast, consider a simple replacement of the path-dependencies
with a type projection.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">brokenTwoInits</span><span class="o">(</span><span class="n">u</span><span class="k">:</span> <span class="kt">LittleUniverse</span><span class="o">)</span>
    <span class="k">:</span> <span class="o">(</span><span class="kt">LittleUniverse</span><span class="k">#</span><span class="kt">Needle</span><span class="o">,</span> <span class="kt">LittleUniverse</span><span class="k">#</span><span class="kt">Needle</span><span class="o">)</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">init</span><span class="o">,</span> <span class="n">u</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">init</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bti</span> <span class="k">=</span> <span class="n">brokenTwoInits</span><span class="o">(</span><span class="n">lu</span><span class="o">)</span>
<span class="n">bti</span><span class="k">:</span> <span class="o">(</span><span class="kt">LittleUniverse</span><span class="k">#</span><span class="kt">Needle</span><span class="o">,</span> <span class="kt">LittleUniverse</span><span class="k">#</span><span class="kt">Needle</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="nc">Needle</span><span class="o">(),</span><span class="nc">Needle</span><span class="o">())</span>
</code></pre></div></div>

<p>That seems to be okay, until it’s time to actually use the result.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">lu</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">bti</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">LittleUniverse</span><span class="k">#</span><span class="kt">Needle</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">lu.Needle</span>
       <span class="n">lu</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">bti</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
                            <span class="o">^</span>
</code></pre></div></div>

<p>The return type of <code class="highlighter-rouge">brokenTwoInits</code> “forgot” the index, <code class="highlighter-rouge">lu.type</code>.</p>

<h2 id="getting-two-needles-without-a-universe">Getting two needles without a universe</h2>

<p>When we pass a <code class="highlighter-rouge">LittleUniverse</code> to the above functions, we’re also
kind of passing in a constraint on the singleton type created by the
argument variable. That’s how we know that the returned <code class="highlighter-rouge">u.Needle</code> is
a perfectly acceptable <code class="highlighter-rouge">lu.Needle</code> in the caller scope, when we pass
<code class="highlighter-rouge">lu</code> as the universe.</p>

<p>However, as the contents of a universe become more complex, there are
many more interactions that need not involve a universe at all, at
least not directly.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">twoInitsFromAHaystack</span><span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span><span class="o">](</span>
    <span class="n">h</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Haystack</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span><span class="o">,</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span><span class="o">)</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="n">init</span><span class="o">,</span> <span class="n">h</span><span class="o">.</span><span class="n">init</span><span class="o">)</span>
  
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">tifah</span> <span class="k">=</span> <span class="n">twoInitsFromAHaystack</span><span class="o">[</span><span class="kt">lu.</span><span class="k">type</span><span class="o">](</span><span class="n">lu</span><span class="o">.</span><span class="n">haystack</span><span class="o">)</span>
<span class="n">tifah</span><span class="k">:</span> <span class="o">(</span><span class="kt">lu.Needle</span><span class="o">,</span> <span class="kt">lu.Needle</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="nc">Needle</span><span class="o">(),</span><span class="nc">Needle</span><span class="o">())</span>
</code></pre></div></div>

<p>Since we didn’t pass in <code class="highlighter-rouge">lu</code>, how did it know that the returned
<code class="highlighter-rouge">Needle</code>s were <code class="highlighter-rouge">lu.Needle</code>s?</p>

<ol>
  <li>The type of <code class="highlighter-rouge">lu.haystack</code> is <code class="highlighter-rouge">lu.Haystack</code>.</li>
  <li>That type is shorthand for <code class="highlighter-rouge">lu.type#Haystack</code>.</li>
  <li>We passed in <code class="highlighter-rouge">U = lu.type</code>, and our argument meets the resulting
requirement for a <code class="highlighter-rouge">lu.type#Haystack</code> (after expanding <code class="highlighter-rouge">U</code>).</li>
  <li>The type of the expression <code class="highlighter-rouge">h.init</code> is
<code class="highlighter-rouge">u.Needle forSome {val u: U}</code>. We use an existential because the
relevant variable (and its singleton type) is not in scope.</li>
  <li>This type <em>widens</em> to <code class="highlighter-rouge">U#Needle</code>, satisfying the expected return
type.</li>
</ol>

<p>This seems like a more complicated way of doing things, but it’s very
freeing: by not being forced to <em>necessarily</em> pass the universe around
everywhere, you’ve managed to escape the cake’s clutches much more
thoroughly. You can also write syntax enrichments on various members
of the universe that don’t need to talk about the universe’s value,
just its singleton type.</p>

<p>Unless, you know, the index appears in contravariant position.</p>

<h2 id="syntactic-steptwice">Syntactic <code class="highlighter-rouge">stepTwice</code></h2>

<p>One test of how well we’ve managed to escape the cake is to be able to
write enrichments that deal with the universe. This is a little
tricky, but quite doable if you have the universe’s value.</p>

<p>With the advent of <code class="highlighter-rouge">implicit class</code>, this became a little easier to do
wrongly, but it’s a good start.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">class</span> <span class="nc">NonWorkingStepTwice</span><span class="o">(</span><span class="k">val</span> <span class="n">u</span><span class="k">:</span> <span class="kt">LittleUniverse</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">stepTwiceOops</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">u.Needle</span><span class="o">)</span><span class="k">:</span> <span class="kt">u.Needle</span> <span class="o">=</span>
    <span class="n">u</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>That compiles okay, but seemingly can’t actually be used!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">lu</span> <span class="n">stepTwiceOops</span> <span class="n">lu</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">init</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">15</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">lu.Needle</span>
 <span class="n">required</span><span class="k">:</span> <span class="k">_</span><span class="err">1</span><span class="kt">.u.Needle</span> <span class="kt">where</span> <span class="kt">val</span> <span class="k">_</span><span class="err">1</span><span class="kt">:</span> <span class="kt">NonWorkingStepTwice</span>
       <span class="n">lu</span> <span class="n">stepTwiceOops</span> <span class="n">lu</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">init</span>
                                    <span class="o">^</span>
</code></pre></div></div>

<p>There’s a hint in that we had to write <code class="highlighter-rouge">val u</code>, not <code class="highlighter-rouge">u</code>, nor <code class="highlighter-rouge">private
val u</code>, in order for the <code class="highlighter-rouge">implicit class</code> itself to compile. This
signature tells us that there’s an <em>argument</em> of type
<code class="highlighter-rouge">LittleUniverse</code>, and a <em>member</em> <code class="highlighter-rouge">u: LittleUniverse</code>. However, whereas
with the function examples above, we [and the compiler] could trust
that they’re one and the same, we have no such guarantee here. So we
don’t know that an <code class="highlighter-rouge">lu.Needle</code> is a <code class="highlighter-rouge">u.Needle</code>. We didn’t get far
enough, but we don’t know that a <code class="highlighter-rouge">u.Needle</code> is an <code class="highlighter-rouge">lu.Needle</code>, either.</p>

<h2 id="relatable-variables">Relatable variables</h2>

<p>Instead, we have to expand a little bit, and take advantage of a very
interesting, if obscure, element of the type equivalence rules in the
Scala language.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">WorkingStepTwice</span><span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span><span class="o">](</span><span class="k">val</span> <span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">stepTwice</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">u.Needle</span><span class="o">)</span><span class="k">:</span> <span class="kt">u.Needle</span> <span class="o">=</span>
    <span class="n">u</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nc">WorkingStepTwice</span><span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span><span class="o">](</span><span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span>
    <span class="k">:</span> <span class="kt">WorkingStepTwice</span><span class="o">[</span><span class="kt">u.</span><span class="k">type</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">WorkingStepTwice</span><span class="o">(</span><span class="n">u</span><span class="o">)</span>
</code></pre></div></div>

<p><em>Unfortunately, the ritual of expanding the <code class="highlighter-rouge">implicit class</code> shorthand
is absolutely necessary; the <code class="highlighter-rouge">implicit class</code> won’t generate the
dependent-method-typed implicit conversion we need.</em></p>

<p>Now we can get the proof we need.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">lu</span> <span class="n">stepTwice</span> <span class="n">lu</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">init</span>
<span class="n">res7</span><span class="k">:</span> <span class="k">_</span><span class="err">1</span><span class="kt">.u.Needle</span> <span class="k">forSome</span> <span class="o">{</span> <span class="kt">val</span> <span class="k">_</span><span class="err">1</span><span class="kt">:</span> <span class="kt">WorkingStepTwice</span><span class="o">[</span><span class="kt">lu.</span><span class="k">type</span><span class="o">]</span> <span class="o">}</span> <span class="k">=</span> <span class="nc">Needle</span><span class="o">()</span>

<span class="c1">// that's a little weird, but reduces to what we need
</span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">res7</span><span class="k">:</span> <span class="kt">lu.Needle</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">lu.Needle</span> <span class="o">=</span> <span class="nc">Needle</span><span class="o">()</span>
</code></pre></div></div>

<p>How does this work?</p>

<ol>
  <li>Implicitly convert <code class="highlighter-rouge">lu</code>, giving us a <code class="highlighter-rouge">conv:
WorkingStepTwice[lu.type]</code>.</li>
  <li>This means that <code class="highlighter-rouge">conv.u: lu.type</code>, by expansion of <code class="highlighter-rouge">U</code>.</li>
  <li>This in turn means that <code class="highlighter-rouge">conv.u.type &lt;: lu.type</code>.</li>
</ol>

<p>The next part is worth taking in two parts. It may be worth
having
<a href="http://www.scala-lang.org/files/archive/spec/2.12/03-types.html#conformance">§3.5.2 “Conformance”</a> of
the language spec open for reference. First, let’s consider the return
type (a covariant position), which is simpler.</p>

<ol>
  <li>The return type expands to <code class="highlighter-rouge">conv.u.type#Needle</code>.</li>
  <li>The ninth conformance bullet point tells us that the left side of a
<code class="highlighter-rouge">#</code> projection is covariant, so because <code class="highlighter-rouge">conv.u.type &lt;: lu.type</code>
(see above), the return type <em>widens</em> to <code class="highlighter-rouge">lu.type#Needle</code>.</li>
  <li>For this, <code class="highlighter-rouge">lu.Needle</code> is a shorthand.</li>
</ol>

<p>It was far longer until I realized how the argument type works. You’ll
want to scroll up on the SLS a bit, to the “Equivalence” section. Keep
in mind that we are trying to widen <code class="highlighter-rouge">lu.Needle</code> to <code class="highlighter-rouge">conv.u.Needle</code>,
which is the reverse of what we did for the return type.</p>

<ol>
  <li>Our argument’s type expands to <code class="highlighter-rouge">lu.type#Needle</code>.</li>
  <li>The second bullet point under “Equivalence” says that “If a path
<em>p</em> has a singleton type <em>q</em><code class="highlighter-rouge">.type</code>, then <em>p</em><code class="highlighter-rouge">.type</code> ≡ <em>q</em><code class="highlighter-rouge">.type</code>.”
From this, we can derive that <code class="highlighter-rouge">conv.u.type = lu.type</code>. This is a
stronger conclusion than we reached above!</li>
  <li>We substitute the left side of the <code class="highlighter-rouge">#</code> using the equivalence,
giving us <code class="highlighter-rouge">conv.u.type#Needle</code>.</li>
</ol>

<p>I cannot characterize this feature of the type system as anything
other than “really freaky” when you first encounter it. It seems like
an odd corner case. Normally, when you write <code class="highlighter-rouge">val x: T</code>, then <code class="highlighter-rouge">x.type</code>
is a <em>strict</em> subtype of <code class="highlighter-rouge">T</code>, and you can count on that, but this
carves out an exception to that rule. It is sound, though, and an
absolutely essential feature!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">sameLu</span><span class="k">:</span> <span class="kt">lu.</span><span class="k">type</span> <span class="o">=</span> <span class="n">lu</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">sameLu</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">lu</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">init</span><span class="o">)</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">sameLu.Needle</span> <span class="o">=</span> <span class="nc">Needle</span><span class="o">()</span>
</code></pre></div></div>

<p>Without this rule, even though we have given it the most specific type
possible, <code class="highlighter-rouge">sameLu</code> couldn’t be a <em>true</em> substitute for <code class="highlighter-rouge">lu</code> in all
scenarios. That means that in order to make use of singleton type
indices, we would be forever beholden to the <em>variable</em> we initially
stored the value in. I think this would be <em>extremely inconvenient</em>,
structurally, in almost all useful programs.</p>

<p>With the rule in place, we can fully relate the <code class="highlighter-rouge">lu</code> and <code class="highlighter-rouge">conv.u</code>
variables, to let us reorganize how we talk about universes and values
indexed by their singleton types in many ways.</p>

<h2 id="a-pointless-argument">A pointless argument</h2>

<p>Let’s try to hide the universe. We don’t need it, after all. We can’t
refer to <code class="highlighter-rouge">u</code> in the method signature anymore, so let’s try the same
conversion we used with <code class="highlighter-rouge">twoInitsFromAHaystack</code>. We already have the
<code class="highlighter-rouge">U</code> type parameter, after all.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CleanerStepTwice</span><span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span><span class="o">](</span><span class="k">private</span> <span class="k">val</span> <span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">stepTwiceLively</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span> <span class="o">=</span>
    <span class="o">???</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nc">CleanerStepTwice</span><span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span><span class="o">](</span><span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span>
    <span class="k">:</span> <span class="kt">CleanerStepTwice</span><span class="o">[</span><span class="kt">u.</span><span class="k">type</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">CleanerStepTwice</span><span class="o">(</span><span class="n">u</span><span class="o">)</span>
</code></pre></div></div>

<p>This has the proper signature, and it’s cleaner, since we don’t expose
the unused-at-runtime <code class="highlighter-rouge">u</code> variable anymore. We could refine a little
further, and replace it with a <code class="highlighter-rouge">U#Haystack</code>, just as with
<code class="highlighter-rouge">twoInitsFromAHaystack</code>.</p>

<p>This gives us the same interface, with all the index preservation we
need. Even better, it infers a nicer return type.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">trial</span> <span class="k">=</span> <span class="n">lu</span> <span class="n">stepTwiceLively</span> <span class="n">lu</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">init</span>
<span class="n">trial</span><span class="k">:</span> <span class="kt">lu.Needle</span>
</code></pre></div></div>

<p>Now, let’s turn to implementation.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">OnceMoreStepTwice</span><span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span><span class="o">](</span><span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">stepTwiceFinally</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span> <span class="o">=</span>
    <span class="n">u</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
<span class="o">}</span>

<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">18</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">OnceMoreStepTwice.this.u.Needle</span>
           <span class="n">u</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
                                           <span class="o">^</span>
</code></pre></div></div>

<p>This is the last part of the escape! If this worked, we could <em>fully
erase</em> the <code class="highlighter-rouge">LittleUniverse</code> from most code, relying on the pure
type-level index to prove enough of its existence! So it’s a little
frustrating that it doesn’t quite work.</p>

<p>Let’s break it down. First, the return type is fine.</p>

<ol>
  <li>Since <code class="highlighter-rouge">u: U</code>, <code class="highlighter-rouge">u.type &lt;: U</code>. (This is true, and useful, in the
scope of <code class="highlighter-rouge">u</code>, which is now invisible to the caller.)</li>
  <li><code class="highlighter-rouge">iter</code> returns a <code class="highlighter-rouge">u.type#Needle</code>.
    <ul>
      <li>Note: since <code class="highlighter-rouge">u</code> is not in scope for the caller, if we returned
this as is, it would effectively widen to the existentially
bound <code class="highlighter-rouge">u.type#Needle forSome {val u: U}</code>. But the same logic in
the next step would apply to that type.</li>
    </ul>
  </li>
  <li>By the <code class="highlighter-rouge">#</code> left side covariance, <code class="highlighter-rouge">u.type#Needle</code> widens to
<code class="highlighter-rouge">U#Needle</code>.</li>
</ol>

<p>Pretty simple, by the standards of what we’ve seen so far.</p>

<h2 id="contravariance-is-the-root-of-all">Contravariance is the root of all…</h2>

<p>But things break down when we try to call <code class="highlighter-rouge">iter(n)</code>. Keep in mind that
<code class="highlighter-rouge">n: U#Needle</code> and the expected type is <code class="highlighter-rouge">u.Needle</code>. Specifically: since
we don’t know in the implementation that <code class="highlighter-rouge">U</code> is a singleton type, we
can’t use the “singleton type equivalence” rule on it! But suppose
that we <em>could</em>; that is, <strong>suppose that we could constrain <code class="highlighter-rouge">U</code> to be
a singleton type</strong>.</p>

<ol>
  <li>The argument type is <code class="highlighter-rouge">U#Needle</code>.</li>
  <li>By singleton equivalence, since <code class="highlighter-rouge">u: U</code> and <code class="highlighter-rouge">u</code> is stable, so
<code class="highlighter-rouge">u.type = U</code>.</li>
  <li>By substituting the left-hand side of the <code class="highlighter-rouge">#</code>, we get
<code class="highlighter-rouge">u.type#Needle</code>.</li>
  <li>This shortens to <code class="highlighter-rouge">u.Needle</code>.</li>
</ol>

<p>If we are unable to constrain <code class="highlighter-rouge">U</code> in this way, though, we are
restricted to places where <code class="highlighter-rouge">U</code> occurs in covariant position when using
cake-extracted APIs.  We can invoke functions like <code class="highlighter-rouge">init</code>, because
they only have the singleton index occurring in covariant position.</p>

<p>Invoking functions like <code class="highlighter-rouge">iter</code>, where the index occurs in
contravariant or invariant position, requires being able to add this
constraint, so that we can use singleton equivalence directly on the
type variable <code class="highlighter-rouge">U</code>.  This is quite a bit trickier.</p>

<h2 id="extracting-more-types">Extracting more types</h2>

<p>We have the same problem with the function version.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">stepTwiceHaystack</span><span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span><span class="o">](</span>
    <span class="n">h</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Haystack</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span> <span class="o">=</span>
  <span class="n">h</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>

<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">18</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span>
 <span class="n">required</span><span class="k">:</span> <span class="k">_</span><span class="err">1</span><span class="kt">.Needle</span> <span class="kt">where</span> <span class="kt">val</span> <span class="k">_</span><span class="err">1</span><span class="kt">:</span> <span class="kt">U</span>
         <span class="n">h</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
                       <span class="o">^</span>
</code></pre></div></div>

<p>Let’s walk through it one more time.</p>

<ol>
  <li><code class="highlighter-rouge">n: U#Needle</code>.</li>
  <li><code class="highlighter-rouge">h.iter</code> expects a <code class="highlighter-rouge">u.type#Needle</code> for all <code class="highlighter-rouge">val u: U</code>.</li>
  <li><strong>Suppose that we constrain <code class="highlighter-rouge">U</code> to be a singleton type</strong>:
    <ol>
      <li>[The existential] <code class="highlighter-rouge">u.type = U</code>, by singleton equivalence.</li>
      <li>By <code class="highlighter-rouge">#</code> left side equivalence, <code class="highlighter-rouge">h.iter</code> expects a <code class="highlighter-rouge">U#Needle</code>.</li>
    </ol>
  </li>
</ol>

<p>The existential variable complicates things, but the rule is sound.</p>

<p>As a workaround, it is commonly suggested to extract the member types
in question into separate type variables. This works in some cases,
but let’s see how it goes in this one.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">stepTwiceExUnim</span><span class="o">[</span><span class="kt">N</span>, <span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span><span class="o">{</span><span class="k">type</span> <span class="kt">Needle</span> <span class="kt">=</span> <span class="kt">N</span><span class="o">}](</span>
    <span class="n">h</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Haystack</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">N</span><span class="o">)</span><span class="k">:</span> <span class="kt">N</span> <span class="o">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>This looks a lot weirder, but should be able to return the right type.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">trial2</span> <span class="k">=</span> <span class="n">stepTwiceExUnim</span><span class="o">[</span><span class="kt">lu.Needle</span>, <span class="kt">lu.</span><span class="k">type</span><span class="o">](</span><span class="n">lu</span><span class="o">.</span><span class="n">haystack</span><span class="o">,</span> <span class="n">lu</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">init</span><span class="o">)</span>
<span class="n">trial2</span><span class="k">:</span> <span class="kt">lu.Needle</span>
</code></pre></div></div>

<p>But this situation is complex enough for the technique to not work.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">stepTwiceEx</span><span class="o">[</span><span class="kt">N</span>, <span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span><span class="o">{</span><span class="k">type</span> <span class="kt">Needle</span> <span class="kt">=</span> <span class="kt">N</span><span class="o">}](</span>
    <span class="n">h</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Haystack</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">N</span><span class="o">)</span><span class="k">:</span> <span class="kt">N</span> <span class="o">=</span>
  <span class="n">h</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>

<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">18</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">N</span>
 <span class="n">required</span><span class="k">:</span> <span class="k">_</span><span class="err">1</span><span class="kt">.Needle</span> <span class="kt">where</span> <span class="kt">val</span> <span class="k">_</span><span class="err">1</span><span class="kt">:</span> <span class="kt">U</span>
         <span class="n">h</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
                       <span class="o">^</span>
</code></pre></div></div>

<p>Instead, we need to index <code class="highlighter-rouge">Haystack</code> <em>directly</em> with the <code class="highlighter-rouge">Needle</code>
type, that is, add a type parameter to <code class="highlighter-rouge">Haystack</code> so that its <code class="highlighter-rouge">Needle</code>
arguments can be talked about completely independently of the
<code class="highlighter-rouge">LittleUniverse</code>, and then to write <code class="highlighter-rouge">h: U#Haystack[N]</code>
above. Essentially, this means that any time a type talks about
another type in a <code class="highlighter-rouge">Universe</code>, you need another type parameter to
redeclare a little bit of the relationships between types in the
universe.</p>

<p>The problem with this is that we already declared those relationships
by declaring the universe! All of the non-redundant information is
represented in the singleton type index. So even where the above
type-refinement technique works (and it does in many cases), it’s
<em>still</em> redeclaring things that ought to be derivable from the “mere”
fact that <code class="highlighter-rouge">U</code> is a singleton type.</p>

<h2 id="the-fact-that-its-a-singleton-type">The fact that it’s a singleton type</h2>

<p><em>(The following is based on enlightening commentary by Daniel Urban on
an earlier draft.)</em></p>

<p>Let’s examine the underlying error in <code class="highlighter-rouge">stepTwiceEx</code> more directly.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">fetchIter</span><span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span><span class="o">](</span>
    <span class="n">h</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Haystack</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="k">#</span><span class="nc">Needle</span> <span class="k">=</span> <span class="n">h</span><span class="o">.</span><span class="n">iter</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="k">_</span><span class="err">1</span><span class="kt">.</span><span class="k">type</span><span class="o">(</span><span class="kt">in</span> <span class="kt">method</span> <span class="kt">fetchIter</span><span class="o">)</span><span class="k">#</span><span class="kt">Needle</span>
             <span class="n">where</span> <span class="k">type</span> <span class="k">_</span><span class="err">1</span><span class="kt">.</span><span class="k">type</span><span class="o">(</span><span class="kt">in</span> <span class="kt">method</span> <span class="kt">fetchIter</span><span class="o">)</span> <span class="k">&lt;:</span> <span class="kt">U</span> <span class="kt">with</span> <span class="kt">Singleton</span>
 <span class="n">required</span><span class="k">:</span> <span class="k">_</span><span class="err">1</span><span class="kt">.</span><span class="k">type</span><span class="o">(</span><span class="kt">in</span> <span class="kt">value</span> <span class="kt">$anonfun</span><span class="o">)</span><span class="k">#</span><span class="kt">Needle</span>
             <span class="n">where</span> <span class="k">type</span> <span class="k">_</span><span class="err">1</span><span class="kt">.</span><span class="k">type</span><span class="o">(</span><span class="kt">in</span> <span class="kt">value</span> <span class="kt">$anonfun</span><span class="o">)</span> <span class="k">&lt;:</span> <span class="kt">U</span> <span class="kt">with</span> <span class="kt">Singleton</span>
           <span class="n">h</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Haystack</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="k">#</span><span class="nc">Needle</span> <span class="k">=</span> <span class="n">h</span><span class="o">.</span><span class="n">iter</span>
                                                    <span class="o">^</span>
</code></pre></div></div>

<p>It’s a good thing that this doesn’t compile. If it did, we could do</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fetchIter</span><span class="o">[</span><span class="kt">LittleUniverse</span><span class="o">](</span><span class="n">lu</span><span class="o">.</span><span class="n">haystack</span><span class="o">)(</span><span class="n">anotherU</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">init</span><span class="o">)</span>
</code></pre></div></div>

<p>Which is unsound.</p>

<p><a href="http://www.scala-lang.org/files/archive/spec/2.12/03-types.html#singleton-types">§3.2.1 “Singleton Types”</a> of
the specification mentions this <code class="highlighter-rouge">Singleton</code>, which is in a way related
to singleton types.</p>

<blockquote>
  <p>A <em>stable type</em> is either a singleton type or a type which is
declared to be a subtype of trait <code class="highlighter-rouge">scala.Singleton</code>.</p>
</blockquote>

<p>Adding <code class="highlighter-rouge">with Singleton</code> to the upper bound on <code class="highlighter-rouge">U</code> causes <code class="highlighter-rouge">fetchIter</code>
to compile! This is sound, because we are protected from the above
problem with the original <code class="highlighter-rouge">fetchIter</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">fetchIter</span><span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span> <span class="kt">with</span> <span class="kt">Singleton</span><span class="o">](</span>
    <span class="n">h</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Haystack</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="k">#</span><span class="nc">Needle</span> <span class="k">=</span> <span class="n">h</span><span class="o">.</span><span class="n">iter</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fetchIter</span><span class="o">[</span><span class="kt">lu.</span><span class="k">type</span><span class="o">](</span><span class="n">lu</span><span class="o">.</span><span class="n">haystack</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">lu.Needle</span> <span class="o">=&gt;</span> <span class="n">lu</span><span class="o">.</span><span class="nc">Needle</span> <span class="k">=</span> <span class="nc">$$Lambda$1397</span><span class="o">/</span><span class="mi">1159581520</span><span class="k">@</span><span class="mi">683</span><span class="n">e7892</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fetchIter</span><span class="o">[</span><span class="kt">LittleUniverse</span><span class="o">](</span><span class="n">lu</span><span class="o">.</span><span class="n">haystack</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">16</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">[</span><span class="kt">LittleUniverse</span><span class="o">]</span> <span class="k">do</span> <span class="n">not</span> <span class="n">conform</span>
                     <span class="n">to</span> <span class="n">method</span> <span class="n">fetchIter</span><span class="ss">'s </span><span class="k">type</span> <span class="kt">parameter</span> <span class="kt">bounds</span>
                     <span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span> <span class="kt">with</span> <span class="kt">Singleton</span><span class="o">]</span>
       <span class="n">fetchIter</span><span class="o">[</span><span class="kt">LittleUniverse</span><span class="o">](</span><span class="n">lu</span><span class="o">.</span><span class="n">haystack</span><span class="o">)</span>
                <span class="o">^</span>
</code></pre></div></div>

<p>Let’s walk through the logic for <code class="highlighter-rouge">fetchIter</code>. The expression <code class="highlighter-rouge">h.iter</code>
has type <code class="highlighter-rouge">u.Needle =&gt; u.Needle</code> for some <code class="highlighter-rouge">val u: U</code>, and our goal type
is <code class="highlighter-rouge">U#Needle =&gt; U#Needle</code>. So we have two subgoals: prove
<code class="highlighter-rouge">u.Needle &lt;: U#Needle</code> for the covariant position (after <code class="highlighter-rouge">=&gt;</code>), and
<code class="highlighter-rouge">U#Needle &lt;: u.Needle</code> for the contravariant position (before <code class="highlighter-rouge">=&gt;</code>).</p>

<p>First, covariant:</p>

<ol>
  <li>Since <code class="highlighter-rouge">u: U</code>, <code class="highlighter-rouge">u.type &lt;: U</code>.</li>
  <li>Since the left side of <code class="highlighter-rouge">#</code> is covariant, #1 implies
<code class="highlighter-rouge">u.type#Needle &lt;: U#Needle</code>.</li>
  <li>This re-sugars to <code class="highlighter-rouge">u.Needle &lt;: U#Needle</code>, which is the goal.</li>
</ol>

<p>Secondly, contravariant. We’re going to have to make a best guess
here, because it’s not entirely clear to me what’s going on.</p>

<ol>
  <li>Since [existential] path <code class="highlighter-rouge">u</code> has a singleton type <code class="highlighter-rouge">U</code> (if we define
“has a singleton type” as “having a type <em>X</em> such that
<em>X</em><code class="highlighter-rouge"> &lt;: Singleton</code>”), so <code class="highlighter-rouge">u.type = U</code> by the singleton equivalence.</li>
  <li>Since equivalence implies conformance, according to the first
bullet under “Conformance”, #1 implies <code class="highlighter-rouge">U &lt;: u.type</code>.</li>
  <li>Since the left side of <code class="highlighter-rouge">#</code> is covariant, #2 implies that
<code class="highlighter-rouge">U#Needle &lt;: u.type#Needle</code>.</li>
  <li>This resugars to <code class="highlighter-rouge">U#Needle &lt;: u.Needle</code>, which is the goal.</li>
</ol>

<p>I don’t quite understand this, because <code class="highlighter-rouge">U</code> doesn’t <em>seem</em> to meet the
requirements for “singleton type”, according to the definition of
singleton types. However, I’m <em>fairly</em> sure it’s sound, since type
stability seems to be the property that lets us avoid the
universe-mixing unsoundness. Unfortunately, it only seems to work with
<em>existential</em> <code class="highlighter-rouge">val</code>s; we seem to be out of luck with <code class="highlighter-rouge">val</code>s that the
compiler can still see.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// works fine!
</span><span class="k">def</span> <span class="n">stepTwiceSingly</span><span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span> <span class="kt">with</span> <span class="kt">Singleton</span><span class="o">](</span>
    <span class="n">h</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Haystack</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">h</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
<span class="o">}</span>

<span class="c1">// but alas, this form doesn't
</span><span class="k">class</span> <span class="nc">StepTwiceSingly</span><span class="o">[</span><span class="kt">U</span> <span class="k">&lt;:</span> <span class="kt">LittleUniverse</span> <span class="kt">with</span> <span class="kt">Singleton</span><span class="o">](</span><span class="n">u</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">stepTwiceSingly</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span> <span class="o">=</span>
    <span class="n">u</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
<span class="o">}</span>

<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">15</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">U</span><span class="k">#</span><span class="kt">Needle</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">StepTwiceSingly.this.u.Needle</span>
           <span class="n">u</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="n">haystack</span><span class="o">.</span><span class="n">iter</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
                                            <span class="o">^</span>
</code></pre></div></div>

<p>We can work around this by having the second form invoke the first
with the <code class="highlighter-rouge">Haystack</code>, thus “existentializing” the universe. I imagine
that <em>most</em>, albeit not all, cakes can successfully follow this
strategy.</p>

<p>So, finally, we’re almost out of the cake.</p>

<ol>
  <li>Escape covariant positions with universe variable: complete.</li>
  <li>Escape contravariant/invariant positions with universe variable:
complete.</li>
  <li>Escape covariant positions with universe <em>singleton type</em>:
complete!</li>
  <li>Escape contravariant/invariant positions with universe singleton
type: 90% there!</li>
</ol>

<p><em>This article was tested with Scala 2.12.1.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 01 Mar 2017 00:00:00 +0100</pubDate>
        <link>https://typelevel.org/blog/2017/03/01/four-ways-to-escape-a-cake.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2017/03/01/four-ways-to-escape-a-cake.html</guid>
      </item>
    
      <item>
        <title>There are more types than classes</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>As programmers, we are very incautious with our use of the word
“type”. The concept of “type” is sufficiently abstract and specific
that we are tempted to understand it by analogy, so much that we begin
to confuse analogy with sameness.</p>

<p>The colloquial “runtime type”, a fair approximation of “class”, makes
it tempting to equate <em>types</em> with “classes, interfaces, traits, that
sort of thing”, which I will name <em>classes</em> for the rest of this
article. But they aren’t the same. The type system is much richer and
more interesting than the class system, even in Java.</p>

<p>To appreciate this richness, we must stop thinking of types as classes
and stop drawing conclusions from that weak analogy. Luckily, the
compiler will readily reveal how unlike classes types are, if we ask
it some simple questions.</p>

<h2 id="one-value-with-class-many-variables-with-type">One value with class, many variables with type</h2>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">greeting</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"hi there!"</span>
</code></pre></div></div>

<p>Here I have constructed a <code class="highlighter-rouge">String</code> and assigned it to a variable. (I
have also constructed the <code class="highlighter-rouge">char</code> array in the <code class="highlighter-rouge">String</code> and various
other details, but immediately handed those off to the <code class="highlighter-rouge">String</code> and
forgotten about them.) This value has class <code class="highlighter-rouge">String</code>. It has several
classes, really.</p>

<ol>
  <li><code class="highlighter-rouge">String</code></li>
  <li><code class="highlighter-rouge">java.io.Serializable</code></li>
  <li><code class="highlighter-rouge">CharSequence</code></li>
  <li><code class="highlighter-rouge">Comparable[String]</code></li>
  <li><code class="highlighter-rouge">Object</code>/<code class="highlighter-rouge">AnyRef</code></li>
</ol>

<p>That seems like a lot of classes for one value. And they are genuine
classes of <code class="highlighter-rouge">greeting</code>, though 2-5 are all implied by #1.</p>

<p><code class="highlighter-rouge">greeting</code> also has all five of these <em>types</em>. We can ask the compiler
to verify that this <em>type</em> truth holds, entirely separately from the
class truth.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">greeting</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">greeting</span><span class="k">:</span> <span class="kt">java.io.Serializable</span><span class="o">,</span>
        <span class="n">greeting</span><span class="k">:</span> <span class="kt">CharSequence</span><span class="o">,</span> <span class="n">greeting</span><span class="k">:</span> <span class="kt">Comparable</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span>
        <span class="n">greeting</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">java.io.Serializable</span><span class="o">,</span> <span class="nc">CharSequence</span><span class="o">,</span>
       <span class="nc">Comparable</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="nc">AnyRef</span><span class="o">)</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">hi</span> <span class="n">there</span><span class="o">!,</span><span class="n">hi</span> <span class="n">there</span><span class="o">!,</span><span class="n">hi</span> <span class="n">there</span><span class="o">!,</span><span class="n">hi</span> <span class="n">there</span><span class="o">!,</span><span class="n">hi</span> <span class="n">there</span><span class="o">!)</span>
</code></pre></div></div>

<p>So we have exhausted the classes, but aren’t quite done with types.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">greeting</span><span class="k">:</span> <span class="kt">greeting.type</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">greeting.</span><span class="k">type</span> <span class="o">=</span> <span class="n">hi</span> <span class="n">there</span><span class="o">!</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">greeting.type</code> is not like the other five types we just tested. It is
a strict subtype of <code class="highlighter-rouge">String</code>, and has no class with the same name.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// If and only if call compiles, A is a subtype of B.
</span><span class="k">def</span> <span class="n">conformance</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">conformance</span><span class="o">[</span><span class="kt">greeting.</span><span class="k">type</span>, <span class="kt">String</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">conformance</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">greeting.</span><span class="k">type</span><span class="o">]</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">[</span><span class="kt">String</span>,<span class="kt">greeting.</span><span class="k">type</span><span class="o">]</span> <span class="k">do</span> <span class="n">not</span> <span class="n">conform</span>
              <span class="n">to</span> <span class="n">method</span> <span class="n">conformance</span><span class="ss">'s </span><span class="k">type</span> <span class="kt">parameter</span> <span class="kt">bounds</span> <span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>Fine, we can accept that object identity is represented at the type
level without our universe imploding, by inventing the theory that
this is about object identity; hold on, though:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">salutation</span> <span class="k">=</span> <span class="n">greeting</span>
<span class="n">salutation</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">hi</span> <span class="n">there</span><span class="o">!</span>
</code></pre></div></div>

<p>Fine, <code class="highlighter-rouge">salutation</code> is just another name for <code class="highlighter-rouge">greeting</code>, right?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">conformance</span><span class="o">[</span><span class="kt">salutation.</span><span class="k">type</span>, <span class="kt">String</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">greeting.</span><span class="k">type</span> <span class="kt">=:=</span> <span class="kt">salutation.</span><span class="k">type</span><span class="o">]</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">Cannot</span> <span class="kt">prove</span> <span class="kt">that</span> <span class="kt">greeting.</span><span class="k">type</span> <span class="o">=:=</span> <span class="n">salutation</span><span class="o">.</span><span class="n">type</span><span class="o">.</span>
</code></pre></div></div>

<p>Now we have seven. I’ll spare you spelling out the induction: each new
variable defined like <code class="highlighter-rouge">salutation</code> will yield a new alias with a
distinct type. This is not about <em>objects</em>; this is about <em>variables</em>!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// find a type for the literal "hi there!"
</span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">literalHiThere</span> <span class="k">=</span> <span class="n">shapeless</span><span class="o">.</span><span class="nc">Witness</span><span class="o">(</span><span class="s">"hi there!"</span><span class="o">)</span>
<span class="n">literalHiThere</span><span class="k">:</span> <span class="kt">shapeless.Witness.Aux</span><span class="o">[</span><span class="kt">String</span><span class="o">(</span><span class="err">"</span><span class="kt">hi</span> <span class="kt">there!</span><span class="err">"</span><span class="o">)]</span> <span class="k">=</span> <span class="n">shapeless</span><span class="o">.</span><span class="nc">Witness$$anon$1</span><span class="k">@</span><span class="mf">1d</span><span class="mi">1537</span><span class="n">bb</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">conformance</span><span class="o">[</span><span class="kt">greeting.</span><span class="k">type</span>, <span class="kt">literalHiThere.T</span><span class="o">]</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">15</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">[</span><span class="kt">greeting.</span><span class="k">type</span>,<span class="kt">literalHiThere.T</span><span class="o">]</span> <span class="k">do</span> <span class="n">not</span> <span class="n">conform</span>
              <span class="n">to</span> <span class="n">method</span> <span class="n">conformance</span><span class="ss">'s </span><span class="k">type</span> <span class="kt">parameter</span> <span class="kt">bounds</span> <span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">conformance</span><span class="o">[</span><span class="kt">literalHiThere.T</span>, <span class="kt">greeting.</span><span class="k">type</span><span class="o">]</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">15</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">[</span><span class="kt">literalHiThere.T</span>,<span class="kt">greeting.</span><span class="k">type</span><span class="o">]</span> <span class="k">do</span> <span class="n">not</span> <span class="n">conform</span>
              <span class="n">to</span> <span class="n">method</span> <span class="n">conformance</span><span class="ss">'s </span><span class="k">type</span> <span class="kt">parameter</span> <span class="kt">bounds</span> <span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>As local variables are a strictly compile-time abstraction, and we
have anyway seen that the numbers don’t match up, that should be the
end of the “types are classes” confusion for you. But maybe this is
just some Scala oddity! And anyhow I haven’t even begun to demonstrate
the overwhelming richness of the type model as it blindingly outshines
the paucity of the class model. Let’s go further.</p>

<h2 id="no-values-infinite-types-method-type-parameters">No values, infinite types: method type parameters</h2>

<p>To our small program of a greeting, we can add a small method.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">pickGreeting</span><span class="o">[</span><span class="kt">G</span><span class="o">](</span><span class="n">grt</span><span class="k">:</span> <span class="kt">G</span><span class="o">,</span> <span class="n">rand</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">grt</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">pickGreeting</span><span class="o">(</span><span class="n">greeting</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">hi</span> <span class="n">there</span><span class="o">!</span>
</code></pre></div></div>

<p>It seems like <code class="highlighter-rouge">G</code> must be <code class="highlighter-rouge">String</code>, because the argument passed to
<code class="highlighter-rouge">pickGreeting</code> is a string, and in that case so must its return value
be, according to the implementation. And from the perspective of this
call, <a href="/blog/2016/01/28/existential-inside.html">outside</a>
<code class="highlighter-rouge">pickGreeting</code>’s implementation, it is <code class="highlighter-rouge">String</code> indeed.</p>

<p>But that implementation’s perspective matters, too; it is also part of
our program. And it sees things quite differently. We can ask its
thoughts on the matter by adding to its body</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">pickGreeting</span><span class="o">[</span><span class="kt">G</span><span class="o">](</span><span class="n">grt</span><span class="k">:</span> <span class="kt">G</span><span class="o">,</span> <span class="n">rand</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">G</span> <span class="kt">=:=</span> <span class="kt">String</span><span class="o">]</span>
  <span class="n">grt</span>
<span class="o">}</span>

<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">12</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">Cannot</span> <span class="kt">prove</span> <span class="kt">that</span> <span class="kt">G</span> <span class="o">=:=</span> <span class="nc">String</span><span class="o">.</span>
         <span class="n">implicitly</span><span class="o">[</span><span class="kt">G</span> <span class="kt">=:=</span> <span class="kt">String</span><span class="o">]</span>
                   <span class="o">^</span>
</code></pre></div></div>

<p>In fact, <code class="highlighter-rouge">G</code> bears no direct relationship to <code class="highlighter-rouge">String</code> at all.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// replace implicitly with
</span><span class="n">conformance</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">String</span><span class="o">]</span>

<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">13</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">[</span><span class="kt">G</span>,<span class="kt">String</span><span class="o">]</span> <span class="k">do</span> <span class="n">not</span> <span class="n">conform</span>
              <span class="n">to</span> <span class="n">method</span> <span class="n">conformance</span><span class="ss">'s </span><span class="k">type</span> <span class="kt">parameter</span> <span class="kt">bounds</span> <span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">]</span>
         <span class="n">conformance</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">String</span><span class="o">]</span>
                    <span class="o">^</span>

<span class="c1">// or with
</span><span class="n">conformance</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">G</span><span class="o">]</span>

<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">13</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">[</span><span class="kt">String</span>,<span class="kt">G</span><span class="o">]</span> <span class="k">do</span> <span class="n">not</span> <span class="n">conform</span>
              <span class="n">to</span> <span class="n">method</span> <span class="n">conformance</span><span class="ss">'s </span><span class="k">type</span> <span class="kt">parameter</span> <span class="kt">bounds</span> <span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">]</span>
         <span class="n">conformance</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">G</span><span class="o">]</span>
                    <span class="o">^</span>
</code></pre></div></div>

<p>Let’s apply the pigeonhole principle. Imagine that you had a list of
every class that ever was or ever will be. Imagine that, somehow, all
of these classes, from <code class="highlighter-rouge">String</code> to
<code class="highlighter-rouge">AbstractFactoryMethodProxyBuilder</code>, were on your classpath, available
to your program.</p>

<p>Next, imagine that you had the time and inclination to try the <code class="highlighter-rouge">=:=</code>
test with every last one of these classes.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">implicitly</span><span class="o">[</span><span class="kt">G</span> <span class="kt">=:=</span> <span class="kt">javax.swing.JFrame</span><span class="o">]</span>
<span class="n">implicitly</span><span class="o">[</span><span class="kt">G</span> <span class="kt">=:=</span> <span class="kt">AbstractFactoryMethodProxyBuilder</span><span class="o">]</span>
<span class="c1">// ad [in]finitum
</span></code></pre></div></div>

<p>Your search will be futile; every class on your list-of-every-class
will give the same compiler error we got with <code class="highlighter-rouge">String</code>.</p>

<p>So, since <code class="highlighter-rouge">G</code> is not equal to anything on this list, it must be
something else that doesn’t appear on the list. Because this list
contains all classes, <code class="highlighter-rouge">G</code> must be something other than a class.</p>

<h3 id="it-must-not-necessarily-be-anything">It must not necessarily be anything</h3>

<p>It seems like it might be convenient to say “well, in this program <code class="highlighter-rouge">G</code>
is only ever <code class="highlighter-rouge">String</code> by substitution, so therefore it is, even if the
compiler doesn’t see that.” However, thinking like this misses out on
the second key advantage of type parameterization, the one not based
on multiplicity of substitution, or the type-safety of callers:
blindness.</p>

<p>The implementation of type-parameterized classes and methods are
required to treat each type parameter uniquely, uniformly, and without
prejudice. The compiler enforces this by making the implementation
blind to what that parameter, like <code class="highlighter-rouge">G</code>, could be. It can only use what
the caller, the “outside”, has told it about <code class="highlighter-rouge">G</code>—arguments whose
types contain <code class="highlighter-rouge">G</code>, like <code class="highlighter-rouge">List[G]</code>, <code class="highlighter-rouge">(G, G) =&gt; G</code>, or <code class="highlighter-rouge">G</code> itself, like
the argument to <code class="highlighter-rouge">pickGreeting</code>. This
is
<a href="/blog/2016/03/13/information-hiding.html">information-hiding at the type level</a>;
if you find information-hiding a useful tool for implementing correct
programs, you will find the same of the fresh, unique, and mysterious
types induced by each introduction of a type parameter.</p>

<div class="side-note">
  Each operation a language permits by default, not via an argument,
  on values of a type parameter is a leak in this abstraction. This
  includes testing the value’s class, converting to string, and
  comparing to other values of supposedly utter mystery for
  equality. The ability to create a “default” value is also a leak. A
  function is always permitted to ask only that of these that it needs
  from the caller; make them default, and this design choice is taken
  away. That is why <code>Object#equals</code> is little better for
  type-safety than reflection-based calls, and why total type erasure
  is a desirable feature rather than a design flaw—plugging these
  leaks gives the programmer as much freedom to abstract by
  information-hiding as she wishes.
</div>

<h3 id="how-many-calls-are-there">How many calls are there?</h3>

<p>Put another way, when implementing the code in the scope of a type
parameter, your implementation must be equally valid <em>for all</em>
possible <code class="highlighter-rouge">G</code> substitutions, including the ones that haven’t been
invented yet. This is why we call it <em>universal</em> quantification.</p>

<p>But it is not merely each declaration of a type parameter that yields
a distinct type—each call does! Consider two consecutive calls to
<code class="highlighter-rouge">pickGreeting</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pickGreeting</span><span class="o">(</span><span class="n">greeting</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span>
<span class="n">pickGreeting</span><span class="o">(</span><span class="mi">33</span><span class="o">,</span> <span class="mi">84</span><span class="o">)</span>
</code></pre></div></div>

<p>Externally, there are two <code class="highlighter-rouge">G</code> types. However, the possibility of
writing this demands another level of uniqueness treatment when
typechecking <code class="highlighter-rouge">pickGreeting</code>’s definition: whatever <code class="highlighter-rouge">G</code> is now, like
<code class="highlighter-rouge">String</code>, it might be something else in the next call, like <code class="highlighter-rouge">Int</code> in
the above example. With recursion, it might even be two different
things at the same time. There’s nothing to hold this at two, either:
there may be an unbounded number of substitutions for a given type
parameter within a single program, at a single point in time.</p>

<p>While <code class="highlighter-rouge">G</code> <em>may</em> be the same between two invocations of <code class="highlighter-rouge">pickGreeting</code>,
it might not. So we have no choice but to treat the <code class="highlighter-rouge">G</code> types of <em>each
call</em> as separate types. There may be infinitely many calls, so there
are so many types.</p>

<p>Incidentally, the same happens for singleton types. Each time <code class="highlighter-rouge">val
greeting</code> comes into scope, it induces a separate singleton type. It
is easy enough to arrange for an unbounded number of scope entries in
a particular program. This isn’t so practical as the type parameter
phenomenon, though.</p>

<h2 id="more-types-from-variable-copies">More types from variable copies</h2>

<p>Suppose we’d like to wait a while to compute our greeting. We can
define a type-and-class to represent that conveniently.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// like Coyoneda Id, if that helps
</span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Later</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">I</span>
  <span class="k">val</span> <span class="n">i</span><span class="k">:</span> <span class="kt">I</span>
  <span class="k">val</span> <span class="n">f</span><span class="k">:</span> <span class="kt">I</span> <span class="o">=&gt;</span> <span class="n">A</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">later</span><span class="o">[</span><span class="kt">In</span>, <span class="kt">A</span><span class="o">](</span><span class="n">now</span><span class="k">:</span> <span class="kt">In</span><span class="o">)(</span><span class="n">later</span><span class="k">:</span> <span class="kt">In</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span>
  <span class="k">:</span> <span class="kt">Later</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Later</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">I</span> <span class="o">=</span> <span class="nc">In</span>
    <span class="k">val</span> <span class="n">i</span> <span class="k">=</span> <span class="n">now</span>
    <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="n">later</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">greeting3</span> <span class="k">=</span> <span class="n">later</span><span class="o">(</span><span class="mi">3</span><span class="o">){</span>
  <span class="n">n</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="n">n</span><span class="o">)(</span><span class="s">"hi"</span><span class="o">).</span><span class="n">mkString</span><span class="o">(</span><span class="s">" "</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>How many <em>classes</em> are involved here, in the type of <code class="highlighter-rouge">greeting3</code>?</p>

<ol>
  <li><code class="highlighter-rouge">Later</code>, obviously;</li>
  <li><code class="highlighter-rouge">Function1</code>, the <code class="highlighter-rouge">greeting3.f</code> overall class;</li>
  <li><code class="highlighter-rouge">String</code>, the output type of <code class="highlighter-rouge">greeting3.f</code>;</li>
  <li><code class="highlighter-rouge">Int</code>, the <code class="highlighter-rouge">I</code> type.</li>
</ol>

<p>How many types?</p>

<p>The first difference is that <code class="highlighter-rouge">greeting3.I</code> is not <code class="highlighter-rouge">Int</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">greeting3.I</span> <span class="kt">=:=</span> <span class="kt">Int</span><span class="o">]</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">Cannot</span> <span class="kt">prove</span> <span class="kt">that</span> <span class="kt">greeting3.I</span> <span class="o">=:=</span> <span class="nc">Int</span><span class="o">.</span>
       <span class="n">implicitly</span><span class="o">[</span><span class="kt">greeting3.I</span> <span class="kt">=:=</span> <span class="kt">Int</span><span class="o">]</span>
                 <span class="o">^</span>
</code></pre></div></div>

<p>They are unrelated for much the same reason as <code class="highlighter-rouge">G</code> was unrelated to
<code class="highlighter-rouge">String</code> in the previous example: the only things code following
<code class="highlighter-rouge">val greeting3</code> may know are those embodied in the <code class="highlighter-rouge">greeting3.i</code> and
<code class="highlighter-rouge">greeting3.f</code> members. You can almost think of them as “arguments”.</p>

<p>But that’s not all.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">salut3</span> <span class="k">=</span> <span class="n">greeting3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">greeting3</span><span class="o">.</span><span class="n">f</span><span class="o">(</span><span class="n">greeting3</span><span class="o">.</span><span class="n">i</span><span class="o">)</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">hi</span> <span class="n">hi</span> <span class="n">hi</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">salut3</span><span class="o">.</span><span class="n">f</span><span class="o">(</span><span class="n">salut3</span><span class="o">.</span><span class="n">i</span><span class="o">)</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">hi</span> <span class="n">hi</span> <span class="n">hi</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">greeting3</span><span class="o">.</span><span class="n">f</span><span class="o">(</span><span class="n">salut3</span><span class="o">.</span><span class="n">i</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">salut3.i.</span><span class="k">type</span> <span class="o">(</span><span class="kt">with</span> <span class="kt">underlying</span> <span class="k">type</span> <span class="kt">salut3.I</span><span class="o">)</span>
 <span class="kt">required:</span> <span class="kt">greeting3.I</span>
       <span class="n">greeting3</span><span class="o">.</span><span class="n">f</span><span class="o">(</span><span class="n">salut3</span><span class="o">.</span><span class="n">i</span><span class="o">)</span>
                          <span class="o">^</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">greeting3.I</span> <span class="kt">=:=</span> <span class="kt">salut3.I</span><span class="o">]</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">Cannot</span> <span class="kt">prove</span> <span class="kt">that</span> <span class="kt">greeting3.I</span> <span class="o">=:=</span> <span class="n">salut3</span><span class="o">.</span><span class="n">I</span><span class="o">.</span>
</code></pre></div></div>

<p>Just like every call to <code class="highlighter-rouge">pickGreeting</code> induces a new <code class="highlighter-rouge">G</code> type, each
simple <code class="highlighter-rouge">val</code> copy of <code class="highlighter-rouge">greeting3</code> will induce a new, unique <code class="highlighter-rouge">I</code>
type. It doesn’t matter that they’re all the same value; this is a
matter of variables, not values, just as with singleton types.</p>

<p>But that’s <em>still</em> not all.</p>

<h2 id="one-value-with-class-many-variable-references-with-types">One value with class, many variable <em>references</em> with types</h2>

<p>The preceding is more delicate than it seems.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">allo</span> <span class="k">=</span> <span class="n">greeting3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">allo</span><span class="o">.</span><span class="n">f</span><span class="o">(</span><span class="n">allo</span><span class="o">.</span><span class="n">i</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">13</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">Later</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span><span class="k">#</span><span class="n">I</span>
 <span class="n">required</span><span class="k">:</span> <span class="k">_</span><span class="err">1</span><span class="kt">.I</span> <span class="kt">where</span> <span class="kt">val</span> <span class="k">_</span><span class="err">1</span><span class="kt">:</span> <span class="kt">Later</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
       <span class="n">allo</span><span class="o">.</span><span class="n">f</span><span class="o">(</span><span class="n">allo</span><span class="o">.</span><span class="n">i</span><span class="o">)</span>
                   <span class="o">^</span>
</code></pre></div></div>

<p>All we have done differently is use a mutable <code class="highlighter-rouge">var</code> instead of an
immutable <code class="highlighter-rouge">val</code>. Why is this enough to throw a wrench in the works?</p>

<p>Suppose you had another <em>value</em> of the <code class="highlighter-rouge">Later[String]</code> type.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">bhello</span> <span class="k">=</span> <span class="n">later</span><span class="o">(</span><span class="s">"olleh"</span><span class="o">)(</span><span class="k">_</span><span class="o">.</span><span class="n">reverse</span><span class="o">)</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">I</code> substitution here is <code class="highlighter-rouge">String</code>. So the <code class="highlighter-rouge">f</code> takes a <code class="highlighter-rouge">String</code>
argument, and the <code class="highlighter-rouge">I</code> is a <code class="highlighter-rouge">String</code>.</p>

<p><code class="highlighter-rouge">bhello</code> is of a compatible type with the <code class="highlighter-rouge">allo</code> var. So this
assignment will work.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">allo</span> <span class="k">=</span> <span class="n">bhello</span>
</code></pre></div></div>

<p>In a sense, when this mutation occurs, the <code class="highlighter-rouge">I</code> type <em>also</em> mutates,
from <code class="highlighter-rouge">Int</code> to <code class="highlighter-rouge">String</code>. But that isn’t quite right; types cannot
mutate.</p>

<p>Suppose that this assignment happened in the middle of that line of
code that could not compile. We could imagine the sequence of events,
were it permitted.</p>

<ol>
  <li><code class="highlighter-rouge">allo.f</code> (which is <code class="highlighter-rouge">greeting3.f</code>) evaluates. It is the function
<code class="highlighter-rouge">(n: Int) =&gt; List.fill(n)("hi").mkString(" ")</code>.</li>
  <li>The <code class="highlighter-rouge">allo = bhello</code> assignment occurs.</li>
  <li><code class="highlighter-rouge">allo.i</code> (which is <code class="highlighter-rouge">bhello.i</code>) evaluates. It is the string
<code class="highlighter-rouge">"olleh"</code>.</li>
  <li>We attempt to pass <code class="highlighter-rouge">"olleh"</code> as the <code class="highlighter-rouge">(n: Int)</code> argument to complete
the evaluation, and get stuck.</li>
</ol>

<p>Just as it makes no difference what concrete substitutions you make
for <code class="highlighter-rouge">G</code>, it makes no difference whether such an assignment could ever
happen in your specific program; the compiler takes it as a
possibility because you declared a <code class="highlighter-rouge">var</code>. (<code class="highlighter-rouge">def allo = greeting3</code> gets
the same treatment, lest you think non-functional programs get to have
all the fun here.) Each <em>reference</em> to <code class="highlighter-rouge">allo</code> gets a new <code class="highlighter-rouge">I</code> type
member. That failing line of code had two <code class="highlighter-rouge">allo</code> references, so was
working with two incompatible <code class="highlighter-rouge">I</code> types.</p>

<p>Since the number of references to a variable in a program is also
unbounded…you get the picture.</p>

<div class="side-note">
  This also occurs with existential type parameters, which are equally
  expressive to type members. Accordingly, Java <em>also</em>
  generates new types from occurrences of expressions of existential
  type.
</div>

<h2 id="how-do-we-tell-the-two-apart">How do we tell the two apart?</h2>

<p>All of this is simply to say that we must be working with two separate
concepts here.</p>

<ol>
  <li>The <em>runtime</em> shape and properties of the <em>values</em> that end up
flying around when a program actually <em>runs</em>. <strong>This we call
class.</strong></li>
  <li>The <em>compile-time</em>, statically-discoverable shape and properties of
the <em>expressions</em> that fly around when a program is
<em>written</em>. <strong>This we call type.</strong></li>
</ol>

<p>The case with <code class="highlighter-rouge">var</code> is revealing. Maybe the <code class="highlighter-rouge">I</code> type will always be
the same for a given mutable variable. But demonstrating that this
holds true for <em>one</em> run of the program (#1, class) isn’t nearly good
enough to <em>prove</em> that it will be true for <em>all</em> runs of the program
(#2, type).</p>

<p>We refuse to apply the term “type” to the #1, ‘class’ concept because
it does not live up to the name. The statement “these two types are
the same” is another level of power entirely; “these two values have
the same class” is extraordinarily weak by comparison.</p>

<p>It is tempting to use the term “runtime type” to refer to
classes. However, in the case of Scala, as with all type systems
featuring parametric polymorphism, classes are so dissimilar to types
that the similar-sounding term leads to false intuition, not helpful
analogy. It is a detriment to learning, not an aid.</p>

<p>Types are compile-time, and classes are runtime.</p>

<h3 id="when-are-types-real">When are types real?</h3>

<p>The phase separation—compile-time versus runtime—is the key to
the strength of types in Scala and similar type systems. The static
nature of types means that the truths they represent must be
universally quantified—true in all possible cases, not just some
test cases.</p>

<p>We need this strength because the phase separation forbids us from
taking into account anything that cannot be known about the program
without running it. We need to think in terms of “could happen”, not
“pretty sure it doesn’t”.</p>

<h2 id="how-do-classes-give-rise-to-types">How do classes give rise to types?</h2>

<p>There appears to be some overlap between the classes of <code class="highlighter-rouge">greeting</code> and
its types. While <code class="highlighter-rouge">greeting</code> has the <em>class</em> <code class="highlighter-rouge">String</code>, it also has the
<em>type</em> <code class="highlighter-rouge">String</code>.</p>

<p>We want types to represent static truths about the expressions in a
program. That’s why it makes sense to include a “model of the classes”
in the type system. When we define a class, we also define an
associated type or family of types.</p>

<p>When we use a class to construct a value, as in <code class="highlighter-rouge">new Blob</code>, we would
like to assign as much specific meaning to that expression as we can
at compile time. So, because we know right now that this expression
will make a value of class <code class="highlighter-rouge">Blob</code>, we assign it the type <code class="highlighter-rouge">Blob</code> too.</p>

<h3 id="how-do-the-types-disappear">How do the types disappear?</h3>

<p>There’s a common way to throw away type information in Scala,
especially popular in object-oriented style.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">absGreeting</span><span class="k">:</span> <span class="kt">CharSequence</span> <span class="o">=</span> <span class="n">greeting</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">absGreeting</code> has the same value as <code class="highlighter-rouge">greeting</code>, so it has the same
five classes. However, it only has two of those five types, because we
threw away the other three statically. It has lost some other types,
too, namely <code class="highlighter-rouge">greeting.type</code>, and acquired some new ones, namely
<code class="highlighter-rouge">absGreeting.type</code>.</p>

<p>Once a value is constructed, the expression will naturally cast off
the types specifying its precise identity, as it moves into more
abstract contexts. Ironically, the best way to preserve that
information as it passes through abstract contexts is to take
advantage of purely abstract types—type parameters and type
members.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">pickGreeting</span><span class="o">[</span><span class="kt">greeting.</span><span class="k">type</span><span class="o">](</span><span class="n">greeting</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">greeting.</span><span class="k">type</span> <span class="o">=</span> <span class="n">hi</span> <span class="n">there</span><span class="o">!</span>
</code></pre></div></div>

<p>While the implementation must treat its argument as being of the
abstract type <code class="highlighter-rouge">G</code>, the caller knows that the more specific
<code class="highlighter-rouge">greeting.type</code> must come out of that process.</p>

<h3 id="how-do-the-types-come-back">How do the types come back?</h3>

<p>There is a feature in Scala that lets you use class to get back <em>some</em>
type information via a dynamic, runtime test.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">absGreeting</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">hiAgain</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span>
    <span class="n">conformance</span><span class="o">[</span><span class="kt">hiAgain.</span><span class="k">type</span>, <span class="kt">String</span><span class="o">]</span> <span class="c1">// will compile
</span><span class="o">}</span>
</code></pre></div></div>

<p>The name “type test” for this feature is poorly chosen. The
<em>conclusion</em> affects the type level—<code class="highlighter-rouge">hiAgain</code> is, indeed, proven
statically to be of type <code class="highlighter-rouge">String</code>—but the <em>test</em> occurs only at
the class level.</p>

<p>The compiler will tell you about this limitation sometimes.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">pickGreeting2</span><span class="o">[</span><span class="kt">G</span><span class="o">](</span><span class="n">grt</span><span class="k">:</span> <span class="kt">G</span><span class="o">,</span> <span class="n">rand</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">G</span> <span class="o">=</span>
  <span class="o">(</span><span class="s">"magic"</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">ok</span><span class="k">:</span> <span class="kt">G</span> <span class="o">=&gt;</span> <span class="n">ok</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">sys</span> <span class="n">error</span> <span class="s">"failed!"</span>
  <span class="o">}</span>

<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">13</span><span class="k">:</span> <span class="kt">warning:</span> <span class="kt">abstract</span> <span class="k">type</span> <span class="kt">pattern</span> <span class="kt">G</span> <span class="kt">is</span> <span class="kt">unchecked</span>
              <span class="n">since</span> <span class="n">it</span> <span class="n">is</span> <span class="n">eliminated</span> <span class="n">by</span> <span class="n">erasure</span>
           <span class="k">case</span> <span class="n">ok</span><span class="k">:</span> <span class="kt">G</span> <span class="o">=&gt;</span> <span class="n">ok</span>
                    <span class="o">^</span>
</code></pre></div></div>

<p>But reflecting the runtime classes back to compile-time types is a
subtle art, and the compiler often can’t explain exactly what you got
wrong.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">pickGreeting3</span><span class="o">[</span><span class="kt">G</span><span class="o">](</span><span class="n">grt</span><span class="k">:</span> <span class="kt">G</span><span class="o">,</span> <span class="n">rand</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">G</span> <span class="o">=</span>
  <span class="n">grt</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">_:</span> <span class="kt">String</span> <span class="o">=&gt;</span>
      <span class="s">"Surely type G is String, right?"</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">grt</span>
  <span class="o">}</span>

<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">String</span><span class="o">(</span><span class="err">"</span><span class="kt">Surely</span> <span class="k">type</span> <span class="kt">G</span> <span class="kt">is</span> <span class="kt">String</span><span class="o">,</span> <span class="kt">right?</span><span class="err">"</span><span class="o">)</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">G</span>
             <span class="s">"Surely type G is String, right?"</span>
             <span class="o">^</span>
</code></pre></div></div>

<p>I’ve touched upon this
mistake
<a href="/blog/2014/07/06/singleton_instance_trick_unsafe.html#types-are-erased">in previous articles</a>,
but it’s worth taking at least one more look. Let’s examine how
tempting this mistake is.</p>

<p><code class="highlighter-rouge">String</code> is a <code class="highlighter-rouge">final class</code>. So it is true that <code class="highlighter-rouge">G</code> can contain no
more specific class than <code class="highlighter-rouge">String</code>, if the first <code class="highlighter-rouge">case</code> matches. For
example, given <code class="highlighter-rouge">trait MyAwesomeMixin</code>, <code class="highlighter-rouge">G</code> cannot be
<code class="highlighter-rouge">String with MyAwesomeMixin</code> if this <code class="highlighter-rouge">case</code> succeeds, because that
can’t be instantiated; you would need to create a subclass of <code class="highlighter-rouge">String</code>
that implemented <code class="highlighter-rouge">MyAwesomeMixin</code>.</p>

<p>This pattern match isn’t enough evidence to say that <code class="highlighter-rouge">G</code> is exactly
<code class="highlighter-rouge">String</code>. There are still other class-based types it could be, like
<code class="highlighter-rouge">Serializable</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pickGreeting3</span><span class="o">[</span><span class="kt">java.io.Serializable</span><span class="o">](</span><span class="n">greeting</span><span class="o">,</span> <span class="mi">4055</span><span class="o">)</span>
</code></pre></div></div>

<p>Instead, it feels like this pattern match confirms <code class="highlighter-rouge">Serializable</code> as a
possibility, instead of denying it.</p>

<p>But we don’t need <code class="highlighter-rouge">G = String</code> for this code to compile; we only need
<code class="highlighter-rouge">G &gt;: String</code>. If that was true, then <code class="highlighter-rouge">"Surely type G is String,
right?"</code>, a <code class="highlighter-rouge">String</code>, could simply upcast to <code class="highlighter-rouge">G</code>.</p>

<p>However, even <code class="highlighter-rouge">G &gt;: String</code> is unproven. There are no subclasses of
<code class="highlighter-rouge">String</code>, but there are infinitely many <em>subtypes</em> of
<code class="highlighter-rouge">String</code>. Including the <code class="highlighter-rouge">G</code> created by each entry into
<code class="highlighter-rouge">pickGreeting3</code>, every abstract and existential type bounded by
<code class="highlighter-rouge">String</code>, and every singleton type of <code class="highlighter-rouge">String</code> variable definitions.</p>

<p>This mistake is, once again, confusing a demonstration of one case
with a proof. Pattern matching tells us a great deal about one value,
the <code class="highlighter-rouge">grt</code> argument, but very little about the type <code class="highlighter-rouge">G</code>. All we know
for sure is that “<code class="highlighter-rouge">grt</code> is of type <code class="highlighter-rouge">G</code>, and also of type <code class="highlighter-rouge">String</code>, so
these types overlap by at least one value.” In the type system, if you
don’t know something for sure, you don’t know it at all.</p>

<h2 id="classes-are-a-concrete-source-of-values">Classes are a concrete source of values</h2>

<p>In the parlance of functional Scala, concrete classes are often called
“data constructors”.</p>

<p>When you are creating a value, you must ultimately be concrete about
its class, at the bottom of all the abstractions and indirections used
to hide this potentially messy detail.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">pickGreeting4</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span><span class="k">:</span> <span class="kt">G</span> <span class="o">=</span> <span class="k">new</span> <span class="n">G</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">12</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">class</span> <span class="k">type</span> <span class="kt">required</span> <span class="kt">but</span> <span class="kt">G</span> <span class="kt">found</span>
       <span class="k">def</span> <span class="n">pickGreeting4</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span><span class="k">:</span> <span class="kt">G</span> <span class="o">=</span> <span class="k">new</span> <span class="n">G</span>
                                     <span class="o">^</span>
</code></pre></div></div>

<p>You’ll have to do something else here, like take an argument
<code class="highlighter-rouge">() =&gt; G</code>, to let <code class="highlighter-rouge">pickGreeting4</code> construct <code class="highlighter-rouge">G</code>s.</p>

<p>The truly essential role that classes play is that they encapsulate
instructions for constructing concrete values of various types. In a
safe program, this is the only feature of classes you’ll use.</p>

<p>In Scala, classes leave fingerprints on the values that they
construct, without fail. This is merely an auxiliary part of their
primary function as value factories, like a “Made in <code class="highlighter-rouge">class Blah</code>”
sticker on the back. Pattern matching’s “type tests” work by checking
this fingerprint of construction.</p>

<h2 id="most-runtime-type-test-mechanisms-do-not-work-for-types">Most runtime “type test” mechanisms do not work for types</h2>

<p>These fingerprints only come from classes, not types. So “type tests”
only work for “classy” types, like <code class="highlighter-rouge">String</code> and <code class="highlighter-rouge">MyAwesomeMixin</code>. They
also work for specific singleton types because construction also
leaves an “object identity” fingerprint that the test can use.</p>

<p>The
<a href="http://www.scala-lang.org/api/2.12.1/scala/reflect/ClassTag.html"><code class="highlighter-rouge">ClassTag</code> typeclass</a> does
not change this restriction. When you add a <code class="highlighter-rouge">ClassTag</code> or <code class="highlighter-rouge">TypeTag</code>
context bound, you also prevent that type parameter from working with
most types.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">reflect.ClassTag</span><span class="o">[</span><span class="kt">greeting3.I</span><span class="o">]]</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">No</span> <span class="kt">ClassTag</span> <span class="kt">available</span> <span class="kt">for</span> <span class="kt">greeting3.I</span>
       <span class="n">implicitly</span><span class="o">[</span><span class="kt">reflect.ClassTag</span><span class="o">[</span><span class="kt">greeting3.I</span><span class="o">]]</span>
                 <span class="o">^</span>
</code></pre></div></div>

<p>As such, judicious use of <code class="highlighter-rouge">ClassTag</code> is not a great solution to
excessive use of type tests in abstract contexts. There are so many
more types than classes that this is to confine the expressivity of
your types to a very small, class-reflective box. Set them free!</p>

<h2 id="but-doesnt-pythonjavascriptc-have-both-types-and-classes-at-runtime">“But doesn’t Python/JavaScript/&amp;c have both types and classes at runtime?”</h2>

<p>In JavaScript, there’s a very general runtime classification of values
called “type”, meant to classify built-in categories like <code class="highlighter-rouge">string</code>,
<code class="highlighter-rouge">number</code>, and the like.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;</span> <span class="k">typeof</span> <span class="s2">"hi"</span>
<span class="s2">"string"</span>
<span class="o">&gt;&gt;</span> <span class="k">typeof</span> <span class="mi">42</span>
<span class="s2">"number"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">typeof</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'a'</span><span class="p">]</span>
<span class="s2">"object"</span>
</code></pre></div></div>

<p>Defining a class with the new <code class="highlighter-rouge">class</code> keyword doesn’t extend this
partition with new “types”; instead, it further subdivides <em>one</em> of
those with a separate classification.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;</span> <span class="kd">class</span> <span class="nx">Foo</span><span class="p">()</span> <span class="p">{}</span>
<span class="o">&gt;&gt;</span> <span class="kd">class</span> <span class="nx">Bar</span><span class="p">()</span> <span class="p">{}</span>
<span class="o">&gt;&gt;</span> <span class="k">typeof</span> <span class="p">(</span><span class="k">new</span> <span class="nx">Foo</span><span class="p">)</span>
<span class="s2">"object"</span>
<span class="o">&gt;&gt;</span> <span class="k">typeof</span> <span class="p">(</span><span class="k">new</span> <span class="nx">Bar</span><span class="p">)</span>
<span class="s2">"object"</span>
<span class="o">&gt;&gt;</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">().</span><span class="kd">constructor</span>
<span class="kd">function</span> <span class="nx">Foo</span><span class="p">()</span>
<span class="o">&gt;&gt;</span> <span class="k">new</span> <span class="nx">Bar</span><span class="p">().</span><span class="kd">constructor</span>
<span class="kd">function</span> <span class="nx">Bar</span><span class="p">()</span>
</code></pre></div></div>

<p>So, if you treat JavaScript’s definition of the word “type” as
analogous to the usage in this article, then yes, JavaScript has
“runtime types”.</p>

<p>But JavaScript can only conveniently get away with this because its
static types are uninteresting. It has one type—the type of all
values—and no opportunities to do interesting type-level modeling,
at least not as part of the standard language.</p>

<p>Hence, JavaScript is free to repurpose the word “type” for a flavor of
its classes, because our “types” aren’t a tool you make much use of in
JavaScript. But when you come back to Scala, Haskell, the ML family,
et al, you need a word for the static concept once again.</p>

<h2 id="thinking-about-types-as-just-classes-leads-to-incorrect-conclusions">Thinking about types as <em>just</em> classes leads to incorrect conclusions</h2>

<p>Setting aside the goal of principled definition of terms, this
separation is the one that makes the most sense for a practitioner of
Scala. Consider the practicalities:</p>

<p>Types and classes have different behavior, are equal and unequal
according to different rules, and there are a lot more types than
classes. So we need different words to distinguish them.</p>

<p>Saying “compile-time type” or “runtime type” is not a practical
solution—no one wants to speak such an unwieldy qualifier every
time they refer to such a commonly-used concept.</p>

<p>While I’ve given a sampling of the richness of the type system in this
article, it’s not necessary to know that full richness to appreciate
or remember the difference between the two: types are static and
compile-time; classes are dynamic and runtime.</p>

<p><em>This article was tested with Scala 2.12.1, Shapeless 2.3.2, and
Firefox 53.0a2.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Mon, 13 Feb 2017 00:00:00 +0100</pubDate>
        <link>https://typelevel.org/blog/2017/02/13/more-types-than-classes.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2017/02/13/more-types-than-classes.html</guid>
      </item>
    
      <item>
        <title>Endorsing the new Scala Code of Conduct</title>
        
          <dc:creator>typelevel</dc:creator>
                
        <description><![CDATA[<p>A couple of days ago, the new <a href="https://contributors.scala-lang.org/t/please-read-scala-code-of-conduct/28">Scala Code of Conduct</a> was published.
It applies to all official Scala channels, including mailing lists, Gitter channels and GitHub repositories.
We would like to take this opportunity to endorse this new Code of Conduct.
From our perspective, it does a good job of listing encouraged behaviour, instead of just banning harassment: It reflects the goal of <em>actively</em> creating a welcoming community.
Also, we consider it to be a decent substitute of our own <a href="/conduct.html">Code of Conduct</a>.
That means that Typelevel project maintainers are free to switch to the Scala Code of Conduct if they wish.</p>

<p>For some more background, please see the <a href="https://github.com/typelevel/general/issues/51">discussion on GitHub</a>.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sat, 17 Dec 2016 00:00:00 +0100</pubDate>
        <link>https://typelevel.org/blog/2016/12/17/scala-coc.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/12/17/scala-coc.html</guid>
      </item>
    
      <item>
        <title>API Design for Heaps (aka Priority Queues)</title>
        
          <dc:creator>chrisokasaki</dc:creator>
                
        <description><![CDATA[<p><em>This is a guest post by Chris Okasaki. It was initially published as the <a href="https://github.com/chrisokasaki/scads/blob/e78233ac6a787b7c66b44cd6139392418b214eb9/design/heaps.md">design document</a> behind <a href="https://github.com/chrisokasaki/scads">scads</a>. It is being republished here with the permission of the original author.</em></p>

<p>A heap (or priority queue) is a collection of elements ordered by some <code class="highlighter-rouge">Ordering</code>, optimized for retrieving the first element according to that ordering.
Duplicate elements are allowed.
Applications vary in whether they need the first element to be the smallest or the biggest element according to the ordering, so both variations should be easy to use.
(However, any given heap is expected to offer easy access to either the smallest element only or the biggest element only, not both at the same time.)
I will consider immutable heaps in this document, but the core issues discussed below apply to both immutable heaps and mutable heaps.</p>

<p>Even if an element type has a natural ordering, that ordering may not be the one we want to use, so we must allow the user to specify the ordering.</p>

<h2 id="problem-1-dont-mix-two-different-orderings-in-the-same-heap">Problem 1: Don’t mix two different orderings in the same heap</h2>

<p>Here is a strawman design for a very simple heap API:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Heap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="o">{</span>  <span class="c1">// WARNING: THIS IS BROKEN!!!
</span>  <span class="k">def</span> <span class="n">isEmpty</span><span class="o">(</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">Elem</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Elem</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">Elem</span><span class="o">])</span><span class="k">:</span> <span class="kt">Heap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">first</span><span class="o">(</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">Elem</span><span class="o">])</span><span class="k">:</span> <span class="kt">Elem</span>
  <span class="k">def</span> <span class="n">rest</span><span class="o">(</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">Elem</span><span class="o">])</span><span class="k">:</span> <span class="kt">Heap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span>
<span class="o">}</span>

<span class="c1">// factory method, probably in some companion object
</span><span class="k">def</span> <span class="n">empty</span><span class="o">[</span><span class="kt">Elem</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">Elem</span><span class="o">])</span><span class="k">:</span> <span class="kt">Heap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>You may think it strange that all of these methods are taking an <code class="highlighter-rouge">ord</code> parameter.
From a Scala point of view, that doesn’t make much sense.
But you can find variations of this design in many implementations of heaps on GitHub, including in the well-respected Scalaz library.
Why? As far as I can tell, the answer is <em>because Haskell does it that way</em>.
Here’s the equivalent design in Haskell:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">Heap</span> <span class="n">a</span>
<span class="n">empty</span>   <span class="o">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">Heap</span> <span class="n">a</span>
<span class="n">isEmpty</span> <span class="o">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">Heap</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">add</span>     <span class="o">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Heap</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Heap</span> <span class="n">a</span>
<span class="n">first</span>   <span class="o">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">Heap</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">rest</span>    <span class="o">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">Heap</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Heap</span> <span class="n">a</span>
</code></pre></div></div>

<p>In Haskell, this makes perfect sense.
Behind the scenes, each method takes an <code class="highlighter-rouge">Ord</code> dictionary as a hidden parameter.
But there’s one critical difference between Haskell and Scala: in Haskell, there can only be a <em>single</em> ordering for an element type, but in Scala, there can be <em>many</em> orderings for the same element type.</p>

<p>For example, consider this Scala code:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">ord1</span> <span class="k">=</span> <span class="nc">Ordering</span><span class="o">.</span><span class="nc">Int</span>
<span class="k">val</span> <span class="n">ord2</span> <span class="k">=</span> <span class="n">ord1</span><span class="o">.</span><span class="n">reverse</span>
<span class="k">val</span> <span class="n">heap1</span> <span class="k">=</span> <span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">ord1</span><span class="o">).</span><span class="n">add</span><span class="o">(</span><span class="mi">5</span><span class="o">)(</span><span class="n">ord1</span><span class="o">).</span><span class="n">add</span><span class="o">(</span><span class="mi">7</span><span class="o">)(</span><span class="n">ord1</span><span class="o">)</span>
<span class="k">val</span> <span class="n">heap2</span> <span class="k">=</span> <span class="n">heap1</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="mi">4</span><span class="o">)(</span><span class="n">ord2</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">heap2</span><span class="o">.</span><span class="n">first</span><span class="o">)</span>
</code></pre></div></div>

<p>What should this print?
Of course, that depends on the details of the implementation, but you would expect it to print either 4 (the smallest element) or 7 (the biggest element).
However, because one ordering was used for two of the <code class="highlighter-rouge">add</code>s and the opposite ordering was used for the third <code class="highlighter-rouge">add</code>, there’s an excellent chance that the actual result will be 5, which is the wrong answer for both orderings.</p>

<p>The magic of implicit parameters is that you usually don’t need to pass them explicitly.
But (A) there’s nothing to stop you from doing so, and (B) there’s nothing to prevent you from calling methods in different scopes with different orderings.
No, if you’re anything like me, the possibility that this could happen by accident is making your skin crawl.
Surely, the API should prevent this from happening!</p>

<p>Fortunately, this problem is very easy to fix.
<em>Only the <code class="highlighter-rouge">empty</code> method should take an ordering.</em>
Once that initial heap has been created, all future heaps derived from that heap via any sequence of <code class="highlighter-rouge">add</code>s or <code class="highlighter-rouge">rest</code>s should use the same ordering.
With this change, the API becomes:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Heap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Elem</span><span class="o">)</span><span class="k">:</span> <span class="kt">Heap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">first</span><span class="k">:</span> <span class="kt">Elem</span>
  <span class="k">def</span> <span class="n">rest</span><span class="k">:</span> <span class="kt">Heap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span>
<span class="o">}</span>

<span class="c1">// factory method, probably in some companion object
</span><span class="k">def</span> <span class="n">empty</span><span class="o">[</span><span class="kt">Elem</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">Elem</span><span class="o">])</span><span class="k">:</span> <span class="kt">Heap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Yay! That is both simpler and safer.</p>

<h2 id="problem-2-merge">Problem 2: <code class="highlighter-rouge">merge</code></h2>

<p>Another operation supported by many kinds of heaps is <code class="highlighter-rouge">merge</code>, which combines two heaps into a single heap.
Examples of heaps supporting merge include leftist heaps, skew heaps, binomial heaps (aka binomial queues), Fibonacci heaps, etc.</p>

<p>We can easily add <code class="highlighter-rouge">merge</code> to the existing <code class="highlighter-rouge">Heap[Elem]</code> trait.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Heap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">merge</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Heap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">])</span><span class="k">:</span> <span class="kt">Heap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>However, there are at last two problems with this.
First, traits allow for subclassing, so we might have several different implementations, such as leftist heaps and binomial heaps.
But we only want to merge leftist heaps with leftist heaps and binomial heaps with binomial heaps—we do <em>not</em> want to merge leftist heaps with binomial heaps.</p>

<p>There are several ways to address this problem.
For example, leftist heaps and binomial heaps could just use completely separate trait hierarchies, and each could use a <code class="highlighter-rouge">sealed trait</code> to prevent this unwanted mixing of types.</p>

<p>But the code duplication this would entail is unsatisfying.
It would also make it more difficult to share code (such as a testing harness) between different implementations.</p>

<p>Alternatively, we can control the types more precisely by adding a second type parameter for the specific representation being used, as in:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MHeap</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">Heap</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// MHeap is "Mergeable Heap"
</span>  <span class="c1">// Heap is the specific Heap representation being used
</span>  <span class="k">def</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Elem</span><span class="o">)</span><span class="k">:</span> <span class="kt">Heap</span>
  <span class="k">def</span> <span class="n">first</span><span class="k">:</span> <span class="kt">Elem</span>
  <span class="k">def</span> <span class="n">rest</span><span class="k">:</span> <span class="kt">Heap</span>
  <span class="k">def</span> <span class="n">merge</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Heap</span><span class="o">)</span><span class="k">:</span> <span class="kt">Heap</span>
<span class="o">}</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">LeftistHeap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">MHeap</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">LeftistHeap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]]</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">BinomialHeap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">MHeap</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">BinomialHeap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]]</span>
</code></pre></div></div>

<p>Because of the extra type parameter, a leftist heap and binomial heap are incompatible and cannot be merged.</p>

<h2 id="problem-3-merge-continued">Problem 3: <code class="highlighter-rouge">merge</code> (continued)</h2>

<p>There’s a second problem with <code class="highlighter-rouge">merge</code>.  A particular implementation, such as leftist heaps, would provide a factory method for creating a new heap.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">LeftistHeap</span> <span class="o">{</span> <span class="c1">// companion object
</span>  <span class="k">def</span> <span class="n">empty</span><span class="o">[</span><span class="kt">Elem</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">Elem</span><span class="o">])</span><span class="k">:</span> <span class="kt">LeftistHeap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Because of the <code class="highlighter-rouge">MHeap</code> definition, we can’t <code class="highlighter-rouge">merge</code> a leftist heap with a binomial heap.
But now we’ve re-introduced the problem of incompatible orderings!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">ord1</span> <span class="k">=</span> <span class="nc">Ordering</span><span class="o">.</span><span class="nc">Int</span>
<span class="k">val</span> <span class="n">ord2</span> <span class="k">=</span> <span class="n">ord1</span><span class="o">.</span><span class="n">reverse</span>
<span class="k">val</span> <span class="n">heap1</span> <span class="k">=</span> <span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">ord1</span><span class="o">).</span><span class="n">add</span><span class="o">(</span><span class="mi">5</span><span class="o">).</span><span class="n">add</span><span class="o">(</span><span class="mi">7</span><span class="o">)</span>
<span class="k">val</span> <span class="n">heap2</span> <span class="k">=</span> <span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="n">ord2</span><span class="o">).</span><span class="n">add</span><span class="o">(</span><span class="mi">6</span><span class="o">).</span><span class="n">add</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>
<span class="k">var</span> <span class="n">heap3</span> <span class="k">=</span> <span class="n">heap1</span><span class="o">.</span><span class="n">merge</span><span class="o">(</span><span class="n">heap2</span><span class="o">)</span>
<span class="k">while</span> <span class="o">(!</span><span class="n">heap3</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="n">heap3</span><span class="o">.</span><span class="n">first</span><span class="o">)</span>
  <span class="n">heap3</span> <span class="k">=</span> <span class="n">heap3</span><span class="o">.</span><span class="n">rest</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Notice that <code class="highlighter-rouge">heap1</code> and <code class="highlighter-rouge">heap2</code> were created with opposite orderings.
What happens if we merge them? Nothing good!
The exact results depend on details of the implementation, but a likely result is that loop will print the elements in the order 5,6,4,7—or maybe 5,7,6,4—when it <em>should</em> print them in sorted order!</p>

<p>We would really like to make this sort of situation impossible!
Maybe we could test the orderings for object equality at runtime, and throw an exception if they’re different?
That could actually work for simple types like integers with a built-in ordering object.
But for more complicated types, such as tuples, the orderings are generated on demand from the orderings of their constituent parts.
And this generation is not memoized, so if we demand an ordering for, say, <code class="highlighter-rouge">(Int,String)</code> twice, we’ll get two separate ordering objects, which will cause a false negative for our hypothetical dynamic equality check.</p>

<p>No, we would really like to make merging two heaps with different orderings a type error.
We can achieve this by making the notion of a factory explicit.
The idea is that heaps can only be merged with other heaps from the same factory.
Attempting to merge heaps from different factories will cause a type error.</p>

<p>In code, we might express this as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">HeapFactory</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Elem</span>
  <span class="k">type</span> <span class="kt">Heap</span> <span class="k">&lt;:</span> <span class="kt">MHeap</span><span class="o">[</span><span class="kt">Elem</span>,<span class="kt">Heap</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">empty</span><span class="k">:</span> <span class="kt">Heap</span>
  <span class="c1">// plus other factory methods
</span><span class="o">}</span>

<span class="k">object</span> <span class="nc">LeftistHeap</span> <span class="o">{</span> <span class="c1">// companion object
</span>  <span class="k">def</span> <span class="n">factory</span><span class="o">[</span><span class="kt">E</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">HeapFactory</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Elem</span> <span class="o">=</span> <span class="kt">E</span> <span class="o">}</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now we can say:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">minHeaps</span> <span class="k">=</span> <span class="nc">LeftistHeap</span><span class="o">.</span><span class="n">factory</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">Ordering</span><span class="o">.</span><span class="nc">Int</span><span class="o">)</span>
<span class="k">val</span> <span class="n">maxHeaps</span> <span class="k">=</span> <span class="nc">LeftistHeap</span><span class="o">.</span><span class="n">factory</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">Ordering</span><span class="o">.</span><span class="nc">Int</span><span class="o">.</span><span class="n">reverse</span><span class="o">)</span>

<span class="k">val</span> <span class="n">heap1</span> <span class="k">=</span> <span class="n">minHeaps</span><span class="o">.</span><span class="n">empty</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="mi">5</span><span class="o">).</span><span class="n">add</span><span class="o">(</span><span class="mi">7</span><span class="o">)</span>
<span class="k">val</span> <span class="n">heap2</span> <span class="k">=</span> <span class="n">minHeaps</span><span class="o">.</span><span class="n">empty</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="mi">6</span><span class="o">).</span><span class="n">add</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>
<span class="k">val</span> <span class="n">heap3</span> <span class="k">=</span> <span class="n">heap1</span><span class="o">.</span><span class="n">merge</span><span class="o">(</span><span class="n">heap2</span><span class="o">)</span> <span class="c1">// this typechecks
</span>
<span class="k">val</span> <span class="n">heap4</span> <span class="k">=</span> <span class="n">maxHeaps</span><span class="o">.</span><span class="n">empty</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="mi">6</span><span class="o">).</span><span class="n">add</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>
<span class="k">val</span> <span class="n">heap5</span> <span class="k">=</span> <span class="n">heap1</span><span class="o">.</span><span class="n">merge</span><span class="o">(</span><span class="n">heap4</span><span class="o">)</span> <span class="c1">// !!!type error!!!
</span></code></pre></div></div>

<p>Notice that <code class="highlighter-rouge">heap1</code>, <code class="highlighter-rouge">heap2</code>, and <code class="highlighter-rouge">heap3</code> have type <code class="highlighter-rouge">minHeaps.Heap</code> but <code class="highlighter-rouge">heap4</code> has type <code class="highlighter-rouge">maxHeaps.Heap</code>.
According to Scala’s notion of <em>path-dependent types</em>, these types are incompatible so attempting to merge <code class="highlighter-rouge">heap1</code> and <code class="highlighter-rouge">heap4</code> causes a type error, as desired.</p>

<h2 id="a-question">A question</h2>

<p>Clearly, if I create two factories with incompatible element types, then a heap from one factory should not be mergeable with a heap from the other factory.
Similarly, if I create two factories with the same element type but incompatible orderings, then again a heap from one factory should not be mergeable with a heap from the other factory.</p>

<p>But what if I create two separate factories with the same element type and the same ordering?
Should a heap created from one of these factories be mergeable with a heap created from the other factory?
It’s not clear.
If this duplication of factories was deliberate, then the answer is probably “no”.
This often happens with units of measure.
For example, maybe one of the factories is using integers to represent inches and the other is using integers to represent grams.
Even if the factories are using the same ordering, we probably don’t want to merge a heap of inches with a heap of grams!</p>

<p>On the other hand, the duplication of factories could be accidental, perhaps the result of two chunks of code being written separately and then brought together later.
In that case, we might very well want to be able to merge a heap from one factory with a heap from another accidentally-separate-but-equivalent factory.</p>

<p>Regardless of where you come down on what <em>should</em> happen, what <em>will</em> happen in the above design is that attempting to merge heaps from distinct factories will cause a type error, even if the factories were made for the same element type and ordering.</p>

<h2 id="problem-4-usability-in-the-simple-case">Problem 4: Usability in the simple case</h2>

<p>Most applications of priority queues do not need the <code class="highlighter-rouge">merge</code> method.
Trying to make <code class="highlighter-rouge">merge</code> typesafe has made the API more complicated and harder to use because of the need to instantiate a factory before creating actual heaps.
Can we hide these complications from a user until and unless they actually need to use <code class="highlighter-rouge">merge</code>? Yes.</p>

<p>I’ll re-introduce the interface without <code class="highlighter-rouge">merge</code>, but now called <code class="highlighter-rouge">SHeap</code> for “Simple Heap”:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">SHeap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Elem</span><span class="o">)</span><span class="k">:</span> <span class="kt">SHeap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">first</span><span class="k">:</span> <span class="kt">Elem</span>
  <span class="k">def</span> <span class="n">rest</span><span class="k">:</span> <span class="kt">SHeap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Then <code class="highlighter-rouge">MHeap</code> should be a subtype of <code class="highlighter-rouge">SHeap</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MHeap</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">Heap</span> <span class="k">&lt;:</span> <span class="kt">SHeap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">SHeap</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// inherits isEmpty and first from SHeap[Elem]
</span>  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Elem</span><span class="o">)</span><span class="k">:</span> <span class="kt">Heap</span> <span class="c1">// more specific return type
</span>  <span class="k">def</span> <span class="n">rest</span><span class="k">:</span> <span class="kt">Heap</span> <span class="c1">// more specific return type
</span>  <span class="k">def</span> <span class="n">merge</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Heap</span><span class="o">)</span><span class="k">:</span> <span class="kt">Heap</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">HeapFactory</code> definition is unchanged:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">HeapFactory</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Elem</span>
  <span class="k">type</span> <span class="kt">Heap</span> <span class="k">&lt;:</span> <span class="kt">MHeap</span><span class="o">[</span><span class="kt">Elem</span>,<span class="kt">Heap</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">empty</span><span class="k">:</span> <span class="kt">Heap</span>
  <span class="c1">// plus other factory methods
</span><span class="o">}</span>
</code></pre></div></div>

<p>The last part is that the companion object should supply simple factory methods in terms of <code class="highlighter-rouge">SHeap</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">LeftistHeap</span> <span class="o">{</span> <span class="c1">// companion object
</span>  <span class="k">def</span> <span class="n">empty</span><span class="o">[</span><span class="kt">E</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">SHeap</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
  <span class="c1">// plus other ordinary factory methods, similar to other Scala collections
</span>
  <span class="c1">// the big bad
</span>  <span class="k">def</span> <span class="n">factory</span><span class="o">[</span><span class="kt">E</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">HeapFactory</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Elem</span> <span class="o">=</span> <span class="kt">E</span> <span class="o">}</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now the user can proceed in blissful ignorance of <code class="highlighter-rouge">factory</code> or <code class="highlighter-rouge">MHeap</code>, treating this essentially just like any other Scala collection, until they need <code class="highlighter-rouge">merge</code>.
Of course, <code class="highlighter-rouge">empty</code> will probably be defined as</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="n">empty</span><span class="o">[</span><span class="kt">E</span><span class="o">](</span><span class="k">implicit</span> <span class="n">ord</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">SHeap</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="k">=</span> <span class="n">factory</span><span class="o">[</span><span class="kt">E</span><span class="o">](</span><span class="n">ord</span><span class="o">).</span><span class="n">empty</span>
</code></pre></div></div>

<p>(and similarly for the other ordinary factory methods), but the user doesn’t need to know that.</p>

<h2 id="problem-5-min-vs-max">Problem 5: <code class="highlighter-rouge">min</code> vs <code class="highlighter-rouge">max</code></h2>

<p>Should a heap favor smaller elements or bigger elements?
There’s no obvious answer—applications abound for both.
Therefore, an interface should easily support both flavors.
Right now, the ordering parameter allows us to say</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">minHeaps</span> <span class="k">=</span> <span class="nc">LeftistHeap</span><span class="o">.</span><span class="n">factory</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">Ordering</span><span class="o">.</span><span class="nc">Int</span><span class="o">)</span>
<span class="k">val</span> <span class="n">maxHeaps</span> <span class="k">=</span> <span class="nc">LeftistHeap</span><span class="o">.</span><span class="n">factory</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">Ordering</span><span class="o">.</span><span class="nc">Int</span><span class="o">.</span><span class="n">reverse</span><span class="o">)</span>
</code></pre></div></div>

<p>But how did I know that <code class="highlighter-rouge">Ordering.Int</code> was the right ordering for min-heaps and <code class="highlighter-rouge">Ordering.Int.reverse</code> was the right ordering for max-heaps?
The opposite could just as easily have been true.
Sure, this detail would probably be documented in the API, but it was fundamentally a flip-a-coin arbitrary decision.
And arbitrary decisions with no logic favoring one choice over the other are the hardest to remember.</p>

<p>In an easier-to-use interface, the user might write:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">minHeaps</span> <span class="k">=</span> <span class="nc">LeftistHeap</span><span class="o">.</span><span class="n">minFactory</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">Ordering</span><span class="o">.</span><span class="nc">Int</span><span class="o">)</span>
<span class="k">val</span> <span class="n">maxHeaps</span> <span class="k">=</span> <span class="nc">LeftistHeap</span><span class="o">.</span><span class="n">maxFactory</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">Ordering</span><span class="o">.</span><span class="nc">Int</span><span class="o">)</span>
</code></pre></div></div>

<p>Now, the user doesn’t need to worry whether to use <code class="highlighter-rouge">Ordering.Int</code> or <code class="highlighter-rouge">Ordering.Int.reverse</code>.
Instead, if they want min-oriented heaps, they call <code class="highlighter-rouge">minFactory(Ordering.Int)</code> and if they want max-oriented heaps, they call <code class="highlighter-rouge">maxFactory(Ordering.Int)</code>.
In fact, it’s even better than that.
The whole point of implicit parameters is that you usually don’t need to write them down explicitly.
In reality, the user would probably only write:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">minHeaps</span> <span class="k">=</span> <span class="nc">LeftistHeap</span><span class="o">.</span><span class="n">minFactory</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="k">val</span> <span class="n">maxHeaps</span> <span class="k">=</span> <span class="nc">LeftistHeap</span><span class="o">.</span><span class="n">maxFactory</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</code></pre></div></div>

<p>Actually, in the current version of scads, this is now</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">minHeaps</span> <span class="k">=</span> <span class="nc">LeftistHeap</span><span class="o">.</span><span class="nc">Min</span><span class="o">.</span><span class="n">factory</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="k">val</span> <span class="n">maxHeaps</span> <span class="k">=</span> <span class="nc">LeftistHeap</span><span class="o">.</span><span class="nc">Max</span><span class="o">.</span><span class="n">factory</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</code></pre></div></div>

<p>where <code class="highlighter-rouge">LeftistHeap.Min</code> and <code class="highlighter-rouge">LeftistHeap.Max</code> both support other simpler methods for creating <code class="highlighter-rouge">SHeap</code>s for users who don’t need <code class="highlighter-rouge">merge</code>.
For example, a user could write:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">h1</span> <span class="k">=</span> <span class="nc">LeftistHeap</span><span class="o">.</span><span class="nc">Min</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="c1">// an empty min-heap of integers
</span><span class="k">val</span> <span class="n">h2</span> <span class="k">=</span> <span class="nc">LeftistHeap</span><span class="o">.</span><span class="nc">Max</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span> <span class="c1">// a max-heap containing 1, 2, and 3
</span></code></pre></div></div>

<p>Of course, there’s lots more needed to flesh the whole design out into an industrial-strength API, and even more to integrate it with the current Scala collections.
I’ll continue to work on this, and I welcome discussion on these issues.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 17 Nov 2016 00:00:00 +0100</pubDate>
        <link>https://typelevel.org/blog/2016/11/17/heaps.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/11/17/heaps.html</guid>
      </item>
    
      <item>
        <title>EDSLs as functions</title>
        
          <dc:creator>adelbertc</dc:creator>
                
        <description><![CDATA[<p><em>This is the second of a series of articles on “Monadic EDSLs in Scala.”</em></p>

<p>Perhaps the most direct way to start writing an EDSL is to start writing
functions. Let’s say we want a language for talking about sets of integers.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">SetLang</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">set</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">set</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">exists</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">set</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This works… to the extent that we want only to work with
<code class="highlighter-rouge">scala.collection.Set</code>s. As it stands we cannot talk about
other sets such as bloom filters or sets controlled by other threads.
Our language isn’t <em>abstract</em> enough, so let’s remove
all traces of <code class="highlighter-rouge">Set</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">SetLang</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">set</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">set</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">exists</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">set</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span>

  <span class="c1">// Given unknown F we no longer know how to create an empty set
</span>  <span class="c1">// so we add the capability to our language
</span>  <span class="k">def</span> <span class="n">empty</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We’ve parameterized our language with a <a href="/blog/2016/08/21/hkts-moving-forward.html" title="Higher-kinded types: the difference between giving up, and moving forward">higher-kinded type</a> which
represents the context of our set. A similar parameterization could be
done with a *-kinded type (e.g. <code class="highlighter-rouge">SetLang[A]</code>) but since this series
focuses on <strong>monadic</strong> EDSLs, the choice is made for us.</p>

<p>Now we can write mini-programs which talk about some abstract set
yet to be determined.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">lang</span><span class="k">:</span> <span class="kt">SetLang</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">lang._</span>
  <span class="n">exists</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">remove</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="n">add</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">add</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="n">empty</span><span class="o">))))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Interpretation of our program is done by implementing <code class="highlighter-rouge">SetLang</code> and
passing an instance into <code class="highlighter-rouge">program</code>.</p>

<p>However, our language is still not abstract enough. Replacing <code class="highlighter-rouge">Set</code>
with <code class="highlighter-rouge">F</code> allows us to swap in implementations of sets, but doesn’t
allow us to talk about the context. Consider the behavior of <code class="highlighter-rouge">exists</code> if <code class="highlighter-rouge">F</code>
represents some remote set. Since <code class="highlighter-rouge">exists</code> returns a <code class="highlighter-rouge">Boolean</code>,
checking membership must be a synchronous operation despite the set living
on another node.</p>

<p>It’s also tedious to thread the set through each method manually.</p>

<p>We can solve both problems by generalizing the use of <code class="highlighter-rouge">F</code> to some
context that is able to read and write to some set
(think <code class="highlighter-rouge">Set[Int] =&gt; (Set[Int], A)</code>).</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">SetLang</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">exists</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>

  <span class="c1">// No longer need `empty` since the "context" has it already
</span><span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">SetLang</code> can now talk about the <strong>effects</strong> around interpretation, such as
asynchronity.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.Future</span>

<span class="k">type</span> <span class="kt">AsyncSet</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Future</span><span class="o">[(</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">A</span><span class="o">)]</span>

<span class="k">object</span> <span class="nc">AsyncSet</span> <span class="k">extends</span> <span class="nc">SetLang</span><span class="o">[</span><span class="kt">AsyncSet</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Future</span><span class="o">[(</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Unit</span><span class="o">)]</span> <span class="k">=</span> <span class="o">???</span>

  <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Future</span><span class="o">[(</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Unit</span><span class="o">)]</span> <span class="k">=</span> <span class="o">???</span>

  <span class="k">def</span> <span class="n">exists</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Future</span><span class="o">[(</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Boolean</span><span class="o">)]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This new encoding introduces a new but important problem: how do we
combine the results of multiple calls to <code class="highlighter-rouge">SetLang</code> methods? In the previous
encoding we could add and remove by threading the set from one call to
the next. With this change to represent a context, it’s not clear how to do
that.</p>

<p>Fortunately we are now in a position to leverage a powerful tool:
<a href="http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf" title="Monads for functional programming">monads</a>. By extending our set language to be monadic
we recover composition in an elegant way. The <a href="https://github.com/typelevel/cats" title="Typelevel Cats">Cats</a> library is used
for demonstration purposes, but the discussion applies equally to
<a href="https://github.com/scalaz/scalaz/tree/series/7.3.x" title="Scalaz 7">Scalaz</a>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Monad</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">trait</span> <span class="nc">SetLang</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="c1">// See: https://typelevel.org/blog/2016/09/30/subtype-typeclasses.html
</span>  <span class="c1">// for why the `Monad` instance is defined as a member as opposed to inherited
</span>  <span class="k">def</span> <span class="n">monad</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">exists</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">lang</span><span class="k">:</span> <span class="kt">SetLang</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">lang._</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">monadInstance</span> <span class="k">=</span> <span class="n">monad</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">add</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">add</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">remove</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="n">exists</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">b</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Defining an interpreter starts by identifying a target context. Since the context
computes values while updating state, this suggests the state monad.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.data.State</span>

<span class="k">object</span> <span class="nc">ScalaSet</span> <span class="k">extends</span> <span class="nc">SetLang</span><span class="o">[</span><span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">monad</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span>

  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">State</span><span class="o">.</span><span class="n">modify</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="n">i</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">State</span><span class="o">.</span><span class="n">modify</span><span class="o">(</span><span class="k">_</span> <span class="o">-</span> <span class="n">i</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">exists</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">State</span><span class="o">.</span><span class="n">inspect</span><span class="o">(</span><span class="k">_</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">state</span> <span class="k">=</span> <span class="n">program</span><span class="o">[</span><span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]](</span><span class="nc">ScalaSet</span><span class="o">)</span>
<span class="c1">// state: cats.data.StateT[cats.Eval,scala.collection.immutable.Set[Int],Boolean] = cats.data.StateT@ce9f626
</span>
<span class="n">state</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">).</span><span class="n">value</span>
<span class="c1">// res5: (scala.collection.immutable.Set[Int], Boolean) = (Set(10),true)
</span></code></pre></div></div>

<p>Note that calling <code class="highlighter-rouge">program</code> did not require any context-specific knowledge -
we could define another interpreter, perhaps one that talks to a set
concurrently.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.data.StateT</span>
<span class="k">import</span> <span class="nn">scala.concurrent.</span><span class="o">{</span><span class="nc">ExecutionContext</span><span class="o">,</span> <span class="nc">Future</span><span class="o">}</span>

<span class="c1">// Asynchronous state
</span><span class="k">def</span> <span class="nc">AsyncSet</span><span class="o">(</span><span class="k">implicit</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">SetLang</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">Future</span>, <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">SetLang</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">Future</span>, <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">monad</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">Future</span>, <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span>

    <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">Future</span>, <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">StateT</span><span class="o">.</span><span class="n">modify</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="n">i</span><span class="o">)</span>

    <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">Future</span>, <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">StateT</span><span class="o">.</span><span class="n">modify</span><span class="o">(</span><span class="k">_</span> <span class="o">-</span> <span class="n">i</span><span class="o">)</span>

    <span class="k">def</span> <span class="n">exists</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">Future</span>, <span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">StateT</span><span class="o">.</span><span class="n">inspect</span><span class="o">(</span><span class="k">_</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
  <span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// No changes to `program` required
</span><span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">program</span><span class="o">(</span><span class="nc">AsyncSet</span><span class="o">(</span><span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span><span class="o">))</span>
<span class="c1">// result: cats.data.StateT[scala.concurrent.Future,scala.collection.immutable.Set[Int],Boolean] = cats.data.StateT@1c029382
</span></code></pre></div></div>

<p><code class="highlighter-rouge">SetLang</code> captures the <em>structure</em> of a computation, but leaves open
its <em>interpretation</em>.</p>

<h1 id="monad-transformers-and-classes">Monad transformers and classes</h1>

<p>As it turns out, <code class="highlighter-rouge">SetLang</code> is an example of an encoding often referred to as
<a href="https://hackage.haskell.org/package/mtl" title="Monad classes">MTL-style</a>.</p>

<h2 id="monads-in-monads">Monads in monads</h2>

<p>Among the motivations for monad classes is to remove the need to specify
monad transformer stacks. The following example is adapted from
<a href="http://web.cecs.pdx.edu/~mpj/pubs/springschool.html" title="Functional Programming with Overloading and Higher-Order Polymorphism">Functional Programming with Overloading and Higher-Order Polymorphism</a>
by Professor Mark P. Jones.</p>

<p>Consider a program that is open to failure and computes with some state. This
suggests a combinator of <code class="highlighter-rouge">Either</code> and <code class="highlighter-rouge">State</code>, both of which have
monad transformers. All that is left is to decide which transformer to use.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">App1</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">EitherT</span><span class="o">[</span><span class="kt">State</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">Error</span>, <span class="kt">A</span><span class="o">]</span>
            <span class="c1">// State[S, Either[Error, A]]
</span>            <span class="c1">// S =&gt; (S, Either[Error, A])
</span>
<span class="k">type</span> <span class="kt">App2</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">Error</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span>
            <span class="c1">// S =&gt; Either[Error, (S, A)]
</span></code></pre></div></div>

<p>While <code class="highlighter-rouge">App1</code> and <code class="highlighter-rouge">App2</code> are both valid compositions, the
semantics of the compositions differ. <code class="highlighter-rouge">App1</code> describes a program where
the computation of a <em>value</em> at each transition may fail - but any changes
are preserved - whereas <code class="highlighter-rouge">App2</code> describes a program where the <em>entire</em>
transition may fail.</p>

<p>We can abstract away the difference by creating a type class which provides
the relevant operations we need.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">monad</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">raiseError</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">handleErrorWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">MonadState</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">S</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">monad</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">get</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Similar type classes exist for the <code class="highlighter-rouge">Reader</code> and <code class="highlighter-rouge">Writer</code> data types.
These type classes are provided in both <a href="https://github.com/typelevel/cats" title="Typelevel Cats">Cats</a> and <a href="https://github.com/scalaz/scalaz/tree/series/7.3.x" title="Scalaz 7">Scalaz</a>,
<a href="/blog/2016/09/30/subtype-typeclasses.html" title="Subtype type classes don't work">with some caveats</a>.</p>

<p>With these type classes in place we can write functions against these as
opposed to specific transformer stacks. Furthermore our functions can specify
exactly what operations they need which helps correctness and
<a href="https://www.mpi-sws.org/~dreyer/tor/papers/wadler.pdf" title="Theorems for free!">parametricity</a>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.</span><span class="o">{</span><span class="nc">MonadError</span><span class="o">,</span> <span class="nc">MonadState</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">cats.data.</span><span class="o">{</span><span class="nc">EitherT</span><span class="o">,</span> <span class="nc">State</span><span class="o">,</span> <span class="nc">StateT</span><span class="o">}</span>

<span class="k">def</span> <span class="n">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">F0</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">String</span><span class="o">],</span>
                           <span class="n">F1</span><span class="k">:</span> <span class="kt">MonadState</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">F0</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">F1</span><span class="o">.</span><span class="n">get</span><span class="o">)</span> <span class="o">{</span> <span class="n">i</span> <span class="k">=&gt;</span>
    <span class="n">F0</span><span class="o">.</span><span class="n">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="s">"fail"</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Our program can then be instantiated with either transformer stack.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="c1">// At the time of this writing Cats does not have these instances
// so they are defined here.
//
// Additionally, both Cats and Scalaz 7 have encoding issues
// with these MTL type classes which requires us to redefine Monad when
// defining MonadState instances, despite there already being one.
</span><span class="k">implicit</span> <span class="k">def</span> <span class="n">eitherTMonadState</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span>, <span class="kt">S</span><span class="o">](</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">MonadState</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span><span class="o">])</span><span class="k">:</span> <span class="kt">MonadState</span><span class="o">[</span><span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">S</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">MonadState</span><span class="o">[</span><span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">S</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">get</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">S</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">EitherT</span><span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="k">_</span><span class="o">)))</span>

    <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">EitherT</span><span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">set</span><span class="o">(</span><span class="n">s</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="k">_</span><span class="o">)))</span>

    <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">])</span>
                     <span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="n">fa</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>

    <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">EitherT</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>

    <span class="k">def</span> <span class="n">tailRecM</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]])</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">EitherT</span><span class="o">.</span><span class="n">catsDataMonadErrorForEitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">].</span><span class="n">tailRecM</span><span class="o">(</span><span class="n">a</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
  <span class="o">}</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="n">stateTMonadError</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span>, <span class="kt">S</span><span class="o">](</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">handleErrorWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span> <span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="k">val</span> <span class="n">state</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">S</span>, <span class="kt">A</span><span class="o">)]</span> <span class="k">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
        <span class="n">F</span><span class="o">.</span><span class="n">handleErrorWith</span><span class="o">(</span><span class="n">state</span><span class="o">)(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">e</span><span class="o">).</span><span class="n">run</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
      <span class="o">}</span>

    <span class="k">def</span> <span class="n">raiseError</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">)</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">StateT</span><span class="o">.</span><span class="n">lift</span><span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">raiseError</span><span class="o">(</span><span class="n">e</span><span class="o">))</span>

    <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="n">fa</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>

    <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">StateT</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>

    <span class="k">def</span> <span class="n">tailRecM</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]])</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">StateT</span><span class="o">.</span><span class="n">catsDataMonadStateForStateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span><span class="o">].</span><span class="n">tailRecM</span><span class="o">(</span><span class="n">a</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
  <span class="o">}</span>

<span class="k">type</span> <span class="kt">App1</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">EitherT</span><span class="o">[</span><span class="kt">State</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">String</span>, <span class="kt">A</span><span class="o">]</span>

<span class="k">type</span> <span class="kt">App2</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">Int</span>, <span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">app1</span> <span class="k">=</span> <span class="n">program</span><span class="o">[</span><span class="kt">App1</span><span class="o">]</span>
<span class="c1">// app1: App1[Int] = EitherT(cats.data.StateT@5fdc056d)
</span>
<span class="k">val</span> <span class="n">app2</span> <span class="k">=</span> <span class="n">program</span><span class="o">[</span><span class="kt">App2</span><span class="o">]</span>
<span class="c1">// app2: App2[Int] = cats.data.StateT@72493a33
</span></code></pre></div></div>

<h1 id="composing-languages">Composing languages</h1>

<p>From one angle we can view our set language, or more generally any EDSL
in MTL-style, as an effect like <code class="highlighter-rouge">MonadError</code> and <code class="highlighter-rouge">MonadState</code>. From another
angle we can view <code class="highlighter-rouge">MonadError</code> and <code class="highlighter-rouge">MonadState</code> as EDSLs that talk about errors
and stateful computations. We can eliminate the distinctions by renaming
<code class="highlighter-rouge">SetLang</code> to <code class="highlighter-rouge">MonadSet</code> and treating it as a type class.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Monad</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">trait</span> <span class="nc">MonadSet</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">monad</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">exists</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Composing multiple languages then becomes adding constraints to functions, and
interpretation becomes instantiating type parameters that satisfy the
constraints.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadCalc</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">monad</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">lit</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="n">r</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">setProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">MonadSet</span><span class="o">](</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">MonadSet</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="n">exists</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>

<span class="k">def</span> <span class="n">calcProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">MonadCalc</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">calc</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">MonadCalc</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span>
  <span class="n">calc</span><span class="o">.</span><span class="n">plus</span><span class="o">(</span><span class="n">calc</span><span class="o">.</span><span class="n">lit</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="n">calc</span><span class="o">.</span><span class="n">lit</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">composedProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">MonadCalc:</span> <span class="kt">MonadSet</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">monad</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">MonadCalc</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="n">monad</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">i</span> <span class="k">&lt;-</span> <span class="n">calcProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="n">setProgram</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">b</span>
<span class="o">}</span>

<span class="c1">// Instance
</span>
<span class="c1">// Instances are defined together but nothing is stopping us from defining
// these separately, perhaps one in the MonadSet object and another in the
// SetState object.
</span><span class="k">implicit</span> <span class="k">val</span> <span class="n">stateInstance</span><span class="k">:</span> <span class="kt">MonadSet</span><span class="o">[</span><span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">with</span> <span class="nc">MonadCalc</span><span class="o">[</span><span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">MonadSet</span><span class="o">[</span><span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">with</span> <span class="nc">MonadCalc</span><span class="o">[</span><span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">monad</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span>

    <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">State</span><span class="o">.</span><span class="n">modify</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="n">i</span><span class="o">)</span>

    <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">State</span><span class="o">.</span><span class="n">modify</span><span class="o">(</span><span class="k">_</span> <span class="o">-</span> <span class="n">i</span><span class="o">)</span>

    <span class="k">def</span> <span class="n">exists</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span> <span class="nc">State</span><span class="o">.</span><span class="n">inspect</span><span class="o">(</span><span class="k">_</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>

    <span class="k">def</span> <span class="n">lit</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">State</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
    <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Int</span><span class="o">],</span> <span class="n">r</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
      <span class="o">(</span><span class="n">l</span> <span class="o">|@|</span> <span class="n">r</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">composedProgram</span><span class="o">[</span><span class="kt">State</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]].</span><span class="n">run</span><span class="o">(</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">]).</span><span class="n">value</span>
<span class="c1">// result: (scala.collection.immutable.Set[Int], Boolean) = (Set(),false)
</span></code></pre></div></div>

<p>As before, <code class="highlighter-rouge">composedProgram</code>, <code class="highlighter-rouge">calcProgram</code>, and <code class="highlighter-rouge">setProgram</code> are defined
independent of interpretation, so alternative interpretations simply require
defining appropriate instances.</p>

<h1 id="a-note-about-laws">A note about laws</h1>

<p>Type classes should come with laws - this lets us give meaning to their use.
The <code class="highlighter-rouge">Monoid</code> type class requires data types to have an <strong>associative</strong> binary
operation and a corresponding identity element. These laws allow us to
parallelize batch operations, such as partitioning a <code class="highlighter-rouge">List[A]</code> into
multiple chunks to be scattered across threads or machines and gathered
back.</p>

<p>Since our EDSLs are type classes, we should think about what laws we expect
to hold. Below are some possible candidates for laws:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// MonadSet
set *&gt; add(i)    *&gt; remove(i) = set
set *&gt; remove(i) *&gt; exists(i) = false
set *&gt; add(i)    *&gt; exists(i) = true

// MonadCalc - these are just the Monoid laws
plus(lit(0), x) = plus(x, lit(0)) = x
plus(x, plus(y, z)) = plus(plus(x, y), z)
</code></pre></div></div>

<p>Next up we’ll take a look at some pitfalls of this approach, and a modified
encoding that solves some of them.</p>

<p><em>This article was tested with Scala 2.11.8, Cats 0.7.2, kind-projector 0.9.0,
and si2712fix-plugin 1.2.0 using <a href="https://github.com/tpolecat/tut" title="tut: doc/tutorial generator for scala">tut</a>.</em></p>

<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 26 Oct 2016 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2016/10/26/edsls-part-2.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/10/26/edsls-part-2.html</guid>
      </item>
    
      <item>
        <title>Typelevel representative at the Scala Center Advisory Board</title>
        
          <dc:creator>larsrh</dc:creator>
                
        <description><![CDATA[<p>It is our pleasure to announce that the Scala Center Advisory Board has invited us to nominate a member of the Typelevel community to serve as a community representative, alongside Bill Venners.
To figure out whether or not we should accept this offer and who we pick we have held <a href="https://github.com/typelevel/general/issues/42">an open discussion on GitHub</a>, resulting in my nomination, which I happily accept.
Thanks everyone for their trust!
The corresponding Scala Center announcement can be found <a href="http://scala-lang.org/blog/2016/10/24/lars-hupel-joins-sc-board.html">here</a>.</p>

<p><em>On a more personal note:
Some years ago, when I initially registered the <code class="highlighter-rouge">typelevel.org</code> domain, I could have never anticipated the large community which has gathered around typeful functional programming in Scala.
The offer from the Scala Center to nominate a representative is an acknowledgement, and also a positive signal for community outreach.
So, naturally, I’m very excited about what lies ahead.
Keep rocking!</em></p>

<p>What follows is a summary of the process.</p>

<h2 id="scala-center-advisory-board">Scala Center Advisory Board</h2>

<p>To quote <a href="http://www.scala-lang.org/blog/2016/05/30/scala-center-advisory-board.html">Jon Pretty</a>:</p>

<blockquote>
  <p>The Advisory Board is a separate body from the Scala Center, much as many governments have separate legislative and executive branches: the Advisory Board makes recommendations to the Scala Center on the work we should do, but it’s the Scala Center’s job to execute those recommendations.</p>

  <p>It currently has seven voting members: representatives from each of our six sponsors, plus Bill Venners, the community representative. Additionally the Executive Director of the Scala Center, Heather Miller, sits on the board to report on the Scala Center’s activities, and provide advice on the feasibility of the proposals under consideration, and Martin Odersky is the technical advisor to the board.</p>
</blockquote>

<p>More details, including minutes and bylaws, can be found on <a href="https://scala.epfl.ch/">their website</a>.</p>

<h2 id="process">Process</h2>

<p>To make the nomination as transparently as possible, I <a href="https://github.com/typelevel/general/issues/42">opened an issue</a> shortly after Jon mailed me about the opening.
The discussion period ended on October 12th.
All nominees endorsed me, so no vote was necessary.</p>

<h2 id="provisions">Provisions</h2>

<p>As indicated in the discussion about the nomination, we have established that the term length will be one year and after that, we will have another vote.
I hope this measure will improve community participation.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Tue, 18 Oct 2016 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2016/10/18/scala-center.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/10/18/scala-center.html</guid>
      </item>
    
      <item>
        <title>Let's build ourselves a small ScalaCheck</title>
        
          <dc:creator>larsrh</dc:creator>
                
        <description><![CDATA[<p><em><a href="http://scalacheck.org/">ScalaCheck</a> is a well-known property-based testing library, based on ideas from Haskell’s <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a>.
It is also a <a href="/projects">Typelevel project</a>.
In this post, I’d like to show some of the underlying mechanisms, stripped down to the bare minimum.</em></p>

<p>Testing with properties is well-understood in academia and widely used in parts of the industry – namely the parts which embrace functional programming.
However, the design space of property-testing libraries is rather large.
I think it is high time to talk about various tradeoffs done in libraries.
Here, I’d like to contribute by implementing a ScalaCheck clone from scratch using a very similar design and explaining the design choices along the way.</p>

<p>This is not an introduction to property testing.
However, it can be read as a guide to implementation ideas.
QuickCheck, ScalaCheck and the like are nice examples of functional library design, but their internals are often obscured by technicalities.
I hope that by clearing up some of the concepts it will become easier to read their code and perhaps designing your own property-testing library.</p>

<h2 id="the-first-design-decision">The first design decision</h2>

<p>The basic point of a property testing library is providing an interface looking roughly like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Prop</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">check</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">???</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Prop</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">forAll</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">prop</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Prop</span> <span class="o">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now, you can use that in your test code:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Prop</span><span class="o">.</span><span class="n">forAll</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="n">x</span> <span class="o">==</span> <span class="n">x</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This expresses that you have a property which is parameterized on a single integer number.
Hence, the library must somehow provide these integer numbers.
The original Haskell QuickCheck, ScalaCheck and many other libraries use a <em>random generator</em> for this.
This comes with a number of advantages:</p>

<ul>
  <li>It is relatively simple and efficient to implement.</li>
  <li>Random number generators compose exceedingly well.</li>
  <li>The confidence in the tests can be increased by just generating more inputs.</li>
  <li>Depending on the random distributions of the generators used, you have chances that both “exotic” and “common” inputs are covered.</li>
  <li>In practice, it turns out that random generators are decent at finding edge cases.</li>
</ul>

<p>But it is also not without problems:</p>

<ul>
  <li>For more complex inputs, the default generators are basically useless, because they will produce invalid input most of the time.</li>
  <li>Filtering random values before feeding them into the property can dramatically slow down the whole process.</li>
  <li>By default, it is non-deterministic (but there are remedies available).</li>
  <li>Generation of <em>random functions</em> to be used as inputs for higher-order properties is quite round-about.</li>
</ul>

<p>Of course, there are other possible design choices:</p>

<ul>
  <li><a href="https://hackage.haskell.org/package/smallcheck">SmallCheck</a> instead enumerates <em>all</em> values up to a certain size.
For example, you can specify that you want to test some function over integer lists with all lists up to size 5, containing all integers between -5 and +5.
In some situations, namely when your input is finite, you can even <em>exhaustively</em> check all inputs, which is equivalent to a <em>proof</em> that your program is correct.
The disadvantage is that even for small sizes, the input space may explode exponentially or worse (e.g. when generating lists of lists).</li>
  <li><a href="https://isabelle.in.tum.de">Isabelle</a> Quickcheck supports multiple modes, including <em>narrowing</em>, which is a form of symbolically exploring the search space.
This is based on Haskell’s <a href="https://hackage.haskell.org/package/lazysmallcheck">Lazy SmallCheck</a> (see also the <a href="https://www.cs.york.ac.uk/fp/smallcheck/smallcheck.pdf">paper by Runciman et.al.</a>).
The basic idea is that we can try to evaluate properties with <em>partially-defined inputs</em> and refine them on demand.</li>
</ul>

<p><strong>For this post, we’re assuming that random generation is a given.</strong></p>

<h2 id="the-second-design-decision">The second design decision</h2>

<blockquote>
  <p>Do we want to do this purely or poorly?</p>
</blockquote>

<p>Of course, this motto is tongue-in-cheek.
Just because something isn’t <em>pure</em> doesn’t mean that it is <em>poor.</em></p>

<p>To understand the design space here, let’s focus on the smallest building block: A primitive random generator.
There are two possible ways to model this.
The <em>mutable</em> way is what Java, Scala and many other languages offer in their libraries:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Random</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">nextInt</span><span class="o">(</span><span class="n">min</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">max</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">def</span> <span class="n">nextFloat</span><span class="o">()</span><span class="k">:</span> <span class="kt">Float</span>
  <span class="k">def</span> <span class="n">nextItem</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">pool</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>
</code></pre></div></div>

<p>By looking at the types alone, we can already see that two subsequent calls of <code class="highlighter-rouge">nextInt</code> will produce different results; the interface is thus <em>impure.</em></p>

<p>The <em>pure</em> way is to make the internal state (also known as “seed” in the context of random generators) explicit:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Seed</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">nextInt</span><span class="o">(</span><span class="n">min</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">max</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Seed</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">nextFloat</span><span class="k">:</span> <span class="o">(</span><span class="kt">Float</span><span class="o">,</span> <span class="kt">Seed</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">nextItem</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">pool</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">Seed</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Seed</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">init</span><span class="o">()</span><span class="k">:</span> <span class="kt">Seed</span> <span class="o">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Because this is difficult to actually use (don’t mix up the <code class="highlighter-rouge">Seed</code> instances and use them twice!), one would wrap this into a state monad:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Random</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">private</span> <span class="k">val</span> <span class="n">op</span><span class="k">:</span> <span class="kt">Seed</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="nc">Seed</span><span class="o">))</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="k">def</span> <span class="n">run</span><span class="o">()</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">op</span><span class="o">(</span><span class="nc">Seed</span><span class="o">.</span><span class="n">init</span><span class="o">()).</span><span class="n">_1</span>

  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Random</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Random</span><span class="o">[</span><span class="kt">B</span><span class="o">]({</span> <span class="n">seed0</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">seed1</span><span class="o">)</span> <span class="k">=</span> <span class="n">self</span><span class="o">.</span><span class="n">op</span><span class="o">(</span><span class="n">seed0</span><span class="o">)</span>
      <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="n">seed1</span><span class="o">)</span>
    <span class="o">})</span>

  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Random</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Random</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Random</span><span class="o">[</span><span class="kt">B</span><span class="o">]({</span> <span class="n">seed0</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">seed1</span><span class="o">)</span> <span class="k">=</span> <span class="n">self</span><span class="o">.</span><span class="n">op</span><span class="o">(</span><span class="n">seed0</span><span class="o">)</span>
      <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="n">op</span><span class="o">(</span><span class="n">seed1</span><span class="o">)</span>
    <span class="o">})</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"&lt;random&gt;"</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Random</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">int</span><span class="o">(</span><span class="n">min</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">max</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Random</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">nextInt</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">max</span><span class="o">))</span>
  <span class="k">val</span> <span class="n">float</span><span class="k">:</span> <span class="kt">Random</span><span class="o">[</span><span class="kt">Float</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">nextFloat</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now we can use Scala’s <code class="highlighter-rouge">for</code> comprehensions:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="n">x</span> <span class="k">&lt;-</span> <span class="nc">Random</span><span class="o">.</span><span class="n">int</span><span class="o">(-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
  <span class="n">y</span> <span class="k">&lt;-</span> <span class="nc">Random</span><span class="o">.</span><span class="n">int</span><span class="o">(-</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
<span class="c1">// res2: Random[(Int, Int)] = &lt;random&gt;
</span></code></pre></div></div>

<p>The tradeoffs here are the usual when we’re talking about functional programming in Scala: Reasoning ability, convenience, performance, … 
In the pure case, there are also multiple other possible encodings, including free monads.
Luckily, this blog covers that topic in another <a href="/blog/2016/09/21/edsls-part-1.html">post</a>.</p>

<p>How do other libraries fare here?</p>

<ul>
  <li>ScalaCheck up to 1.12.x uses a mutable random number generator; namely, <code class="highlighter-rouge">scala.util.Random</code>.</li>
  <li>ScalaCheck 1.13.x+ uses its own, immutable implementation.</li>
  <li>Another Scala library for property testing, <a href="https://github.com/scalaprops/scalaprops">scalaprops</a>, does not.
I’m not familiar with it, but as far as I can tell from the <a href="https://github.com/scalaprops/scalaprops/blob/v0.3.4/gen/src/main/scala/scalaprops/Rand.scala">sources</a>, it’s similar to the <code class="highlighter-rouge">Seed</code> trait from above, and there is also an additional state-monadic layer on top of it.</li>
  <li>In QuickCheck, the encoding seems strange at first.
They use a primitive generator which looks a lot like <code class="highlighter-rouge">Seed</code>, but they don’t use the updated seed.
Instead, their approach is via an additional primitive <code class="highlighter-rouge">split</code> of type <code class="highlighter-rouge">Seed =&gt; (Seed, Seed)</code>, which gets used to “distribute” randomness during composition (see the <a href="http://publications.lib.chalmers.se/records/fulltext/183348/local_183348.pdf">paper by Claessen &amp; Pałka</a> about the theory behind that).
It is worth noting that Java 8 introduced a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/SplittableRandom.html"><code class="highlighter-rouge">SplittableRandom</code></a> class.</li>
</ul>

<p><strong>For this post, we’re assuming that mutable state is a given.</strong>
We’ll use <code class="highlighter-rouge">scala.util.Random</code> (because it’s readily available) in a similar fashion to ScalaCheck 1.12.x.</p>

<h2 id="the-third-design-decision">The third design decision</h2>

<p>Asynchronous programming is all the rage these days.
This means that many functions will not return plain values of type <code class="highlighter-rouge">A</code>, but rather <code class="highlighter-rouge">Future[A]</code>, <code class="highlighter-rouge">Task[A]</code> or some other similar type.
For our testing framework, this poses a challenge:
If our properties call such asynchronous functions, the framework needs to know how to deal with a lot of <code class="highlighter-rouge">Future[Boolean]</code> values.
On the JVM, although not ideal, we could fall back to blocking on the result and proceed as usual.
On <a href="http://www.scala-js.org/">Scala.js</a>, this won’t fly, because you just can’t block in JavaScript.</p>

<p>Most general-purpose testing frameworks, like Specs2, have a <a href="https://etorreborre.github.io/specs2/guide/SPECS2-3.8.5/org.specs2.guide.Matchers.html">story about this</a>, enabling asynchronous checking of assertions.</p>

<p>In theory, it’s not a problem to support this in a property testing library.
But in practice, there are some complications:</p>

<ul>
  <li>Has the library been designed that way? If not, can we change it to support it?
This is a real problem: It took quite some time and some significant refactorings to support <code class="highlighter-rouge">Future</code>s in <a href="http://www.scalatest.org/user_guide/async_testing">ScalaTest</a>.</li>
  <li>Should random generators also return <code class="highlighter-rouge">Future</code> values?
We can easily imagine wanting to draw from a pool of inputs stemming from a database, or possibly to get better randomness from <a href="https://www.random.org/">random.org</a>.
(The latter is a joke.)</li>
  <li>What async type constructor should we support?
<a href="http://www.scala-lang.org/files/archive/api/2.11.8/#scala.concurrent.Future">The built-in one</a>?
<a href="https://monix.io/docs/2x/eval/task.html">Monix’ <code class="highlighter-rouge">Task</code></a>?
<a href="https://github.com/functional-streams-for-scala/fs2/blob/v0.9.1/core/shared/src/main/scala/fs2/Task.scala">fs2’s <code class="highlighter-rouge">Task</code></a>?
All of them?</li>
</ul>

<p>If in the first design decisions we had chosen exhaustive generators, this problem would be even tougher, because designing a correct effectful stream type (of all possible inputs) is not trivial.</p>

<p><strong>For this post, we’re assuming that we’re only interested in synchronous properties, or can always block.</strong>
However, I’d like to add, I’d probably try to incorporate async properties right from the start if I were to implement a testing library from scratch.</p>

<p>What about the existing libraries?</p>

<ul>
  <li>ScalaCheck itself does not support asynchronous properties.</li>
  <li>In SmallCheck, both <a href="https://hackage.haskell.org/package/smallcheck-1.1.1/docs/Test-SmallCheck-Series.html#t:Serial">generators</a> and <a href="https://hackage.haskell.org/package/smallcheck-1.1.1/docs/Test-SmallCheck.html#t:Property">properties</a> may be monadic.</li>
  <li>QuickCheck supports arbitrary I/O actions in a property via a function called <a href="https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Property.html#v:morallyDubiousIOProperty"><code class="highlighter-rouge">morallyDubiosIOProperty</code></a> (nowadays just <code class="highlighter-rouge">ioProperty</code>).
But there is also <a href="https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Monadic.html">more advanced support</a> for monadic testing.</li>
</ul>

<h2 id="the-fourth-design-decision">The fourth design decision</h2>

<p>Let’s summarize what we have so far:</p>

<ol>
  <li>randomly generated inputs</li>
  <li>… using a stateful primitive generator</li>
  <li>synchronous properties</li>
</ol>

<p>Now, I’d like to talk about how to “package” random generators.
Earlier, we’ve only seen random integer and floating-point numbers, but of course, we want something more complex, including custom data structures.
It is convenient to abstract over this and specify the concept of a <em>generator</em> for type <code class="highlighter-rouge">A</code>.
The idea is to make a generator for a type as “general” as possible and then provide combinators to compose them.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">trait</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Gen</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">int</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
      <span class="n">rnd</span><span class="o">.</span><span class="n">nextInt</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>An obvious combinator is a generator for tuples:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">zip</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">genT</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">genU</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[(</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">)]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[(</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">)]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span><span class="o">,</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=</span>
    <span class="o">(</span><span class="n">genT</span><span class="o">.</span><span class="n">generate</span><span class="o">(</span><span class="n">rnd</span><span class="o">),</span> <span class="n">genU</span><span class="o">.</span><span class="n">generate</span><span class="o">(</span><span class="n">rnd</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>But we still have a problem:
There is currently no way to talk about the <em>size</em> of the generated inputs.
Let’s say we want to check an expensive algorithm over lists, for example with a complexity of $\mathcal O(n^3)$ over lists.
A naive implemenation of a list generator would take a a random size, and then give you some generator for lists.
The problem arises at the use site: Whenver you want to change the size of the generated inputs, you need to change the expression constructing the generator.</p>

<p>But we’d like to do better here:</p>

<p><strong>For this post, there should be a way to specify a maximum size of generated values, together with a way to influence that size in the tests without having to modify the generators.</strong></p>

<p>Here’s how we can do that:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">trait</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"&lt;gen&gt;"</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Gen</span> <span class="o">{</span>

  <span class="k">val</span> <span class="n">int</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">range</span> <span class="k">=</span> <span class="n">size</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="n">rnd</span><span class="o">.</span><span class="n">nextInt</span><span class="o">(</span><span class="n">range</span><span class="o">)</span> <span class="o">-</span> <span class="n">size</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">list</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">genA</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">length</span> <span class="k">=</span> <span class="n">rnd</span><span class="o">.</span><span class="n">nextInt</span><span class="o">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
      <span class="nc">List</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="n">length</span><span class="o">)(</span><span class="n">genA</span><span class="o">.</span><span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>We can now check this (note that for the purpose of this post we’ll be using fixed seeds):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">printSample</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">genT</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">count</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">rnd</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">size</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">genT</span><span class="o">.</span><span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">printSample</span><span class="o">(</span><span class="nc">Gen</span><span class="o">.</span><span class="n">int</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
<span class="mi">2</span>
<span class="mi">6</span>
<span class="o">-</span><span class="mi">6</span>
<span class="o">-</span><span class="mi">8</span>
<span class="mi">1</span>
<span class="mi">4</span>
<span class="o">-</span><span class="mi">8</span>
<span class="mi">5</span>
<span class="o">-</span><span class="mi">4</span>
<span class="o">-</span><span class="mi">8</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">printSample</span><span class="o">(</span><span class="nc">Gen</span><span class="o">.</span><span class="n">int</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="mi">2</span>
<span class="o">-</span><span class="mi">1</span>
<span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">printSample</span><span class="o">(</span><span class="nc">Gen</span><span class="o">.</span><span class="n">list</span><span class="o">(</span><span class="nc">Gen</span><span class="o">.</span><span class="n">int</span><span class="o">),</span> <span class="mi">10</span><span class="o">)</span>
<span class="nc">List</span><span class="o">()</span>
<span class="nc">List</span><span class="o">(-</span><span class="mi">6</span><span class="o">,</span> <span class="o">-</span><span class="mi">8</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="o">-</span><span class="mi">8</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(-</span><span class="mi">8</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="o">-</span><span class="mi">9</span><span class="o">,</span> <span class="o">-</span><span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(-</span><span class="mi">8</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="o">-</span><span class="mi">8</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="o">-</span><span class="mi">7</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">10</span><span class="o">)</span>
<span class="nc">List</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">printSample</span><span class="o">(</span><span class="nc">Gen</span><span class="o">.</span><span class="n">list</span><span class="o">(</span><span class="nc">Gen</span><span class="o">.</span><span class="n">int</span><span class="o">),</span> <span class="mi">3</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</code></pre></div></div>

<p>That’s already pretty cool.
But there’s another hidden design decision here:
We’re using the same size on all sub-elements in the generated thing.
For example, in <code class="highlighter-rouge">Gen.list</code>, we’re just passing the size through to the child generator.</p>

<p>SmallCheck does that differently: The “size” is defined to be the total number of constructors in the generated value.
For integer numbers, the “number of constructors” is basically the number itself.
For example, the value <code class="highlighter-rouge">List(1, 2)</code> has size $2$ in our framework (length of the list), but size $1 + 2 + 2 = 5$ in SmallCheck (roughly: size of all elements plus length of list).</p>

<p>Of course, our design decision might mean that stuff grows too fast.
The explicit size parameter can be used to alleviate that, especially for writing recursive generators:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">recList</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">genT</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="o">{</span>
  <span class="c1">// extremely stupid implementation, don't use it
</span>  <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">rnd</span><span class="o">.</span><span class="n">nextInt</span><span class="o">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
      <span class="n">genT</span><span class="o">.</span><span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span> <span class="o">::</span> <span class="n">recList</span><span class="o">(</span><span class="n">genT</span><span class="o">).</span><span class="n">generate</span><span class="o">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="nc">Nil</span>
<span class="o">}</span>
<span class="c1">// recList: [T](genT: Gen[T])Gen[List[T]]
</span>
<span class="n">printSample</span><span class="o">(</span><span class="n">recList</span><span class="o">(</span><span class="nc">Gen</span><span class="o">.</span><span class="n">int</span><span class="o">),</span> <span class="mi">10</span><span class="o">)</span>
<span class="c1">// List()
// List(-6, 1, -6)
// List(-8, 8, 4, 7, 0, 5, -4)
// List(-8)
// List(9, -3, 4)
// List(1, 3, -7, -2, -3, 0, -3, 3)
// List()
// List(10, 5, -8, -4, -5, 4, -1)
// List(-5, 9, 7)
// List(-8)
</span></code></pre></div></div>

<p>We can also provide a combinator for this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">resize</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">genT</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">newSize</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
    <span class="n">genT</span><span class="o">.</span><span class="n">generate</span><span class="o">(</span><span class="n">newSize</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>That one is useful because in reality ScalaCheck’s <code class="highlighter-rouge">generate</code> method takes some more parameters than just the size.
Some readers might be reminded that this is just the reader monad and its <code class="highlighter-rouge">local</code> combinator in disguise.</p>

<h2 id="some-sugar">Some sugar</h2>

<p>In order to make these generators nicely composable, we can leverage <code class="highlighter-rouge">for</code> comprehensions.
We just need to implement <code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">flatMap</code> and <code class="highlighter-rouge">withFilter</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">trait</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>

  <span class="c1">// Generate a value and then apply a function to it
</span>  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span> <span class="o">=</span>
      <span class="n">f</span><span class="o">(</span><span class="n">self</span><span class="o">.</span><span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">))</span>
  <span class="o">}</span>

  <span class="c1">// Generate a value and then use it to produce a new generator
</span>  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span> <span class="o">=</span>
      <span class="n">f</span><span class="o">(</span><span class="n">self</span><span class="o">.</span><span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)).</span><span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="c1">// Repeatedly generate values until one passes the check
</span>  <span class="c1">// (We would usually call this `filter`, but Scala requires us to
</span>  <span class="c1">// call it `withFilter` in order to be used in `for` comprehensions)
</span>  <span class="k">def</span> <span class="n">withFilter</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">candidate</span> <span class="k">=</span> <span class="n">self</span><span class="o">.</span><span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">(</span><span class="n">candidate</span><span class="o">))</span>
        <span class="n">candidate</span>
      <span class="k">else</span> <span class="c1">// try again
</span>        <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"&lt;gen&gt;"</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Gen</span> <span class="o">{</span>

  <span class="c1">// unchanged from above
</span>
  <span class="k">val</span> <span class="n">int</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">range</span> <span class="k">=</span> <span class="n">size</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="n">rnd</span><span class="o">.</span><span class="n">nextInt</span><span class="o">(</span><span class="n">range</span><span class="o">)</span> <span class="o">-</span> <span class="n">size</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">list</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">genA</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">length</span> <span class="k">=</span> <span class="n">rnd</span><span class="o">.</span><span class="n">nextInt</span><span class="o">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
      <span class="nc">List</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="n">length</span><span class="o">)(</span><span class="n">genA</span><span class="o">.</span><span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>Look how simple composition is now:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Frac</span><span class="o">(</span><span class="n">numerator</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">denominator</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="c1">// defined class Frac
</span>
<span class="k">val</span> <span class="n">fracGen</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">Frac</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">num</span> <span class="k">&lt;-</span> <span class="nc">Gen</span><span class="o">.</span><span class="n">int</span>
    <span class="n">den</span> <span class="k">&lt;-</span> <span class="nc">Gen</span><span class="o">.</span><span class="n">int</span>
    <span class="k">if</span> <span class="n">den</span> <span class="o">!=</span> <span class="mi">0</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="nc">Frac</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">den</span><span class="o">)</span>
<span class="c1">// fracGen: Gen[Frac] = &lt;gen&gt;
</span>
<span class="n">printSample</span><span class="o">(</span><span class="n">fracGen</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
<span class="c1">// Frac(2,6)
// Frac(-6,-8)
// Frac(1,4)
// Frac(-8,5)
// Frac(-4,-8)
// Frac(-2,-8)
// Frac(4,6)
// Frac(1,4)
// Frac(0,-10)
// Frac(10,4)
</span></code></pre></div></div>

<p>And we can even read the construction nicely: “First draw a numerator, then draw a denominator, then check that the denominator is not zero, then construct a fraction.”
However, we need to be cautious with the filtering.
If you look closely at the implementation of <code class="highlighter-rouge">withFilter</code>, you can see that there is potential for an infinite loop.
For example, when you pass in the filter <code class="highlighter-rouge">_ =&gt; false</code>.
It will just keep generating values and then discard them.
How do existing frameworks alleviate this?</p>

<ul>
  <li>QuickCheck has two filter combinators: one that returns <code class="highlighter-rouge">Gen[A]</code> as above, and one that return <code class="highlighter-rouge">Gen[Option[A]]</code>.
The latter uses a number of tries and if they all fail, terminates and returns <code class="highlighter-rouge">None</code>.
The former uses the latter, but keeps increasing the size parameter.
Of course, this might not terminate.</li>
  <li>ScalaCheck’s <code class="highlighter-rouge">filter</code> method returns <code class="highlighter-rouge">Gen[A]</code>, but the possibility of failure is encoded in the return type of its equivalent of the <code class="highlighter-rouge">generate</code> method, which always returns <code class="highlighter-rouge">Option[T]</code>.
But there is also a combinator which retries until it finds a valid input, called <code class="highlighter-rouge">retryUntil</code>.</li>
</ul>

<p>As a side note: <code class="highlighter-rouge">Gen</code> as it is right now is <em>definitely not</em> a valid monad, because it internally relies on mutable state.
But in my opinion, it is still justified to offer the <code class="highlighter-rouge">map</code> and <code class="highlighter-rouge">flatMap</code> methods, but don’t give a <code class="highlighter-rouge">Monad</code> instance.
This prevents you from shoving <code class="highlighter-rouge">Gen</code> into functions which expect lawful monads.</p>

<p>It’s still tedious to having to construct these generators by hand.
Both QuickCheck and ScalaCheck introduce a thin layer atop generators, called <code class="highlighter-rouge">Arbitrary</code>.
This is just a type class which contains a generator, nothing more.
Here’s how it would look like in Scala:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Arbitrary</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">gen</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>

<span class="c1">// in practice we would put that into the companion object
//object Arbitrary {
</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">arbitraryInt</span><span class="k">:</span> <span class="kt">Arbitrary</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Arbitrary</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">gen</span> <span class="k">=</span> <span class="nc">Gen</span><span class="o">.</span><span class="n">int</span>
  <span class="o">}</span>

<span class="c1">//}
</span></code></pre></div></div>

<p>Based on this definition, ScalaCheck provides a lot of pre-defined instances for all sorts of types.
For your custom types, the idea is that you define a low-level generator and wrap it into an implicit <code class="highlighter-rouge">Arbitrary</code>.
Then, in your tests, you just use the implicitly provided generator, and avoid to drop down to constructing them manually.</p>

<p>The purpose of the additional layer is explained easily: It is common to have multiple <code class="highlighter-rouge">Gen[T]</code> for the same <code class="highlighter-rouge">T</code> depending on which context it is needed in.
But there should only be one <code class="highlighter-rouge">Arbitrary[T]</code> for each <code class="highlighter-rouge">T</code>.
For example, you might have <code class="highlighter-rouge">Gen[Int]</code> for positive and negative integers, but you only have a single <code class="highlighter-rouge">Arbitrary[Int]</code> which covers all integers.
You use the latter when you actually need to supply an integer to your property, and the former to construct more complex generators, like for <code class="highlighter-rouge">Frac</code> above.</p>

<h2 id="the-fifth-design-decision">The fifth design decision</h2>

<p>This is where everything really comes together.
We’re now looking at how to use <code class="highlighter-rouge">Gen</code> to implement the desired <code class="highlighter-rouge">forAll</code> function we’ve seen early in the introduction of the post, and how that is related to the <code class="highlighter-rouge">Prop</code> type I didn’t define.
I’ll readily admit that the following isn’t really a design decision per se, because we’ll be guided by the presence of type classes in Scala.
Still, one could reasonably structure this differently, and in fact, the design of the <code class="highlighter-rouge">Prop</code> type in e.g. QuickCheck is much more complex than what you’ll see.</p>

<p>The rest of this post will now depart from the way it’s done in ScalaCheck, although the ideas are still similar.
Instead, I’ll try to show a simplified version without introducing complications required to make it work nicely.</p>

<p>Let’s start with the concept of a <em>property.</em>
A property is something that we can <em>run</em> and which returns a <em>result</em>.
The result should ideally be something like a boolean: Either the property holds or it doesn’t.
But one of the main features of any property testing library is that it will return a counterexample for the inputs where the property doesn’t hold.
Hence, we need to store this counterexample in the failure case.
In practice, the result type would be much richer, with attached labels, reasons, expectations, counters, … and more diagnostic fields.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Result</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Success</span> <span class="k">extends</span> <span class="nc">Result</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">counterexample</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Result</span>

<span class="k">object</span> <span class="nc">Result</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">fromBoolean</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Result</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">b</span><span class="o">)</span>
      <span class="nc">Success</span>
    <span class="k">else</span>
      <span class="c1">// if it's false, it's false; no input has been produced,
</span>      <span class="c1">// so the counterexample is empty
</span>      <span class="nc">Failure</span><span class="o">(</span><span class="nc">Nil</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>You’ll note that I’ve used <code class="highlighter-rouge">List[String]</code> here, because in the end we only want to print the counterexample on the console.
ScalaCheck has a dedicated <code class="highlighter-rouge">Pretty</code> type for that.
We could do even more fancy things here if we wanted to, but let’s keep it simple.</p>

<p>Now we define the <code class="highlighter-rouge">Prop</code> type:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Prop</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">Result</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"&lt;prop&gt;"</span>
<span class="o">}</span>
</code></pre></div></div>

<p>What’s missing is a way to construct properties.
Sure, we could implement the trait manually in our tests, but that would be tedious.
Type classes to the rescue!
We call something <em>testable</em> if it can be converted to a <code class="highlighter-rouge">Prop</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Testable</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">asProp</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Prop</span>
<span class="o">}</span>

<span class="c1">// in practice we would put these into the companion object
//object Testable {
</span>
  <span class="c1">// Booleans can be trivially converted to a property:
</span>  <span class="c1">// They are already basically a `Result`, so no need
</span>  <span class="c1">// to run anything!
</span>  <span class="k">implicit</span> <span class="k">val</span> <span class="n">booleanIsTestable</span><span class="k">:</span> <span class="kt">Testable</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Testable</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">asProp</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Prop</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Prop</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">Result</span> <span class="o">=</span>
        <span class="nc">Result</span><span class="o">.</span><span class="n">fromBoolean</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="c1">// Props are already `Prop`s.
</span>  <span class="k">implicit</span> <span class="k">val</span> <span class="n">propIsTestable</span><span class="k">:</span> <span class="kt">Testable</span><span class="o">[</span><span class="kt">Prop</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Testable</span><span class="o">[</span><span class="kt">Prop</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">asProp</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Prop</span><span class="o">)</span><span class="k">:</span> <span class="kt">Prop</span> <span class="o">=</span> <span class="n">t</span>
  <span class="o">}</span>

<span class="c1">//}
</span></code></pre></div></div>

<p>Now we’re all set:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">forAll</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">O</span><span class="o">](</span><span class="n">prop</span><span class="k">:</span> <span class="kt">I</span> <span class="o">=&gt;</span> <span class="n">O</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">arbI</span><span class="k">:</span> <span class="kt">Arbitrary</span><span class="o">[</span><span class="kt">I</span><span class="o">],</span> <span class="n">testO</span><span class="k">:</span> <span class="kt">Testable</span><span class="o">[</span><span class="kt">O</span><span class="o">])</span><span class="k">:</span> <span class="kt">Prop</span> <span class="o">=</span>
  <span class="k">new</span> <span class="nc">Prop</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">Result</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">input</span> <span class="k">=</span> <span class="n">arbI</span><span class="o">.</span><span class="n">gen</span><span class="o">.</span><span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">subprop</span> <span class="k">=</span> <span class="n">testO</span><span class="o">.</span><span class="n">asProp</span><span class="o">(</span><span class="n">prop</span><span class="o">(</span><span class="n">input</span><span class="o">))</span>
      <span class="n">subprop</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Success</span> <span class="k">=&gt;</span>
          <span class="nc">Success</span>
        <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">counterexample</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="nc">Failure</span><span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="n">toString</span> <span class="o">::</span> <span class="n">counterexample</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Let’s unpack this step by step.</p>

<ol>
  <li>We’re taking a function from <code class="highlighter-rouge">I =&gt; O</code>.
This is supposed to be our parameterized property, for example <code class="highlighter-rouge">{ (x: Int) =&gt; x == x }</code>.
Because we abstracted over values that can be generated (<code class="highlighter-rouge">Arbitrary</code>) and things that can be tested (<code class="highlighter-rouge">Testable</code>), the input and output types are completely generic.
In the <code class="highlighter-rouge">implicit</code> block, we’re taking the instructions of how to fit everything together.</li>
  <li>We’re constructing a <code class="highlighter-rouge">Prop</code>; that is, a thing that we can run and that produces a boolean-ish <code class="highlighter-rouge">Result</code>.</li>
  <li>To run the property, we need to construct a random input.
We can use the <code class="highlighter-rouge">Gen[I]</code> which we get from the <code class="highlighter-rouge">Arbitrary[I]</code>.</li>
  <li>We pass that <code class="highlighter-rouge">I</code> into the parameterized property.
To stick with the example, we evaluate the anonymous function <code class="highlighter-rouge">{ (x: Int) =&gt; x == x }</code> at input <code class="highlighter-rouge">5</code>, and obtain <code class="highlighter-rouge">true</code>.</li>
  <li>We convert the result to a <code class="highlighter-rouge">Prop</code> again.
This allows us to recursively nest <code class="highlighter-rouge">forAll</code>s, for example when we need two inputs.</li>
  <li>We run the resulting property and check if it fails.
If it does, we prepend the generated input to the counterexample.
In the nested scenario, this allows us to see all generated inputs and the order in which we sticked them into the property.</li>
</ol>

<p>At this point we should look at an example.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">propReflexivity</span> <span class="k">=</span>
  <span class="n">forAll</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">x</span> <span class="o">==</span> <span class="n">x</span>
  <span class="o">}</span>
<span class="c1">// propReflexivity: Prop = &lt;prop&gt;
</span></code></pre></div></div>

<p>Cool, but how do we run this?</p>

<p>Remember that our tool is supposed to evaluate a property on multiple inputs.
All these evaluations will produce a <code class="highlighter-rouge">Result</code>.
Hence, we need to merge those together into a single result.
We’ll also define a convenient function that runs a property multiple times on different sizes:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">merge</span><span class="o">(</span><span class="n">rs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Result</span><span class="o">])</span><span class="k">:</span> <span class="kt">Result</span> <span class="o">=</span>
  <span class="n">rs</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="nc">Success</span><span class="k">:</span> <span class="kt">Result</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">cs</span><span class="o">),</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">cs</span><span class="o">)</span>
    <span class="k">case</span> <span class="o">(</span><span class="nc">Success</span><span class="o">,</span> <span class="nc">Success</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Success</span>
    <span class="k">case</span> <span class="o">(</span><span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">cs</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">cs</span><span class="o">)</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="n">check</span><span class="o">[</span><span class="kt">P</span><span class="o">](</span><span class="n">prop</span><span class="k">:</span> <span class="kt">P</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">testP</span><span class="k">:</span> <span class="kt">Testable</span><span class="o">[</span><span class="kt">P</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">rnd</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">rs</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">size</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">100</span><span class="o">)</span>
    <span class="k">yield</span> <span class="n">testP</span><span class="o">.</span><span class="n">asProp</span><span class="o">(</span><span class="n">prop</span><span class="o">).</span><span class="n">run</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span>
  <span class="n">merge</span><span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="n">toList</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Success</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"✓ Property successfully checked"</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">counterexample</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">pretty</span> <span class="k">=</span> <span class="n">counterexample</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">"("</span><span class="o">,</span> <span class="s">", "</span><span class="o">,</span> <span class="s">")"</span><span class="o">)</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"✗ Property failed with counterexample: $pretty"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>What is happening here?</p>

<ol>
  <li>The <code class="highlighter-rouge">merge</code> function takes a list of <code class="highlighter-rouge">Result</code>s and returns the first <code class="highlighter-rouge">Failure</code>, if it exists.
Otherwise it returns <code class="highlighter-rouge">Success</code>.
In case there are multiple <code class="highlighter-rouge">Failure</code>s, it doesn’t care and just discards the later ones.</li>
  <li>The <code class="highlighter-rouge">check</code> function initializes a fresh random generator.</li>
  <li>We have fixed the maximum size to 100 and will run the passed property with each size from 0 to 100.
This ensures that we get a nice coverage of various input sizes.
An obvious optimisation here would be to stop after the first failure, instead of merging the results in a subsequent step.</li>
  <li>In case there’s a failure, we just print the counterexample.</li>
</ol>

<p>Let’s check our property!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">check</span><span class="o">(</span><span class="n">propReflexivity</span><span class="o">)</span>
<span class="o">✓</span> <span class="nc">Property</span> <span class="n">successfully</span> <span class="n">checked</span>
</code></pre></div></div>

<p>… and how about something wrong?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">check</span><span class="o">(</span><span class="n">forAll</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
     <span class="o">|</span>   <span class="n">x</span> <span class="o">&gt;</span> <span class="n">x</span>
     <span class="o">|</span> <span class="o">})</span>
<span class="o">✗</span> <span class="nc">Property</span> <span class="n">failed</span> <span class="k">with</span> <span class="n">counterexample</span><span class="k">:</span> <span class="o">(</span><span class="err">0</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="some-more-sugar">Some more sugar</h2>

<p>Okay, we’re almost done.
The only tedious thing that remains is that we have to use the <code class="highlighter-rouge">forAll</code> combinator, especially in the nested case.
It would be great if we could just use <code class="highlighter-rouge">check</code> and pass it a function.
But since we’ve used type classes for everything, we’re in luck!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">funTestable</span><span class="o">[</span><span class="kt">I</span> <span class="kt">:</span> <span class="kt">Arbitrary</span>, <span class="kt">O</span> <span class="kt">:</span> <span class="kt">Testable</span><span class="o">]</span><span class="k">:</span> <span class="kt">Testable</span><span class="o">[</span><span class="kt">I</span> <span class="k">=&gt;</span> <span class="kt">O</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Testable</span><span class="o">[</span><span class="kt">I</span> <span class="k">=&gt;</span> <span class="kt">O</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">asProp</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">I</span> <span class="o">=&gt;</span> <span class="n">O</span><span class="o">)</span><span class="k">:</span> <span class="kt">Prop</span> <span class="o">=</span>
    <span class="c1">// wait for it ...
</span>    <span class="c1">// ...
</span>    <span class="c1">// ...
</span>    <span class="c1">// it's really simple ...
</span>    <span class="n">forAll</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now we can check our functions even easier!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">check</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
     <span class="o">|</span>   <span class="n">x</span> <span class="o">==</span> <span class="n">x</span>
     <span class="o">|</span> <span class="o">}</span>
<span class="o">✓</span> <span class="nc">Property</span> <span class="n">successfully</span> <span class="n">checked</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">check</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
     <span class="o">|</span>   <span class="n">x</span> <span class="o">&gt;</span> <span class="n">x</span>
     <span class="o">|</span> <span class="o">}</span>
<span class="o">✗</span> <span class="nc">Property</span> <span class="n">failed</span> <span class="k">with</span> <span class="n">counterexample</span><span class="k">:</span> <span class="o">(</span><span class="err">0</span><span class="o">)</span>

<span class="kt">scala&gt;</span> <span class="kt">check</span> <span class="o">{</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="kt">y:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">=&gt;</span>
     <span class="o">|</span>   <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">==</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
     <span class="o">|</span> <span class="o">}</span>
<span class="o">✓</span> <span class="nc">Property</span> <span class="n">successfully</span> <span class="n">checked</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">check</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
     <span class="o">|</span>   <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">==</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
     <span class="o">|</span> <span class="o">}</span>
<span class="o">✗</span> <span class="nc">Property</span> <span class="n">failed</span> <span class="k">with</span> <span class="n">counterexample</span><span class="k">:</span> <span class="o">(</span><span class="err">0</span><span class="o">,</span> <span class="err">1</span><span class="o">)</span>
</code></pre></div></div>

<p>Now, if you look closely, you can basically get rid of the <code class="highlighter-rouge">Prop</code> class and define it as</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Prop</span> <span class="o">=</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">Result</span><span class="o">]</span>
</code></pre></div></div>

<p>If you think about this for a moment, it makes sense: A “property” is really just a thing which feeds on randomness and produces a result.
The only thing left is to define a driver which runs a couple of iterations and gathers the results; in our implementation, that’s the <code class="highlighter-rouge">check</code> function.
I encourage you to spell out the other functions (e.g. <code class="highlighter-rouge">forAll</code>), and you will notice that our <code class="highlighter-rouge">Prop</code> trait is indeed isomorphic to <code class="highlighter-rouge">Gen[Result]</code>.
In practice, QuickCheck uses such a representation (although with some more contraptions).</p>

<h2 id="summary">Summary</h2>

<p>It turns out that it’s not that hard to write a small property-testing library.
I’m going to stop here with the implementation, although there are still some things to explore:</p>

<ul>
  <li>How to <a href="https://github.com/alexarchambault/scalacheck-shapeless">get rid of the boilerplate</a> to generate “boring” data structures?</li>
  <li>How to <a href="https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Arbitrary.html#t:CoArbitrary">generate functions</a>?</li>
  <li>How to improve usability?</li>
  <li>How to <a href="https://github.com/typelevel/discipline">bundle up a bunch of properties</a>?</li>
  <li>How to <a href="https://github.com/rickynils/scalacheck/blob/1.13.2/doc/UserGuide.md#test-case-minimisation">show useful counterexamples</a>?</li>
  <li>How to test <a href="https://github.com/rickynils/scalacheck/blob/1.13.2/doc/UserGuide.md#properties">conditional properties</a>?</li>
  <li>How to test the library itself?</li>
  <li>How to make sure that your generators produce reasonable values?</li>
  <li>How to make sure that your generators <a href="https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck.html#v:label">cover a wide range of values</a>?</li>
  <li>How to test <a href="https://github.com/larsrh/polycheck">polymorphic properties</a>?</li>
  <li>…</li>
</ul>

<p>Finally, I’d like to note that there are many more libraries out there than I’ve mentioned here, some of which depart more, some less, from the original Haskell implementation.
They even exist for not-functional languages, e.g. <a href="http://www.javaslang.io/javaslang-docs/#_property_checking">Javaslang</a> for Java or <a href="http://hypothesis.works/">Hypothesis</a> for Python.</p>

<p><em>Correction: In a previous version of this post, I incorrectly stated that ScalaCheck uses a mutable random generator. This is only true up to ScalaCheck 1.12.x. I have updated that section in the post.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Mon, 17 Oct 2016 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2016/10/17/minicheck.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/10/17/minicheck.html</guid>
      </item>
    
      <item>
        <title>Subtype type classes don't work</title>
        
          <dc:creator>adelbertc</dc:creator>
                
        <description><![CDATA[<p><em>Update: A comprehensive version of this blog post was published at the
<a href="https://conf.researchr.org/track/scala-2017/scala-2017-papers&lt;Paste&gt;">2017 Scala Symposium</a> and is available <a href="http://www.sigplan.org/OpenTOC/scala17.html">for free</a>
through the ACM OpenTOC service. The corresponding talk can be found
<a href="https://www.youtube.com/watch?v=BGoTXO1V0HM&amp;list=PL6KWJEIH5ulcNeQ92iKFN2k-UIV9QHExH&amp;index=3">here</a>.</em></p>

<p>The common encoding of type classes in Scala relies on subtyping. This singular
fact gives us a certain cleanliness in the code, but at what cost?</p>

<h2 id="problem">Problem</h2>

<p>Consider the following hierarchy of type classes. A similar hierarchy can be
found in both <a href="https://github.com/typelevel/cats" title="Typelevel Cats">Cats</a> and <a href="https://github.com/scalaz/scalaz/tree/series/7.3.x" title="Scalaz 7">Scalaz 7</a>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>

<span class="nc">trait</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="k">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

<span class="k">trait</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

<span class="k">trait</span> <span class="nc">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
</code></pre></div></div>

<p>For purposes of demonstration I will be using Cats for the rest of this post,
but the same arguments apply to Scalaz 7.</p>

<p>We will also assume that there is syntax accompanying this hierarchy, allowing
us to call methods like <code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">flatMap</code>, and <code class="highlighter-rouge">traverse</code> directly on some
<code class="highlighter-rouge">F[A]</code>, provided <code class="highlighter-rouge">F</code> has the appropriate type class instances (<code class="highlighter-rouge">Functor</code>,
<code class="highlighter-rouge">Monad</code>, and <code class="highlighter-rouge">Traverse</code>, respectively).</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats._</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>
</code></pre></div></div>

<p>One important consequence is we can use for comprehensions in methods
parameterized over some <code class="highlighter-rouge">Monad</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">a</span> <span class="k">&lt;-</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">pure</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
  <span class="n">b</span> <span class="k">&lt;-</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">pure</span><span class="o">(</span><span class="mi">20</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</code></pre></div></div>

<p>Notice that due to how for comprehensions <a href="http://docs.scala-lang.org/tutorials/FAQ/yield.html" title="How does yield work?">desugar</a>, there is also
a call to <code class="highlighter-rouge">map</code> in there. Since our type class hierarchy is encoded via
subtyping Scala knows a <code class="highlighter-rouge">Monad[F]</code> implies a <code class="highlighter-rouge">Functor[F]</code>, so all is well.
Or is it?</p>

<p>Consider a case where we want to abstract over a data type that has
both <code class="highlighter-rouge">Monad</code> and <code class="highlighter-rouge">Traverse</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Ignore the fact we're not even using `Traverse` - we can't even call `map`!
</span><span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">pure</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">identity</span><span class="o">)</span>
<span class="c1">// &lt;console&gt;:19: error: value map is not a member of type parameter F[Int]
//        def foo[F[_]: Monad: Traverse]: F[Int] = Monad[F].pure(10).map(identity)
//                                                                   ^
// &lt;console&gt;:19: error: missing argument list for method identity in object Predef
// Unapplied methods are only converted to functions when a function type is expected.
// You can make this conversion explicit by writing `identity _` or `identity(_)` instead of `identity`.
//        def foo[F[_]: Monad: Traverse]: F[Int] = Monad[F].pure(10).map(identity)
//                                                                       ^
</span></code></pre></div></div>

<p>We’re already in trouble. In order to call <code class="highlighter-rouge">map</code> we need <code class="highlighter-rouge">F</code> to have a
<code class="highlighter-rouge">Functor</code> instance, which it does via <code class="highlighter-rouge">Monad</code> as before.. but now also via
<code class="highlighter-rouge">Traverse</code>. It is for precisely this reason that this does not work. Because
our encoding of type classes uses subtyping, a <code class="highlighter-rouge">Monad[F]</code> <strong>is a</strong> <code class="highlighter-rouge">Functor[F]</code>.
Similarly, a <code class="highlighter-rouge">Traverse[F]</code> <strong>is a</strong> <code class="highlighter-rouge">Functor[F]</code>. When implicit resolution
attempts to find a <code class="highlighter-rouge">Functor[F]</code>, it can’t decide between <code class="highlighter-rouge">Monad[F]</code>’s or
<code class="highlighter-rouge">Traverse[F]</code>’s and bails out. Even though the instances may be,
<a href="https://www.youtube.com/watch?v=hIZxTQP1ifo" title="Edward Kmett - Type Classes vs. the World">and arguably should be</a>, the same, the compiler has no way of
knowing that.</p>

<p>This problem generalizes to anytime the compiler decides an implicit is ambiguous,
such as method calls.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// The fact we don't actually use `Functor` here is irrelevant.
</span><span class="k">def</span> <span class="n">bar</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative:</span> <span class="kt">Functor</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">pure</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">callBar</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">bar</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="c1">// &lt;console&gt;:19: error: ambiguous implicit values:
//  both value evidence$2 of type cats.Traverse[F]
//  and value evidence$1 of type cats.Monad[F]
//  match expected type cats.Functor[F]
//        def callBar[F[_]: Monad: Traverse]: F[Int] = bar[F]
//                                                        ^
</span></code></pre></div></div>

<p>What do we do? For <code class="highlighter-rouge">map</code> it is easy enough to arbitrarily pick one
of the instances and call <code class="highlighter-rouge">map</code> on that. For function calls you
can thread the implicit through explicitly.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">map</span><span class="o">(</span><span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">pure</span><span class="o">(</span><span class="mi">10</span><span class="o">))(</span><span class="n">identity</span><span class="o">)</span>

<span class="k">def</span> <span class="n">callBar</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">bar</span><span class="o">(</span><span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span>
                                       <span class="c1">// or bar(Monad[F], Traverse[F])
</span></code></pre></div></div>

<p>For <code class="highlighter-rouge">foo</code> it’s not <em>too</em> terrible. For <code class="highlighter-rouge">bar</code> though we are
already starting to see it get unwieldy. While we could have passed in
<code class="highlighter-rouge">Monad[F]</code> or <code class="highlighter-rouge">Traverse[F]</code> for the second parameter which corresponds
to <code class="highlighter-rouge">bar</code>’s <code class="highlighter-rouge">Functor[F]</code> constraint, we can only pass in <code class="highlighter-rouge">Monad[F]</code> for
the first parameter to satisfy <code class="highlighter-rouge">Applicative[F]</code>. Because implicit resolution
can’t disambiguate the <code class="highlighter-rouge">Functor[F]</code> by itself we’ve had to pass it in
explicitly, but by doing so we also have to pass in everything else explicitly!
We become the implicit resolver. And this is with just two constraints, what
if we had three, four, five?</p>

<p>And the trouble doesn’t end there. We asked for a <code class="highlighter-rouge">Monad</code> so let’s try using
a for comprehension.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">a</span> <span class="k">&lt;-</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">pure</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
  <span class="n">b</span> <span class="k">&lt;-</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">pure</span><span class="o">(</span><span class="mi">20</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="c1">// &lt;console&gt;:21: error: value map is not a member of type parameter F[Int]
//          b &lt;- Monad[F].pure(20)
//                            ^
</span></code></pre></div></div>

<p>This is also broken! Because of how <a href="http://docs.scala-lang.org/tutorials/FAQ/yield.html" title="How does yield work?">for comprehensions</a> desugar, a
<code class="highlighter-rouge">map</code> call is inevitable which leads to the for comprehension breaking down.
This drastically reduces the ergonomics of doing anything monadic.</p>

<p>As with <code class="highlighter-rouge">map</code> we could call <code class="highlighter-rouge">flatMap</code> on <code class="highlighter-rouge">Monad</code> directly, but this quickly
becomes cumbersome.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">M</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
  <span class="n">M</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">M</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="mi">10</span><span class="o">))</span> <span class="o">{</span> <span class="n">a</span> <span class="k">=&gt;</span>
    <span class="n">M</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">M</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="mi">20</span><span class="o">))</span> <span class="o">{</span> <span class="n">b</span> <span class="k">=&gt;</span>
      <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>These same problems arise if you ask for two or more type classes that share a
common superclass. Some examples of this:</p>

<ul>
  <li>Two or more of Monad{Error, Plus, Reader, State, Writer} (ambiguous Monad)
    <ul>
      <li>This prevents ergonomic use of <a href="https://hackage.haskell.org/package/mtl" title="mtl: Monad classes, using functional dependencies">“MTL-style”</a></li>
    </ul>
  </li>
  <li>MonadPlus + Monad (ambiguous Monad)</li>
  <li>Alternative + Traverse (ambiguous Functor)</li>
  <li>MonadRec + MonadPlus (ambiguous Monad)</li>
</ul>

<p>This suggests every type class have only <strong>one</strong> subclass.
That is quite limiting as is readily demonstrated by the extremely useful
<code class="highlighter-rouge">Applicative</code> and <code class="highlighter-rouge">Traverse</code> type classes. What do we do?</p>

<h2 id="solution-">Solution (?)</h2>

<p>This more or less remains an open problem in Scala. There has been
an interesting alternative prototyped in <a href="https://github.com/aloiscochard/scato" title="Scato">scato</a>, now making its way to
<a href="https://github.com/scalaz/scalaz/tree/series/8.0.x" title="Scalaz 8">Scalaz 8</a>, that has received some positive feedback. The gist of the
encoding completely throws out the notion of subtyping, encoding the hierarchy
via members instead.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">functor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">map2</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span>
<span class="o">}</span>

<span class="c1">// Definitions elided for space
</span><span class="k">trait</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span> <span class="k">def</span> <span class="n">applicative</span><span class="k">:</span> <span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">}</span>

<span class="k">trait</span> <span class="nc">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span> <span class="k">def</span> <span class="n">functor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">}</span>
</code></pre></div></div>

<p>Because there is no relation between the type classes, there is no
danger of implicit ambiguity. However, for that very reason, having a
<code class="highlighter-rouge">Monad[F]</code> no longer implies having a <code class="highlighter-rouge">Functor[F]</code>. Not currently
anyway. What we can do is use implicit conversions to re-encode the
hierarchy.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">applicativeIsFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">]</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="n">functor</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="n">traverseIsFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="n">functor</span>
</code></pre></div></div>

<p>But now we’re back to square one.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Syntax for Functor
</span><span class="k">implicit</span> <span class="k">class</span> <span class="nc">FunctorOps</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="n">pure</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">identity</span><span class="o">)</span>
<span class="c1">// &lt;console&gt;:18: error: value map is not a member of type parameter F[Int]
//          implicitly[Applicative[F]].pure(10).map(identity)
//                                              ^
// &lt;console&gt;:18: error: missing argument list for method identity in object Predef
// Unapplied methods are only converted to functions when a function type is expected.
// You can make this conversion explicit by writing `identity _` or `identity(_)` instead of `identity`.
//          implicitly[Applicative[F]].pure(10).map(identity)
//                                                  ^
</span></code></pre></div></div>

<p>Since both implicits have equal priority, the compiler
doesn’t know which one to pick. <strong>However</strong>, Scala has mechanisms for
<a href="http://eed3si9n.com/revisiting-implicits-without-import-tax" title="revisiting implicits without import tax">prioritizing implicits</a> which solves the problem.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Prioritized</span> <span class="o">{</span> <span class="c1">// needed for tut, irrelevant to demonstration
</span>  <span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="o">}</span>

  <span class="c1">// Prioritize implicit conversions - Functor only for brevity
</span>  <span class="k">trait</span> <span class="nc">FunctorConversions1</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">applicativeIsFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">]</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
      <span class="n">implicitly</span><span class="o">[</span><span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="n">functor</span>
  <span class="o">}</span>

  <span class="k">trait</span> <span class="nc">FunctorConversions0</span> <span class="k">extends</span> <span class="nc">FunctorConversions1</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">def</span> <span class="n">traverseIsFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
      <span class="n">implicitly</span><span class="o">[</span><span class="kt">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="n">functor</span>
  <span class="o">}</span>

  <span class="k">object</span> <span class="nc">Functor</span> <span class="k">extends</span> <span class="nc">FunctorConversions0</span>

  <span class="k">trait</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">functor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

    <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
    <span class="k">def</span> <span class="n">map2</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span>
  <span class="o">}</span>

  <span class="c1">// Definition elided for space
</span>  <span class="k">trait</span> <span class="nc">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span> <span class="k">def</span> <span class="n">functor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">}</span>

  <span class="c1">// Syntax for Functor
</span>  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">FunctorOps</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">implicitly</span><span class="o">[</span><span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span> <span class="c1">// we have Applicative
</span>    <span class="n">implicitly</span><span class="o">[</span><span class="kt">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span>    <span class="c1">// we have Traverse
</span>    <span class="n">implicitly</span><span class="o">[</span><span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span>     <span class="c1">// we also have Functor!
</span>
    <span class="c1">// and we have syntax!
</span>    <span class="n">implicitly</span><span class="o">[</span><span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="n">pure</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">identity</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Because implicit resolution treats implicits in subtypes with higher priority,
we can organize conversions appropriately to prevent ambiguity. Here this means
that <code class="highlighter-rouge">applicativeIsFunctor</code> has lower priority than <code class="highlighter-rouge">traverseIsFunctor</code>, so
when both <code class="highlighter-rouge">Applicative</code> and <code class="highlighter-rouge">Traverse</code> instances are in scope and the compiler
is looking for a <code class="highlighter-rouge">Functor</code>, <code class="highlighter-rouge">traverseIsFunctor</code> wins.</p>

<p>One thing to note is that we’ve baked the implicit hierarchy into <code class="highlighter-rouge">Functor</code>
itself - in general this means all superclasses are aware of their subclasses.
This is convenient from a usability perspective as companion objects are
considered during implicit resolution, but from a modularity perspective is
strange and in this case would prevent extensions to the hierarchy from external
sources. This can be solved by removing the hierarchy from the superclasses
(removing <code class="highlighter-rouge">Functor</code>’s <code class="highlighter-rouge">extends FunctorConversions0</code>), but comes at
the cost of needing an import at use sites to bring the implicits into scope.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">functor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">map2</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span> <span class="k">def</span> <span class="n">functor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">}</span>

<span class="k">implicit</span> <span class="k">class</span> <span class="nc">FunctorOps</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// Separate from type class definitions
</span>
<span class="k">trait</span> <span class="nc">FunctorConversions1</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">applicativeIsFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">]</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">implicitly</span><span class="o">[</span><span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="n">functor</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">FunctorConversions0</span> <span class="k">extends</span> <span class="nc">FunctorConversions1</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">traverseIsFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">implicitly</span><span class="o">[</span><span class="kt">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="n">functor</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Prelude</span> <span class="k">extends</span> <span class="nc">FunctorConversions0</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Need this import to get implicit conversions in scope
</span><span class="k">import</span> <span class="nn">Prelude._</span>

<span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span>

  <span class="n">implicitly</span><span class="o">[</span><span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="n">pure</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">identity</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Prelude</code> could be provided by the base library, but external libraries
with their own type classes can still extend the hierarchy and provide
their own <code class="highlighter-rouge">Prelude</code>.</p>

<p>A more developed form can be seen in the <a href="https://github.com/scalaz/scalaz/blob/611d69f6b2bff3500181d0338dec9d6143d386ad/base/src/main/scala/BaseHierarchy.scala" title="Scalaz 8 base hierarchy">BaseHierarchy</a> of Scalaz 8.</p>

<p>Do we win? I’m not sure. This encoding is certainly more cumbersome than what
we started with, but solves the problems we ran into.</p>

<h2 id="compromise">Compromise?</h2>

<p>Another thing we can try is to make some compromise of the two. We can
continue to use subtyping for a blessed subset of the hierarchy, and use
members for any branching type class.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">class</span> <span class="nc">FunctorOps</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">map2</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

<span class="k">trait</span> <span class="nc">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span> <span class="k">def</span> <span class="n">functor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">}</span>

<span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative:</span> <span class="kt">Traverse</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="n">pure</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">identity</span><span class="o">)</span>
</code></pre></div></div>

<p>This works, but is even messier than the alternatives. We have to
decide which type classes get to live in the subtype hierarchy and which are
doomed (blessed?) to express the relationship with members. But maybe the
pros outweigh the cons. Pull requests with this change have been filed for
<a href="https://github.com/typelevel/cats/pull/1379" title="MTL fix for Cats">Cats</a> and <a href="https://github.com/scalaz/scalaz/pull/1262" title="MTL fix for Scalaz">Scalaz 7.3</a>.</p>

<p>I’m not convinced that the story is over though. Maybe there’s another solution
yet to be discovered.</p>

<p>For further reading, there are open tickets for both <a href="https://github.com/typelevel/cats/issues/1210" title="Better accommodate MTL style">Cats</a> and
<a href="https://github.com/scalaz/scalaz/issues/1110" title="MTL-style doesn't seem to work in Scala">Scalaz 7</a> documenting the subtyping problem. A discussion around
the Scato encoding for Scalaz 8 can be found <a href="https://github.com/scalaz/scalaz/issues/1084" title="[scalaz8] Subtyping-free encoding for typeclasses">here</a>.</p>

<p><em>This article was tested with Scala 2.11.8 and Cats 0.7.2 using <a href="https://github.com/tpolecat/tut" title="tut: doc/tutorial generator for scala">tut</a>.</em></p>

<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Fri, 30 Sep 2016 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2016/09/30/subtype-typeclasses.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/09/30/subtype-typeclasses.html</guid>
      </item>
    
      <item>
        <title>It's programs all the way down</title>
        
          <dc:creator>adelbertc</dc:creator>
                
        <description><![CDATA[<p><em>This is the first of a series of articles on “Monadic EDSLs in Scala.”</em></p>

<p>Embedded domain specific languages (EDSLs) are a powerful tool for
abstracting complexities such as effects and business logic from our
programs. Instead of mixing ad-hoc error handling, database access, and web
calls through our code, we isolate each domain into a little language. These
little languages can then be used to write “mini-programs” describing, for
example, how to create a web page for a user.</p>

<p>Our program then becomes a composition of mini-programs, and running our
program becomes interpreting these mini-programs into actions. This is
analogous to running an interpreter, itself a program, which turns code
into actions.</p>

<p>The following illustrates what an EDSL might look like in Scala.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// An embedded program for fetching data for a user
</span><span class="k">def</span> <span class="n">process</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">UserId</span><span class="o">)</span><span class="k">:</span> <span class="kt">Program</span><span class="o">[</span><span class="kt">Page</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">bio</span>  <span class="k">&lt;-</span> <span class="n">getBio</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
  <span class="n">feed</span> <span class="k">&lt;-</span> <span class="n">getFeed</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
  <span class="n">page</span> <span class="k">&lt;-</span> <span class="n">createPage</span><span class="o">(</span><span class="n">bio</span><span class="o">,</span> <span class="n">feed</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">page</span>

<span class="k">def</span> <span class="n">interpretProgram</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">page</span><span class="k">:</span> <span class="kt">Program</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">page</span><span class="o">.</span><span class="n">interpret</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">GetBio</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>            <span class="k">=&gt;</span> <span class="o">...</span>
  <span class="k">case</span> <span class="nc">GetFeed</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>           <span class="k">=&gt;</span> <span class="o">...</span>
  <span class="k">case</span> <span class="nc">CreatePage</span><span class="o">(</span><span class="n">bio</span><span class="o">,</span> <span class="n">feed</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Here <code class="highlighter-rouge">process</code> defines a program in our embedded language.
No action has actually been performed yet, that happens when it gets
interpreted by <code class="highlighter-rouge">interpretProgram</code> and run at runtime.</p>

<p>In many situations a program in one EDSL is translated into another EDSL,
much like a compiler (again another program).</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Translate each term of the program into a database call
</span><span class="k">def</span> <span class="n">compile</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">program</span><span class="k">:</span> <span class="kt">Program</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Database</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">program</span><span class="o">.</span><span class="n">interpret</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">GetBio</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>            <span class="k">=&gt;</span> <span class="o">...</span>
  <span class="k">case</span> <span class="nc">GetFeed</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>           <span class="k">=&gt;</span> <span class="o">...</span>
  <span class="k">case</span> <span class="nc">CreatePage</span><span class="o">(</span><span class="n">bio</span><span class="o">,</span> <span class="n">feed</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">interpretDatabase</span><span class="o">(</span><span class="n">db</span><span class="k">:</span> <span class="kt">Database</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">db</span><span class="o">.</span><span class="n">interpret</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div></div>

<p>Sometimes you can even optimize programs in an EDSL, much like an optimizing
compiler. In the above example, <code class="highlighter-rouge">interpretDatabase</code> could deduplicate identical
requests and batch requests to the same table.</p>

<p>In this series of articles we will explore a couple approaches to embedding
such DSLs in Scala. These techniques will be evaluated against the following
axes:</p>

<ul>
  <li>
    <p>Abstraction: Separation of <strong>structure</strong> from <strong>interpretation</strong>. Programs
describe only the structure of a computation, to be interpreted later on.
A common use case is to have a live interpreter that queries databases and
API endpoints and a test interpreter that works with in-memory stores.</p>
  </li>
  <li>
    <p>Composition: Given two or more EDSLs, how simple is it to compose them?
Given EDSLs for database access and RPC, can we query for data and send
it over the wire while maintaining the abstraction requirement?</p>
  </li>
  <li>
    <p>Performance: At the end of the day we must run our programs and therefore
interpret our mini-programs. How EDSLs are encoded will affect
how they perform and therefore affect any downstream consumers of our
programs, be it other programs or end users.</p>
  </li>
</ul>

<p>In the <a href="/blog/2016/10/26/edsls-part-2.html">next post</a> we’ll take a look
at the first of these approaches.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 21 Sep 2016 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2016/09/21/edsls-part-1.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/09/21/edsls-part-1.html</guid>
      </item>
    
      <item>
        <title>Choosing variance for a phantom type</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>When you use a type parameter to abstract over actual data in your
ADT, there is typically only one
<a href="/blog/2016/02/04/variance-and-functors.html">variance</a> that makes
sense, if you choose to incorporate subtyping into your designs at
all. This is
<a href="/blog/2014/03/09/liskov_lifting.html#parametrically-sound-covariance">the natural, “parametrically sound” variance</a>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">MyModel</span><span class="o">[</span><span class="kt">P</span>, <span class="kt">I</span>, <span class="kt">-T</span>, <span class="kt">+V</span><span class="o">]</span>

<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Running</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">T</span>, <span class="kt">V</span><span class="o">](</span>
  <span class="n">run</span><span class="k">:</span> <span class="o">(</span><span class="kt">I</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">V</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">MyModel</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">I</span>, <span class="kt">T</span>, <span class="kt">V</span><span class="o">]</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Inject</span><span class="o">[</span><span class="kt">I</span><span class="o">](</span>
  <span class="n">config</span><span class="k">:</span> <span class="kt">I</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">MyModel</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">I</span>, <span class="kt">Any</span>, <span class="kt">Nothing</span><span class="o">]</span>
</code></pre></div></div>

<p>There are only four interesting possibilities, each of which is
illustrated above.</p>

<ol>
  <li><code class="highlighter-rouge">V</code> occurs in only covariant positions, so can be marked covariant.</li>
  <li><code class="highlighter-rouge">T</code> occurs in only contravariant positions, so can be marked
contravariant.</li>
  <li><code class="highlighter-rouge">I</code> occurs in a pattern that meets neither of standards 1 and 2, so
may only be marked invariant, while still making sense.</li>
  <li><code class="highlighter-rouge">P</code> meets <em>both</em> standards 1 and 2, so…now what?</li>
</ol>

<p>The fourth case is interesting to me, firstly, because the design of
variance in Scala has not accounted for it; it is “phantom”,
<a href="/blog/2016/02/04/variance-and-functors.html#one-more-thing">the missing fourth variance</a>.
I like to write it as I did in
<a href="https://failex.blogspot.com/2016/09/the-missing-diamond-of-scala-variance.html">“The missing diamond of Scala variance”</a>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">MyModel</span><span class="o">[</span><span class="kt">👻P</span>, <span class="kt">I</span>, <span class="kt">-T</span>, <span class="kt">+V</span><span class="o">]</span>
</code></pre></div></div>

<p>Second, and more practically, it illuminates the role of variance in
pattern matching in a way that can be difficult to see with that
confusing data in the way.</p>

<h2 id="it-can-be-covariant">It can be covariant</h2>

<p>The rule for a type parameter being parametrically covariant says we
have to look at all the positions in the data where the type parameter
occurs; if every one of them is a covariant position, then the type
parameter may be marked covariant. Consider a simplified version of
<code class="highlighter-rouge">MyModel</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Gimme</span><span class="o">[</span><span class="kt">P</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">object</span> <span class="nc">AStr</span> <span class="k">extends</span> <span class="nc">Gimme</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">AnInt</span> <span class="k">extends</span> <span class="nc">Gimme</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</code></pre></div></div>

<p>The type parameter <code class="highlighter-rouge">P</code> appears in no positions, so it vacuously
satisfies the requirement “every occurrence is in covariant position”.</p>

<p>So let us mark <code class="highlighter-rouge">P</code> covariant.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Gimme</span><span class="o">[</span><span class="kt">+P</span><span class="o">]</span>
<span class="c1">// otherwise the same
</span></code></pre></div></div>

<h2 id="it-can-be-contravariant">It can be contravariant</h2>

<p>The rule for contravariance is also based on the occurrences of the
type parameter: if every occurrence is in contravariant position, then
the type parameter may be contravariant.</p>

<p>This rule seems to be contradict the rule for covariance, except that
all “every” statements are always true when the set under
consideration is empty.</p>

<ol>
  <li>Set <strong>S</strong> is empty.</li>
  <li>Every element of set <strong>S</strong> is a dog.</li>
  <li>No element of set <strong>S</strong> is a dog.</li>
</ol>

<p>2 and 3 can be true at the same time, but only if 1 is true, too. So
let us mark <code class="highlighter-rouge">P</code> contravariant, in a renamed ADT.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Gotme</span><span class="o">[</span><span class="kt">-P</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">object</span> <span class="nc">UnStr</span> <span class="k">extends</span> <span class="nc">Gotme</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">UnInt</span> <span class="k">extends</span> <span class="nc">Gotme</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</code></pre></div></div>

<h2 id="the-usual-relationships">The usual relationships</h2>

<p>Since you can choose any variance for phantom parameters, the
important question is: what kind of type relationships should
exist within my ADT?</p>

<p>At first, this seems to be merely a question of how values of <code class="highlighter-rouge">Gimme</code>
and <code class="highlighter-rouge">Gotme</code> types ought to widen.</p>

<ol>
  <li>Every <code class="highlighter-rouge">Gimme[Cat]</code> is a <code class="highlighter-rouge">Gimme[Animal]</code>, and</li>
  <li>every <code class="highlighter-rouge">Gotme[Animal]</code> is a <code class="highlighter-rouge">Gotme[Cat]</code>. Moreover,</li>
  <li>every <code class="highlighter-rouge">Gimme[Nothing]</code> is a <code class="highlighter-rouge">Gimme[T]</code> no matter what <code class="highlighter-rouge">T</code> is, and</li>
  <li>every <code class="highlighter-rouge">Gotme[Any]</code> is a <code class="highlighter-rouge">Gotme[T]</code> no matter what <code class="highlighter-rouge">T</code> is.</li>
</ol>

<p>Obviously, if neither of these behaviors—the 1/3 nor the 2/4—is
desirable, you shouldn’t use variance. In my experience, this is the
case for most phantom types. If one is desirable, then it may be fine,
but there’s more to consider.</p>

<h2 id="extracting-the-covariant">Extracting the covariant</h2>

<p>Pattern-matching on the covariant <code class="highlighter-rouge">Gimme</code> reveals fully safe type
information. Unlike <code class="highlighter-rouge">ClassTag</code> and <code class="highlighter-rouge">TypeTag</code>, which are egregiously
broken for this use case, this method of carrying type information
forward into runtime is closed and
<a href="https://imgur.com/a04WoHn">Scalazzi</a>-safe.</p>

<p>What type information is revealed?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">gimme</span><span class="o">[</span><span class="kt">P</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">Gimme</span><span class="o">[</span><span class="kt">P</span><span class="o">])</span><span class="k">:</span> <span class="o">(</span><span class="kt">P</span><span class="o">,</span> <span class="kt">P</span><span class="o">)</span> <span class="k">=</span> <span class="n">g</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">AStr</span> <span class="k">=&gt;</span>
    <span class="c1">// implicitly[P =:= String]   will fail
</span>    <span class="c1">// implicitly[P &lt;:&lt; String]   will fail
</span>    <span class="n">implicitly</span><span class="o">[</span><span class="kt">String</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">P</span><span class="o">]</span>
    <span class="o">(</span><span class="s">"hi"</span><span class="o">,</span> <span class="s">"there"</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">AnInt</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="mi">84</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>If we left <code class="highlighter-rouge">Gimme</code>’s type parameter invariant, all three tests above
would succeed. In the case of this code, on the other hand,</p>

<ol>
  <li><code class="highlighter-rouge">AStr.type</code> (the type of <code class="highlighter-rouge">AStr</code>) widens to <code class="highlighter-rouge">Gimme[String]</code>,</li>
  <li><code class="highlighter-rouge">Gimme[String]</code> can widen to <code class="highlighter-rouge">Gimme[P]</code> as long as <code class="highlighter-rouge">P</code> is a
<em>supertype</em> of <code class="highlighter-rouge">String</code>.</li>
</ol>

<p>Because we’re reversing this process, we have to assume that #2 could
have happened.</p>

<p>The expression <code class="highlighter-rouge">("hi", "there")</code> still compiles because <code class="highlighter-rouge">P</code>, while
otherwise mysterious, <em>surely is</em> a supertype of <code class="highlighter-rouge">String</code>. So the two
<code class="highlighter-rouge">String</code>s can widen to <code class="highlighter-rouge">P</code>.</p>

<p>Things do not work out so well for all such functions.</p>

<h2 id="extracting-the-contravariant">Extracting the contravariant</h2>

<p>Matching on the contravariant <code class="highlighter-rouge">Gotme</code> likewise reveals fully safe
type information.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">mklength</span><span class="o">[</span><span class="kt">P</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">Gotme</span><span class="o">[</span><span class="kt">P</span><span class="o">])</span><span class="k">:</span> <span class="kt">P</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="n">g</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">UnStr</span> <span class="k">=&gt;</span>
    <span class="c1">// implicitly[P =:= String]   will fail
</span>    <span class="n">implicitly</span><span class="o">[</span><span class="kt">P</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">String</span><span class="o">]</span>
    <span class="c1">// implicitly[String &lt;:&lt; P]   will fail
</span>    <span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span>
  <span class="k">case</span> <span class="nc">UnInt</span> <span class="k">=&gt;</span> <span class="n">identity</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now <code class="highlighter-rouge">P &lt;:&lt; String</code>, which failed for the covariant form but succeeds
for the contravariant. On the other hand, we lost <code class="highlighter-rouge">String &lt;:&lt; P</code>,
which only works for the covariant form. That’s because</p>

<ol>
  <li><code class="highlighter-rouge">UnStr.type</code> widens to <code class="highlighter-rouge">Gotme[String]</code>;</li>
  <li><code class="highlighter-rouge">Gotme[String]</code> can widen to <code class="highlighter-rouge">Gotme[P]</code> as long as <code class="highlighter-rouge">P</code> is a
<em>subtype</em> of <code class="highlighter-rouge">String</code>.</li>
</ol>

<p>In the covariant form, we knew that every <code class="highlighter-rouge">String</code> was a <code class="highlighter-rouge">P</code>. In this
code, we know instead that every <code class="highlighter-rouge">P</code> is a <code class="highlighter-rouge">String</code>. Functions that can
handle any <code class="highlighter-rouge">String</code> are thus able to handle any <code class="highlighter-rouge">P</code>, logically, so the
type <code class="highlighter-rouge">String =&gt; Int</code> widens to <code class="highlighter-rouge">P =&gt; Int</code>.</p>

<h2 id="extracting-the-invariant">Extracting the invariant</h2>

<p><code class="highlighter-rouge">gimme</code> would not work with the contravariant GADT; likewise,
<code class="highlighter-rouge">mklength</code> would not work with the covariant GADT.</p>

<p>An invariant GADT supports both, as well as some supported by
neither. For example, we could produce a <code class="highlighter-rouge">(P, P) =&gt; P</code> from a pattern
match. We can do this because the equivalent of <code class="highlighter-rouge">AStr</code> for invariant
<code class="highlighter-rouge">Gimme</code> tells us <code class="highlighter-rouge">P = String</code>, so all three <code class="highlighter-rouge">implicitly</code> checks
succeed.</p>

<p>From the behavior of pattern matching over these three sorts of GADTs,
I take away two lessons about variance in Scala.</p>

<ol>
  <li>It is impractical to infer variance in Scala, because you cannot
mechanically infer what sort of GADT pattern matching functions
ought to be possible to write.</li>
  <li>The type flexibility of a generic type with variance comes at the
cost of decreased flexibility in pattern-matching
code. <a href="https://en.wikipedia.org/wiki/TANSTAAFL">There ain’t no such thing as a free lunch.</a></li>
</ol>

<h2 id="a-gadt-skolem">A GADT skolem</h2>

<p>The “reverse widening” of pattern matching lifts the veil on one of
the more confusing references in type errors, a “GADT skolem”.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">uncons</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">::</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="n">as</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">c</span><span class="o">@(</span><span class="k">_</span> <span class="o">::</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">c</span><span class="o">)</span>
  <span class="c1">//                      ↑
</span>  <span class="c1">// [error] type mismatch;
</span>  <span class="c1">//  found   : ::[?A1] where type ?A1 &lt;: A
</span>  <span class="c1">//            (this is a GADT skolem)
</span>  <span class="c1">//  required: ::[A]
</span>  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
<span class="o">}</span>
</code></pre></div></div>

<p>These “GADT skolems” appear all the time in sensible, compiling
code. Take a <code class="highlighter-rouge">List</code> with some variance carelessly tossed in.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">MyList</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span>
<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">MyCons</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">MyList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
  <span class="k">extends</span> <span class="nc">MyList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">MyNil</span> <span class="k">extends</span> <span class="nc">MyList</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</code></pre></div></div>

<p>Constructing <code class="highlighter-rouge">MyCons[String]</code>, here’s what can happen.</p>

<ol>
  <li><code class="highlighter-rouge">MyCons[String]</code> widens to <code class="highlighter-rouge">MyList[String]</code>.</li>
  <li><code class="highlighter-rouge">MyList[String]</code> can widen to <code class="highlighter-rouge">MyList[U]</code> for any supertype <code class="highlighter-rouge">U</code> of
<code class="highlighter-rouge">String</code>.</li>
</ol>

<p>So in this code, we cannot reverse <code class="highlighter-rouge">MyList[A]</code> down to
<code class="highlighter-rouge">MyCons[A]</code>. But we <em>can</em> get <code class="highlighter-rouge">MyList[L]</code>, where <code class="highlighter-rouge">L</code> is an otherwise
mysterious subtype of <code class="highlighter-rouge">A</code>. <code class="highlighter-rouge">L</code> is the GADT skolem, similar to <code class="highlighter-rouge">?A1</code> in
the above compiler error. The difference is that this code compiles.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">drop1</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">MyList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">MyList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">as</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">MyNil</span> <span class="k">=&gt;</span> <span class="nc">MyNil</span>
    <span class="k">case</span> <span class="nc">MyCons</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">tl</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">tl</span>
    <span class="c1">// tl: MyList[L]  (L is a GADT skolem)
</span>    <span class="c1">// L &lt;: A, therefore
</span>    <span class="c1">// MyList[L] &lt;: MyList[A] by covariance
</span>  <span class="o">}</span>
</code></pre></div></div>

<h2 id="mylists-type-parameter-is-a-phantom"><code class="highlighter-rouge">MyList</code>’s type parameter is a phantom</h2>

<p>We saw earlier that variance has a strong influence on the usability
of pattern matching. <code class="highlighter-rouge">MyList</code> has something important in common with
<code class="highlighter-rouge">Gimme</code>: the class definition does not use <code class="highlighter-rouge">A</code>, it only <em>defines</em>
it. So the scalac-enforced variance rules do not apply, and we can
make <code class="highlighter-rouge">MyList</code> contravariant instead.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">BadList</span><span class="o">[</span><span class="kt">-A</span><span class="o">]</span>
<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">BadCons</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">BadList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
  <span class="k">extends</span> <span class="nc">BadList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">BadNil</span> <span class="k">extends</span> <span class="nc">BadList</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span>
</code></pre></div></div>

<p>Curiously, <code class="highlighter-rouge">drop1</code> still works.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">baddrop1</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">BadList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">BadList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">as</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">BadNil</span> <span class="k">=&gt;</span> <span class="nc">BadNil</span>
    <span class="k">case</span> <span class="nc">BadCons</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">tl</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">tl</span>
    <span class="c1">// tl: BadList[U]  (U is a GADT skolem)
</span>    <span class="c1">// A &lt;: U, therefore
</span>    <span class="c1">// BadList[U] &lt;: BadList[A] by contravariance
</span>  <span class="o">}</span>
</code></pre></div></div>

<p>Other obvious functions will not work for non-obvious reasons.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">badHeadOption</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">BadList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">as</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">BadNil</span> <span class="k">=&gt;</span> <span class="nc">None</span>
    <span class="k">case</span> <span class="nc">BadCons</span><span class="o">(</span><span class="n">hd</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">hd</span><span class="o">)</span>
    <span class="c1">// [error] type mismatch;   ↑
</span>    <span class="c1">//  found   : hd.type (with underlying type Any)
</span>    <span class="c1">//  required: A
</span>  <span class="o">}</span>
</code></pre></div></div>

<p>This fails because the skolem from a contravariant parameter is a
supertype instead of subtype. So</p>

<ol>
  <li><code class="highlighter-rouge">hd: U</code> (<code class="highlighter-rouge">U</code> is a GADT skolem),</li>
  <li><code class="highlighter-rouge">A &lt;: U</code>,</li>
  <li>we’re stuck; there is no <code class="highlighter-rouge">A</code> value.</li>
</ol>

<p>This is not to imply something as silly as “covariance good,
contravariance bad”; you can just as well get these errors by marking
a parameter covariant that can only meaningfully be marked
contravariant. If anything, contravariance is more important than
covariance. The problem you must face is that the compiler is less
helpful in determining what “meaningful” marking, if any, should be
applied.</p>

<p><code class="highlighter-rouge">MyModel</code>, from the beginning of this article, demonstrates three
situations in which each supported variance is natural. You may use it
as a guide, but its sanity is not compiler-checked. Your variances’
sanity, or lack thereof, only becomes apparent when implementing
practical functions over a datatype.</p>

<h2 id="extracting-the-phantom">Extracting the phantom</h2>

<p>Suppose the phantom variance was defined, and we revisit the
<code class="highlighter-rouge">String</code>-and-<code class="highlighter-rouge">Int</code> GADT one more time.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">BooGimme</span><span class="o">[</span><span class="kt">👻P</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">object</span> <span class="nc">BooStr</span> <span class="k">extends</span> <span class="nc">BooGimme</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">BooInt</span> <span class="k">extends</span> <span class="nc">BooGimme</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</code></pre></div></div>

<p>The trouble with letting the compiler infer covariance or
contravariance is that, on the face of it, either is as good as the
other. With phantom, we choose both.</p>

<p>But this variance makes the GADT utterly useless. Consider how
<code class="highlighter-rouge">BooStr</code> becomes <code class="highlighter-rouge">BooGimme[P]</code>.</p>

<ol>
  <li><code class="highlighter-rouge">BooStr</code> widens to <code class="highlighter-rouge">BooGimme[String]</code>.</li>
  <li><code class="highlighter-rouge">BooGimme[String]</code> can widen to <code class="highlighter-rouge">BooGimme[P]</code> where <code class="highlighter-rouge">P</code> is…oops,
there are no conditions this time! <code class="highlighter-rouge">P</code> can be anything at all and
the widen will still work.</li>
</ol>

<p>The match tells us nothing about the type parameter; all three of the
type relationship checks via <code class="highlighter-rouge">implicitly</code> from the examples above
fail. We maximize the flexibility of the type parameter at the cost of
making GADT pattern matching impossible.</p>

<p>Likewise, if you mark <code class="highlighter-rouge">MyList[A]</code>’s type parameter phantom, there are
no bounds on the GADT skolem, so there’s little you can do with the
elements of the list.</p>

<h2 id="the-case-for-choosing-no-variance">The case for choosing no variance</h2>

<p>My <code class="highlighter-rouge">scalac</code> error message pet peeve is the one suggesting that you
should add a variance annotation. This message treats the addition of
variance like a mechanical change: “if it compiles, it works”. On the
contrary, we have seen that</p>

<ol>
  <li>The flexibility of variance costs flexibility elsewhere;</li>
  <li>the compiler cannot predict how this might harm your APIs’
practicality;</li>
  <li>the semantics of pattern matching are more complex in the face of
variance.</li>
</ol>

<p>Even if variance is applicable to your datatype, these costs, and the
cost of the additional complexity burden, should give you pause. Yet,
I stand by the claim I made in “The missing diamond
of Scala variance”: subtyping is incomplete without variance, so if
variance is too complicated, so is subtyping.</p>

<p>I don’t think subtyping—and its necessary component, variance—are too
complex for the working programmer to understand. Indeed, it can be a
fascinating exercise, with plenty of practical implications.</p>

<p>But, to me, the consequence of working out such exercises is that
neither variance nor subtyping ought to be used in the design of
practical programs, especially when higher-kinded type parameters and
members are available, offering far more flexibility at a better
price. There is no need to struggle in the face of all-too-often
missing features.</p>

<p><em>This article was tested with Scala 2.11.8.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Mon, 19 Sep 2016 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2016/09/19/variance-phantom.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/09/19/variance-phantom.html</guid>
      </item>
    
      <item>
        <title>Higher-kinded types: the difference between giving up, and moving forward</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>As its opening sentence reminds the reader—a point often missed by
many reviewers—the book
<a href="https://www.manning.com/books/functional-programming-in-scala"><em>Functional Programming in Scala</em></a>
is not a book about Scala. This [wise] choice occasionally manifests
in peculiar ways.</p>

<p>For example, you can go quite far into the book implementing its
exercises in languages with simpler type systems. Chapters 1–8 and 10
port quite readily to
<a href="https://github.com/sbordet/fpinscala-jdk8">Java [8]</a> and C#. So
<em>Functional Programming in Scala</em> can be a very fine resource for
learning some typed functional programming, even if such languages are
all you have to work with. Within these chapters, you can remain
blissfully unaware of the limitations imposed on you by these
languages’ type systems.</p>

<p>However, there is a point of inflection in the book at chapter 11. You
can pass through with a language such as <a href="https://ocaml.org/">OCaml</a>,
Scala, Haskell, <a href="http://www.purescript.org/">PureScript</a>, or one of a
few others. However, users of Java, C#, F#,
<a href="http://elm-lang.org/">Elm</a>, and many others may proceed no further,
and must turn back here.</p>

<p><img src="/img/media/hkt-inflection.png" alt="Various languages' chapter 11 support" /></p>

<p>Here is where abstracting over type constructors, or “higher-kinded
types”, comes into play. At this point in the book, you can give up,
or proceed with a sufficiently powerful language. Let’s see how this
happens.</p>

<h2 id="functional-combinators">Functional combinators</h2>

<p>The bread and butter of everyday functional programming, the
“patterns” if you like, is the implementation of standard functional
combinators for your datatypes, and more importantly the comfortable,
confident use of these combinators in your program.</p>

<p>For example, confidence with <code class="highlighter-rouge">bind</code>, also known as <code class="highlighter-rouge">&gt;&gt;=</code> or <code class="highlighter-rouge">flatMap</code>,
is very important. The best way to acquire this comfort is to
reimplement it a bunch of times, so <em>Functional Programming in Scala</em>
has you do just that.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="c1">// in List[A]
</span><span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="c1">// in Option[A]
</span><span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">B</span><span class="o">]</span> <span class="c1">// in Either[E, A]
</span><span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">State</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">B</span><span class="o">]</span> <span class="c1">// in State[S, A]
</span></code></pre></div></div>

<h2 id="all-flatmaps-are-the-same">All <code class="highlighter-rouge">flatMap</code>s are the same</h2>

<p>The similarity between these functions’ types is the most obvious
surfacing of their ‘sameness’. (Unless you wish to count their names,
which I do not.) That sameness is congruent: when you write functions
using <code class="highlighter-rouge">flatMap</code>, in any of the varieties above, these functions
inherit a sort of sameness from the underlying <code class="highlighter-rouge">flatMap</code> combinator.</p>

<p>For example, supposing we have <code class="highlighter-rouge">map</code> and <code class="highlighter-rouge">flatMap</code> for a type, we can
‘tuple’ the values within.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">tuple</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">bs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
  <span class="n">as</span><span class="o">.</span><span class="n">flatMap</span><span class="o">{</span><span class="n">a</span> <span class="k">=&gt;</span>
    <span class="n">bs</span><span class="o">.</span><span class="n">map</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="k">_</span><span class="o">))}</span>
    
<span class="k">def</span> <span class="n">tuple</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">bs</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
  <span class="n">as</span><span class="o">.</span><span class="n">flatMap</span><span class="o">{</span><span class="n">a</span> <span class="k">=&gt;</span>
    <span class="n">bs</span><span class="o">.</span><span class="n">map</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="k">_</span><span class="o">))}</span>
    
<span class="k">def</span> <span class="n">tuple</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">],</span> <span class="n">bs</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="o">(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
  <span class="n">as</span><span class="o">.</span><span class="n">flatMap</span><span class="o">{</span><span class="n">a</span> <span class="k">=&gt;</span>
    <span class="n">bs</span><span class="o">.</span><span class="n">map</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="k">_</span><span class="o">))}</span>
    
<span class="k">def</span> <span class="n">tuple</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">A</span><span class="o">],</span> <span class="n">bs</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>, <span class="o">(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
  <span class="n">as</span><span class="o">.</span><span class="n">flatMap</span><span class="o">{</span><span class="n">a</span> <span class="k">=&gt;</span>
    <span class="n">bs</span><span class="o">.</span><span class="n">map</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="k">_</span><span class="o">))}</span>
</code></pre></div></div>

<p><em>Functional Programming in Scala</em> contains several such functions,
such as <code class="highlighter-rouge">sequence</code>. These are each implemented for several types, each
time with potentially the same code, if you remember to look back and
try copying and pasting a previous solution.</p>

<h2 id="to-parameterize-or-not-to-parameterize">To parameterize, or not to parameterize</h2>

<p>In programming, when we encounter such great sameness—not merely
similar code, but <em>identical</em> code—we would like the opportunity to
<em>parameterize</em>: extract the parts that are different to arguments, and
recycle the common code for all situations.</p>

<p>In <code class="highlighter-rouge">tuple</code>’s case, what is different are</p>

<ol>
  <li>the <code class="highlighter-rouge">flatMap</code> and <code class="highlighter-rouge">map</code> implementations, and</li>
  <li>the <strong>type constructor</strong>: <code class="highlighter-rouge">List</code>, <code class="highlighter-rouge">Option</code>, <code class="highlighter-rouge">State[S, ...]</code>, what
have you.</li>
</ol>

<p>We have a way to pass in implementations; that’s just higher-order
functions, or ‘functions as arguments’. For the type constructor, we
need ‘type-level functions as arguments’.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">tuplef</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>We’ve handled ‘type constructor as argument’, and will add the
<code class="highlighter-rouge">flatMap</code> and <code class="highlighter-rouge">map</code> implementations in a moment. First, let’s learn
how to read this.</p>

<h2 id="reading-a-higher-kinded-type">Reading a higher-kinded type</h2>

<p>Confronted with a type like this, it’s helpful to sit back and muse on
the nature of a function for a moment.</p>

<p>Functions are given meaning by substitution of their arguments.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">double</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">double</code> remains “an abstraction” until we <em>substitute for x</em>; in
other words, pass an argument.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>double(2)    double(5)
2 + 2        5 + 5
4            10
</code></pre></div></div>

<p>But this isn’t enough to tell us <em>what <code class="highlighter-rouge">double</code> is</em>; all we see from
these tests is that <code class="highlighter-rouge">double</code> sometimes returns 4, sometimes 10,
sometimes maybe other things. We must imagine what <code class="highlighter-rouge">double</code> does in
common <em>for all possible arguments</em>.</p>

<p>Likewise, we give meaning to type-parameterized definitions like
<code class="highlighter-rouge">tuplef</code> by substitution. The parameter declaration <code class="highlighter-rouge">F[_]</code> means that
<code class="highlighter-rouge">F</code> may not be a simple type, like <code class="highlighter-rouge">Int</code> or <code class="highlighter-rouge">String</code>, but instead a
one-argument type constructor, like <code class="highlighter-rouge">List</code> or <code class="highlighter-rouge">Option</code>. Performing
these substitutions for <code class="highlighter-rouge">tuplef</code>, we get</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// original, as above
</span><span class="k">def</span> <span class="n">tuplef</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>

<span class="c1">// F = List
</span><span class="k">def</span> <span class="n">tupleList</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>

<span class="c1">// F = Option
</span><span class="k">def</span> <span class="n">tupleOpt</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>
</code></pre></div></div>

<p>More complicated and powerful cases are available with other kinds of
type constructors, such as by partially applying. That’s how we can
fit <code class="highlighter-rouge">State</code>, <code class="highlighter-rouge">Either</code>, and other such types with two or more
parameters into the <code class="highlighter-rouge">F</code> parameter.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// F = Either[E, ...]
</span><span class="k">def</span> <span class="n">tupleEither</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">B</span><span class="o">])</span>
    <span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="o">(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>

<span class="c1">// F = State[S, ...]
</span><span class="k">def</span> <span class="n">tupleState</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">B</span><span class="o">])</span>
    <span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>, <span class="o">(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>
</code></pre></div></div>

<p>Just as with <code class="highlighter-rouge">double</code>, though this isn’t the whole story of <code class="highlighter-rouge">tuplef</code>,
its true meaning arises from the common way in which it treats <em>all
possible</em> <code class="highlighter-rouge">F</code> arguments. That is where higher kinds start to get
interesting.</p>

<h2 id="implementing-functions-with-higher-kinded-type">Implementing functions with higher-kinded type</h2>

<p>The type of <code class="highlighter-rouge">tuplef</code> expresses precisely our intent—the idea of
“multiplying” two <code class="highlighter-rouge">F</code>s, tupling the values within—but cannot be
implemented as written. That’s because we don’t have functions that
operate on <code class="highlighter-rouge">F</code>-constructed values, like <code class="highlighter-rouge">fa: F[A]</code> and <code class="highlighter-rouge">fb: F[B]</code>. As
with any value of an ordinary type parameter, these are opaque.</p>

<p>In Scala, there are a few ways to pass in the necessary functions. One
option is to implement a <code class="highlighter-rouge">trait</code> or <code class="highlighter-rouge">abstract class</code> that itself uses
a higher-kinded type parameter or abstract type constructor. Here are
a couple possibilities.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Bindable</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">+A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">BindableTM</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">F</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note that we must use higher-kinded trait type signatures to support
our higher-kinded method types; otherwise, we can’t write the return
types for <code class="highlighter-rouge">map</code> and <code class="highlighter-rouge">flatMap</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">BindableBad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span> <span class="kt">???</span>
            <span class="c1">// where is the B supposed to go?
</span></code></pre></div></div>

<p>Now we make every type we’d like to support either inherit from or
implicitly convert to <code class="highlighter-rouge">Bindable</code>, such as <code class="highlighter-rouge">List[+A] extends
Bindable[List, A]</code>, and write <code class="highlighter-rouge">tuplef</code> as follows.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">tupleBindable</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Bindable</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">Bindable</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">B</span><span class="o">])</span>
    <span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
  <span class="n">fa</span><span class="o">.</span><span class="n">flatMap</span><span class="o">{</span><span class="n">a</span> <span class="k">=&gt;</span>
    <span class="n">fb</span><span class="o">.</span><span class="n">map</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="k">_</span><span class="o">))}</span>
</code></pre></div></div>

<h2 id="escaping-two-bad-choices">Escaping two bad choices</h2>

<p>There are two major problems with <code class="highlighter-rouge">Bindable</code>’s representation of <code class="highlighter-rouge">map</code>
and <code class="highlighter-rouge">flatMap</code>, ensuring its wild unpopularity in the Scala functional
community, though it still appears in some places, such as
<a href="https://github.com/ermine-language/ermine-parser/blob/cc77bf6e150a16129744d18d69022f7b5902814f/src/main/scala/scalaparsers/Monadic.scala">in Ermine</a>.</p>

<ol>
  <li>The choices of inheritance and implicit conversion are both bad in
different ways. Implicit conversion propagates very poorly—it
doesn’t compose, after all, and fails as soon as we do something
innocent like put the value-to-be-converted into a tuple.
Inheritance leaves its own mess: modifying a type to add new,
nonessential operations, and the weird way that <code class="highlighter-rouge">F</code> is declared in
the method type parameters above.</li>
  <li>The knowledge required to work out the new type signature above is
excessively magical. There are rules about when implicit conversion
happens, how much duplication of the reference to <code class="highlighter-rouge">Bindable</code> is
required to have the <code class="highlighter-rouge">F</code> parameter infer correctly, and even how
many calls to <code class="highlighter-rouge">Bindable</code> methods are performed. For example, we’d
have to declare the <code class="highlighter-rouge">F</code> parameter as <code class="highlighter-rouge">F[X] &lt;: Bindable[F, X]</code> if we
did one more trailing <code class="highlighter-rouge">map</code> call. But then we wouldn’t support
implicit conversion cases anymore, so we’d have to do something
else, too.</li>
</ol>

<p>As a result of all this magic, generic functions over higher kinds
with OO-style operations tend to be ugly; note how much <code class="highlighter-rouge">tuplef</code>
looked like the <code class="highlighter-rouge">List</code>-specific type, and how little <code class="highlighter-rouge">tupleBindable</code>
looks like either of them.</p>

<p>But we still really, really want to be able to write this kind of
generic function. Luckily, we have a Wadler-made alternative.</p>

<h2 id="typeclasses-constrain-higher-kinded-types-elegantly">Typeclasses constrain higher-kinded types elegantly</h2>

<p>To constrain <code class="highlighter-rouge">F</code> to types with the <code class="highlighter-rouge">flatMap</code> and <code class="highlighter-rouge">map</code> we need, we use
typeclasses instead. For <code class="highlighter-rouge">tuplef</code>, that means we leave <code class="highlighter-rouge">F</code> abstract,
and leave the types of <code class="highlighter-rouge">fa</code> and <code class="highlighter-rouge">fb</code> as well as the return type
unchanged, but add an implicit argument, the “typeclass instance”,
which is a first-class representation of the <code class="highlighter-rouge">map</code> and <code class="highlighter-rouge">flatMap</code>
operations.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Bind</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="c1">// note the new ↓ fa argument
</span>  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Then we define instances for the types we’d like to have this on:
<code class="highlighter-rouge">Bind[List]</code>, <code class="highlighter-rouge">Bind[Option]</code>, and so on, as seen in chapter 11 of
<em>Functional Programming in Scala</em>.</p>

<p>Now we just add the argument to <code class="highlighter-rouge">tuplef</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">tupleTC</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span>
           <span class="o">(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Bind</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
  <span class="n">F</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">fa</span><span class="o">){</span><span class="n">a</span> <span class="k">=&gt;</span>
    <span class="n">F</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">fb</span><span class="o">)((</span><span class="n">a</span><span class="o">,</span> <span class="k">_</span><span class="o">))}</span>
</code></pre></div></div>

<p>We typically mirror the typeclass operations back to methods with an
implicit conversion—unlike with <code class="highlighter-rouge">Bindable</code>, this has no effect on
exposed APIs, so is benign. Then, we can remove the <code class="highlighter-rouge">implicit F</code>
argument, replacing it by writing <code class="highlighter-rouge">F[_]: Bind</code> in the type argument
list, and write the method body as it has been written before, with
<code class="highlighter-rouge">flatMap</code> and <code class="highlighter-rouge">map</code> methods.</p>

<p>There’s another major reason to prefer typeclasses, but let’s get back
to <em>Functional Programming in Scala</em>.</p>

<h2 id="getting-stuck">Getting stuck</h2>

<p>I’ve just described many of the practical mechanics of writing useful
functions that abstract over type constructors, but <em>all this is moot
if you cannot abstract over type constructors</em>. The fact that Java
provides no such capability is not an indicator that they have
sufficient abstractions to replace this missing feature: it is simply
an abstraction that they do not provide you.</p>

<p><strong>Oh, you would like to factor this common code? Sorry, you are
stuck. You will have to switch languages if you wish to proceed.</strong></p>

<h2 id="dont-get-stuck-on-the-second-order">Don’t get stuck on the second order</h2>

<p><code class="highlighter-rouge">map</code> functions are obvious candidates for essential parts of a usable
library for functional programming. This is the first-order
abstraction—it eliminates the concrete loops, recursive functions,
or <code class="highlighter-rouge">State</code> lambda specifications, you would need to write otherwise.</p>

<p>When we note a commonality in patterns and define an abstraction over
that commonality, we move “one order up”. When we stopped simply
defining functions, and started taking functions as arguments, we
moved from the first order to the second order.</p>

<p>It is not enough for a modern general-purpose functional library in
Scala to simply have a bunch of <code class="highlighter-rouge">map</code> functions. It must also provide
the second-order feature: the ability to <em>abstract over</em> <code class="highlighter-rouge">map</code>
functions, as well as many, many other functions numerous type
constructors have in common. Let’s not give up; let’s move forward.</p>

<p><em>This article was tested with Scala 2.11.7 and
<a href="https://github.com/fpinscala/fpinscala">fpinscala</a> 5b0115a answers,
with the addition of the method variants of <code class="highlighter-rouge">List#map</code> and
<code class="highlighter-rouge">List#flatMap</code>.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 21 Aug 2016 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2016/08/21/hkts-moving-forward.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/08/21/hkts-moving-forward.html</guid>
      </item>
    
      <item>
        <title>Making internal state functional</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><em>This is the ninth of a series of articles on “Type Parameters and
Type Members”.</em></p>

<p>Scala’s
<a href="http://www.scala-lang.org/api/2.11.8/scala/collection/generic/CanBuildFrom.html"><code class="highlighter-rouge">CanBuildFrom</code> API</a>
is relatively well-founded and flexible;
<a href="https://bitbucket.org/S11001001/record-map#markdown-header-using-gadts-to-find-fast-paths-safely">in combination with GADTs, it can provide that flexibility in a fully type-safe way</a>,
if users choose not to circumvent it with typecasting.</p>

<p>However, it is designed in a purely mutable way; you cannot write a
useful <code class="highlighter-rouge">CanBuildFrom</code> that does not rely on mutation, and you cannot
use the API externally in a functional way.</p>

<p>Let’s design an alternative to <code class="highlighter-rouge">CanBuildFrom</code> that makes sense in a
purely functional context, allowing both implementers and users to
avoid unsightly mutation.</p>

<p>Spoiler warning! Our first pass will have one glaring inelegance. We
will use concepts from previous articles in <em>Type Parameters and Type
Members</em> to “invert the abstraction”, which will greatly simplify the
design. Once you’re comfortable with the “inversion”, you can skip the
intermediate step and use this technique directly in your own designs.</p>

<h2 id="disallowing-functional-approaches">Disallowing functional approaches</h2>

<p>The pattern of use of <code class="highlighter-rouge">CanBuildFrom</code> is</p>

<ol>
  <li><code class="highlighter-rouge">apply</code> the CBF to produce a
<a href="http://www.scala-lang.org/api/2.11.8/scala/collection/mutable/Builder.html"><code class="highlighter-rouge">Builder</code></a>.</li>
  <li>Call <code class="highlighter-rouge">+=</code> and <code class="highlighter-rouge">++=</code> methods to “fill up” the <code class="highlighter-rouge">Builder</code>.</li>
  <li>Call <code class="highlighter-rouge">result</code> to “finalize” or “commit” to the final structure.</li>
</ol>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">collection.generic.CanBuildFrom</span>

<span class="k">val</span> <span class="n">cbf</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">CanBuildFrom</span><span class="o">[</span><span class="kt">Nothing</span>, <span class="kt">Int</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]]</span>
<span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="n">cbf</span><span class="o">()</span>
<span class="n">b</span> <span class="o">+=</span> <span class="mi">3</span>
<span class="n">b</span> <span class="o">++=</span> <span class="nc">Seq</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">result</span><span class="o">()</span>

<span class="n">res0</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
</code></pre></div></div>

<p>Let’s set aside that this is only suited to eager collections, not
lazy ones like
<a href="http://www.scala-lang.org/api/2.11.8/scala/collection/immutable/Stream.html"><code class="highlighter-rouge">Stream</code></a>. You
can tell the problem by types: <code class="highlighter-rouge">+=</code> and <code class="highlighter-rouge">++=</code> have the return type
<code class="highlighter-rouge">this.type</code>. Effectively, this means that if their implementations are
purely functional, all they can do is return <code class="highlighter-rouge">this</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="o">+=(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Elem</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span>
  <span class="k">def</span> <span class="o">++=(</span><span class="n">elems</span><span class="k">:</span> <span class="kt">TraversableOnce</span><span class="o">[</span><span class="kt">Elem</span><span class="o">])</span> <span class="k">=</span> <span class="k">this</span>
</code></pre></div></div>

<p>Aside from the informal contract of <code class="highlighter-rouge">Builder</code>, which suggests that
calls to these methods perform a side effect, the types enforce that
they <em>must</em> perform any useful work by means of side effects.</p>

<p>Returning <code class="highlighter-rouge">this.type</code> permits these methods to be called in a
superficially functional style:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span><span class="o">.+=(</span><span class="mi">3</span><span class="o">)</span>
 <span class="o">.++=(</span><span class="nc">Seq</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
 <span class="o">.</span><span class="n">result</span><span class="o">()</span>

<span class="n">res1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
</code></pre></div></div>

<p>This retouch is only skin-deep, and can’t repair the defect making
<code class="highlighter-rouge">CanBuildFrom</code> unsuitable for functional programs, but it implies that
a functional alternative lurks nearby. Let’s go looking for it.</p>

<h2 id="step-1-explicit-builder-state">Step 1: explicit <code class="highlighter-rouge">Builder</code> state</h2>

<p>First, we need to take the essential mutation out of <code class="highlighter-rouge">Builder</code>. That
means it needs to provide an initial state, and the other methods must
use it as a parameter and return value.</p>

<ol>
  <li>We’ll add a new method to return the initial state.</li>
  <li><code class="highlighter-rouge">+=</code> and <code class="highlighter-rouge">++=</code> will take that state as an argument, returning the
new state instead of <code class="highlighter-rouge">this.type</code>.</li>
  <li><code class="highlighter-rouge">result</code> will take the final state as an argument, still producing
the result collection.</li>
</ol>

<p>While the intermediate state <em>might</em> be the same as the final state,
we don’t want to require that. So <code class="highlighter-rouge">Builder</code> also gains a type
parameter to represent the type of state, <code class="highlighter-rouge">S</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">FunBuilder</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">-Elem</span>, <span class="kt">+To</span><span class="o">]</span> <span class="o">{</span>
  <span class="cm">/** Produce the initial state. */</span>
  <span class="k">def</span> <span class="n">init</span><span class="k">:</span> <span class="kt">S</span>

  <span class="c1">// note everywhere 'S' was added
</span>  <span class="k">def</span> <span class="o">+=(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">Elem</span><span class="o">)</span><span class="k">:</span> <span class="kt">S</span>
  <span class="k">def</span> <span class="o">++=(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">elems</span><span class="k">:</span> <span class="kt">TraversableOnce</span><span class="o">[</span><span class="kt">Elem</span><span class="o">])</span><span class="k">:</span> <span class="kt">S</span>
  <span class="k">def</span> <span class="n">result</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">To</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="a-sample-funbuilder">A sample <code class="highlighter-rouge">FunBuilder</code></h2>

<p>We can incrementally build a
<a href="http://www.scala-lang.org/api/2.11.8/scala/collection/immutable/Vector.html"><code class="highlighter-rouge">Vector</code></a>,
but it may not be the most efficient way. Instead, let’s try to
accumulate a
<a href="http://www.scala-lang.org/api/2.11.8/scala/collection/immutable/List.html"><code class="highlighter-rouge">List</code></a>,
then construct the <code class="highlighter-rouge">Vector</code> once we’re done.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">VectorBuilderList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
    <span class="nc">extends</span> <span class="nc">FunBuilder</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">init</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
  
  <span class="k">def</span> <span class="o">+=(</span><span class="n">s</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="n">elem</span> <span class="o">::</span> <span class="n">s</span>
  
  <span class="k">def</span> <span class="o">++=(</span><span class="n">s</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">elems</span><span class="k">:</span> <span class="kt">TraversableOnce</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span>
    <span class="n">elems</span><span class="o">.</span><span class="n">toList</span> <span class="n">reverse_:::</span> <span class="n">s</span>
  
  <span class="k">def</span> <span class="n">result</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span>
    <span class="n">s</span><span class="o">.</span><span class="n">toVector</span><span class="o">.</span><span class="n">reverse</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">vbl</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">VectorBuilderList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">vbl</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">vbl</span><span class="o">.++=(</span><span class="n">vbl</span><span class="o">.+=(</span><span class="n">vbl</span><span class="o">.</span><span class="n">init</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">Seq</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)))</span>

<span class="n">res0</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>

<p>(There’s a problem with <code class="highlighter-rouge">CanBuildFrom</code> now, but we’ll hold off fixing
it.)</p>

<h2 id="a-slightly-different-builder">A slightly different Builder</h2>

<p>Maybe it would be better to optimize for the <code class="highlighter-rouge">++=</code> “bulk add” method,
though.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">VectorBuilderListList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
    <span class="nc">extends</span> <span class="nc">FunBuilder</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Traversable</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>, <span class="kt">A</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">init</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
  
  <span class="k">def</span> <span class="o">+=(</span><span class="n">s</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Traversable</span><span class="o">[</span><span class="kt">A</span><span class="o">]],</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span>
    <span class="nc">Traversable</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span> <span class="o">::</span> <span class="n">s</span>
    
  <span class="k">def</span> <span class="o">++=(</span><span class="n">s</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Traversable</span><span class="o">[</span><span class="kt">A</span><span class="o">]],</span> <span class="n">elems</span><span class="k">:</span> <span class="kt">TraversableOnce</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span>
    <span class="n">elems</span><span class="o">.</span><span class="n">toTraversable</span> <span class="o">::</span> <span class="n">s</span>
    
  <span class="k">def</span> <span class="n">result</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Traversable</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span> <span class="k">=</span>
    <span class="n">s</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="nc">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]()){(</span><span class="n">z</span><span class="o">,</span> <span class="n">as</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">as</span> <span class="o">++:</span> <span class="n">z</span><span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">vbll</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">VectorBuilderListList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">vbll</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">vbll</span><span class="o">.++=(</span><span class="n">vbll</span><span class="o">.+=(</span><span class="n">vbll</span><span class="o">.</span><span class="n">init</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">Seq</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)))</span>

<span class="n">res0</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="hide-your-state">Hide your state</h2>

<p>The type of these builders are different, even though their usage is
the same. This design also exposes what was originally <em>internal</em>
state as part of the API. Luckily, <code class="highlighter-rouge">CanBuildFrom</code> makes a point of
this when we try to integrate <code class="highlighter-rouge">FunBuilder</code> into our own CBF version;
there’s nowhere to put the <code class="highlighter-rouge">S</code> type parameter.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">FunCanBuildFrom</span><span class="o">[</span><span class="kt">-From</span>, <span class="kt">-Elem</span>, <span class="kt">+To</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">()</span><span class="k">:</span> <span class="kt">FunBuilder</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Elem</span>, <span class="kt">To</span><span class="o">]</span>
<span class="o">}</span>

<span class="err">…</span><span class="o">/</span><span class="nc">FCBF</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">42</span><span class="kt">:</span> <span class="kt">not</span> <span class="kt">found:</span> <span class="k">type</span> <span class="kt">S</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">()</span><span class="k">:</span> <span class="kt">FunBuilder</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Elem</span>, <span class="kt">To</span><span class="o">]</span>
                          <span class="o">^</span>
</code></pre></div></div>

<p>We can hide the state by forcing the caller to deal with the builder
in a state-generic context. One way to do this is with a generic
continuation.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">BuilderCont</span><span class="o">[</span><span class="kt">+Elem</span>, <span class="kt">-To</span>, <span class="kt">+Z</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">continue</span><span class="o">[</span><span class="kt">S</span><span class="o">](</span><span class="n">builder</span><span class="k">:</span> <span class="kt">FunBuilder</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Elem</span>, <span class="kt">To</span><span class="o">])</span><span class="k">:</span> <span class="kt">Z</span>
<span class="o">}</span>

<span class="c1">// in FunCanBuildFrom...
</span>  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">cont</span><span class="k">:</span> <span class="kt">BuilderCont</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">To</span>, <span class="kt">Z</span><span class="o">])</span><span class="k">:</span> <span class="kt">Z</span>
</code></pre></div></div>

<p>Now we can implement a <code class="highlighter-rouge">FunCanBuildFrom</code> that can use either of the
<code class="highlighter-rouge">FunBuilder</code>s we’ve defined.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">VectorCBF</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">bulkOptimized</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">FunCanBuildFrom</span><span class="o">[</span><span class="kt">Any</span>, <span class="kt">A</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">cont</span><span class="k">:</span> <span class="kt">BuilderCont</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">Z</span><span class="o">])</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">bulkOptimized</span><span class="o">)</span>
      <span class="n">cont</span> <span class="n">continue</span> <span class="o">(</span><span class="k">new</span> <span class="nc">VectorBuilderListList</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="n">cont</span> <span class="n">continue</span> <span class="o">(</span><span class="k">new</span> <span class="nc">VectorBuilderList</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Take a look at the type flow. The caller of <code class="highlighter-rouge">apply</code> is the one who
decides the <code class="highlighter-rouge">Z</code> type. But the <code class="highlighter-rouge">apply</code> implementation chooses the <code class="highlighter-rouge">S</code>
to pass to <code class="highlighter-rouge">continue</code>, which cannot know any more about what that
state type is. (It can even choose different types based on runtime
decisions.) Information hiding is restored.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">cbf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">VectorCBF</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="kc">true</span><span class="o">)</span>
<span class="n">cbf</span><span class="o">{</span><span class="k">new</span> <span class="nc">BuilderCont</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">continue</span><span class="o">[</span><span class="kt">S</span><span class="o">](</span><span class="n">vbl</span><span class="k">:</span> <span class="kt">FunBuilder</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Int</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]])</span> <span class="k">=</span>
    <span class="n">vbl</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">vbl</span><span class="o">.++=(</span><span class="n">vbl</span><span class="o">.+=(</span><span class="n">vbl</span><span class="o">.</span><span class="n">init</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">Seq</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)))</span>
<span class="o">}}</span>

<span class="n">res1</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>

<p>Now the code using the <code class="highlighter-rouge">FunBuilder</code> can’t fiddle with the
<code class="highlighter-rouge">FunBuilder</code>’s state values; it can only rewind to previously seen
states, a norm to be expected in functional programming with
persistent state values.</p>

<h2 id="existential-types-are-abstraction-inversion">Existential types are abstraction inversion</h2>

<p>This is rather a lot of inconvenient ceremony, though. Instead of
passing a continuation that receives the <code class="highlighter-rouge">S</code> type as an argument along
with the <code class="highlighter-rouge">FunBuilder</code>, let’s just have <code class="highlighter-rouge">apply</code> return the type along
with the <code class="highlighter-rouge">FunBuilder</code>. We have a tool for returning a pair of type and
value using that type.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="n">apply</span><span class="o">()</span><span class="k">:</span> <span class="kt">FunBuilder</span><span class="o">[</span><span class="k">_</span>, <span class="kt">Elem</span>, <span class="kt">To</span><span class="o">]</span>
</code></pre></div></div>

<p>Remember that existential types are pairs.</p>

<p>Having collapsed callee-of-callee back to caller perspective, let’s
apply the rule of thumb from
<a href="/blog/2015/07/13/type-members-parameters.html">the first post in this series</a>.</p>

<blockquote>
  <p>A type parameter is usually more convenient and harder to screw up, but if you intend to use it existentially in most cases, changing it to a member is probably better.</p>
</blockquote>

<p>The usual case will be from the perspective of a CBF user, so the
usual use of the <code class="highlighter-rouge">S</code> parameter is existential. So let’s turn it into
the equivalent type member.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// rewrite the heading of FunBuilder as
</span><span class="k">trait</span> <span class="nc">FunBuilder</span><span class="o">[</span><span class="kt">-Elem</span>, <span class="kt">+To</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">S</span>
  
<span class="c1">// and FunCanBuildFrom#apply as
</span>  <span class="k">def</span> <span class="n">apply</span><span class="o">()</span><span class="k">:</span> <span class="kt">FunBuilder</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">To</span><span class="o">]</span>

<span class="c1">// and the parameter S moves to a member
// for all implementations so far;
// fix until compile or see appendix
</span></code></pre></div></div>

<p>And we can see the information stays hidden.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">cbf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">VectorCBF</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="kc">true</span><span class="o">)</span>
<span class="n">cbf</span><span class="k">:</span> <span class="kt">fcbf.VectorCBF</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">fcbf</span><span class="o">.</span><span class="nc">VectorCBF</span><span class="k">@</span><span class="mi">4363</span><span class="n">e2ba</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">vb</span> <span class="k">=</span> <span class="n">cbf</span><span class="o">()</span>
<span class="n">vb</span><span class="k">:</span> <span class="kt">fcbf.FunBuilder</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="n">fcbf</span><span class="o">.</span><span class="nc">VectorBuilderListList</span><span class="k">@</span><span class="mi">527</span><span class="n">c222e</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">with1</span> <span class="k">=</span> <span class="n">vb</span><span class="o">.+=(</span><span class="n">vb</span><span class="o">.</span><span class="n">init</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">with1</span><span class="k">:</span> <span class="kt">vb.S</span> <span class="o">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">with2</span> <span class="k">=</span> <span class="n">vb</span><span class="o">.++=(</span><span class="n">with1</span><span class="o">,</span> <span class="nc">Seq</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
<span class="n">with2</span><span class="k">:</span> <span class="kt">vb.S</span> <span class="o">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">vb</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">with2</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</code></pre></div></div>

<p>As in
<a href="/blog/2015/07/30/values-never-change-types.html#naming-the-existential">“Values never change types”</a>,
<code class="highlighter-rouge">vb.S</code> is abstract, existential, irreducible.</p>

<h2 id="last-minute-adjustments">Last minute adjustments</h2>

<p><code class="highlighter-rouge">Builder</code> had to be separate from <code class="highlighter-rouge">CanBuildFrom</code> because the latter
had to be stateless, with <code class="highlighter-rouge">Builder</code> needing to be stateful. Now that
both are stateless, the <code class="highlighter-rouge">FunBuilder</code> API can probably be collapsed
into <code class="highlighter-rouge">FunCanBuildFrom</code>.</p>

<p>This leaves the question, what about the mutable-state <code class="highlighter-rouge">Builder</code>s?
They can mutate the <code class="highlighter-rouge">S</code>, returning the input state from <code class="highlighter-rouge">+=</code> and
<code class="highlighter-rouge">++=</code>. You can’t use <code class="highlighter-rouge">S</code> values to rewind such a <code class="highlighter-rouge">FunBuilder</code>, but you
couldn’t before, anyway.</p>

<p>In the next part, “Avoiding refinement with dependent method types”,
we’ll look at the meaning of Scala’s “dependent method types” feature,
using it to replace some more type parameters with type members in
non-existential use cases.</p>

<p><em>This article was tested with Scala 2.11.8.</em></p>

<h2 id="appendix-final-funbuilder-examples">Appendix: final <code class="highlighter-rouge">FunBuilder</code> examples</h2>

<p>The rewrite from <code class="highlighter-rouge">S</code> type parameter to member in the <code class="highlighter-rouge">FunBuilder</code>
implementations is a boring, mechanical transform, but I’ve included
it here for easy reference.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">VectorBuilderList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
    <span class="nc">extends</span> <span class="nc">FunBuilder</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">S</span> <span class="o">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">init</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
  
  <span class="k">def</span> <span class="o">+=(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="n">elem</span> <span class="o">::</span> <span class="n">s</span>
  
  <span class="k">def</span> <span class="o">++=(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">elems</span><span class="k">:</span> <span class="kt">TraversableOnce</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span>
    <span class="n">elems</span><span class="o">.</span><span class="n">toList</span> <span class="n">reverse_:::</span> <span class="n">s</span>
  
  <span class="k">def</span> <span class="n">result</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">s</span><span class="o">.</span><span class="n">toVector</span><span class="o">.</span><span class="n">reverse</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">VectorBuilderListList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
    <span class="nc">extends</span> <span class="nc">FunBuilder</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">S</span> <span class="o">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Traversable</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>

  <span class="k">def</span> <span class="n">init</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
  
  <span class="k">def</span> <span class="o">+=(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span>
    <span class="nc">Traversable</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span> <span class="o">::</span> <span class="n">s</span>
    
  <span class="k">def</span> <span class="o">++=(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">elems</span><span class="k">:</span> <span class="kt">TraversableOnce</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span>
    <span class="n">elems</span><span class="o">.</span><span class="n">toTraversable</span> <span class="o">::</span> <span class="n">s</span>
    
  <span class="k">def</span> <span class="n">result</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">s</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="nc">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]()){(</span><span class="n">z</span><span class="o">,</span> <span class="n">as</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">as</span> <span class="o">++:</span> <span class="n">z</span><span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">VectorCBF</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">bulkOptimized</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">FunCanBuildFrom</span><span class="o">[</span><span class="kt">Any</span>, <span class="kt">A</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">()</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">bulkOptimized</span><span class="o">)</span>
      <span class="k">new</span> <span class="nc">VectorBuilderListList</span>
    <span class="k">else</span>
      <span class="k">new</span> <span class="nc">VectorBuilderList</span>
<span class="o">}</span>
</code></pre></div></div>

<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Tue, 10 May 2016 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2016/05/10/internal-state.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/05/10/internal-state.html</guid>
      </item>
    
      <item>
        <title>The Typelevel Summit in Boulder is Cancelled</title>
        
          <dc:creator>typelevel</dc:creator>
                
        <description><![CDATA[<p>As a result of
<a href="http://degoes.net/articles/lambdaconf-inclusion">LambdaConf’s decision</a>
to invite Curtis Yarvin as a speaker, the organizers of the Typelevel
Summit Boulder have decided that affiliation with LambdaConf is no
longer compatible with Typelevel’s goals, and we are cancelling the
event, which was scheduled to happen on the Wednesday before the
conference.</p>

<p>Yarvin is an unapologetic proponent of bigotry. As a result of his
modest celebrity in this regard, it is not possible for his views to
be “left at the door.” By extending a speaking invitation, LambdaConf
places him in a position of prestige and tacit endorsement that
Typelevel cannot accept.</p>

<p>We recognize LambdaConf’s goal of “harmony in diversity” and applaud
them for sharing their deliberations, but respectfully disagree with
the outcome.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 24 Mar 2016 00:00:00 +0100</pubDate>
        <link>https://typelevel.org/blog/2016/03/24/typelevel-boulder.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/03/24/typelevel-boulder.html</guid>
      </item>
    
      <item>
        <title>Information hiding, enforced</title>
        
          <dc:creator>adelbertc</dc:creator>
                
        <description><![CDATA[<p>Code should be reusable. An expression traversing a data structure
shouldn’t be written multiple times, it should be pulled out into a
generic traversal function. At a larger scale, a random number generator
shouldn’t be written multiple times, but rather pulled out into a
module that can be used by others.</p>

<p>It is important that such abstractions must be done carefully.
Often times a type is visible to the caller, and if the type
is not handled carefully the abstraction can leak.</p>

<p>For example, a set with fast random indexing (useful for random
walks on a graph) can be implemented with a sorted <code class="highlighter-rouge">Vector</code>.
However, if the <code class="highlighter-rouge">Vector</code> type is
leaked, the user can use this knowledge to violate the invariant.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.annotation.tailrec</span>

<span class="cm">/** (i in repr, position of i in repr) */</span>
<span class="k">def</span> <span class="n">binarySearch</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">repr</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="o">(</span><span class="kt">Boolean</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="cm">/* elided */</span>

<span class="k">object</span> <span class="nc">IntSet</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="nc">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">empty</span><span class="k">:</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="nc">Vector</span><span class="o">.</span><span class="n">empty</span>

  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">repr</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="o">(</span><span class="n">isMember</span><span class="o">,</span> <span class="n">indexOf</span><span class="o">)</span> <span class="k">=</span> <span class="n">binarySearch</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">repr</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isMember</span><span class="o">)</span> <span class="n">repr</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="k">val</span> <span class="o">(</span><span class="n">prefix</span><span class="o">,</span> <span class="n">suffix</span><span class="o">)</span> <span class="k">=</span> <span class="n">repr</span><span class="o">.</span><span class="n">splitAt</span><span class="o">(</span><span class="n">indexOf</span><span class="o">)</span>
      <span class="n">prefix</span> <span class="o">++</span> <span class="nc">Vector</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">++</span> <span class="n">suffix</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">contains</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">repr</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
    <span class="n">binarySearch</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">repr</span><span class="o">).</span><span class="n">_1</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">IntSet._</span>
<span class="c1">// import IntSet._
</span>
<span class="k">val</span> <span class="n">good</span> <span class="k">=</span> <span class="n">add</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">add</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">add</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="n">empty</span><span class="o">)))</span>
<span class="c1">// good: IntSet.Repr = Vector(1, 5, 10)
</span>
<span class="k">val</span> <span class="n">goodResult</span> <span class="k">=</span> <span class="n">contains</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">good</span><span class="o">)</span>
<span class="c1">// goodResult: Boolean = true
</span>
<span class="k">val</span> <span class="n">bad</span> <span class="k">=</span> <span class="n">good</span><span class="o">.</span><span class="n">reverse</span> <span class="c1">// We know it's a Vector!
// bad: scala.collection.immutable.Vector[Int] = Vector(10, 5, 1)
</span>
<span class="k">val</span> <span class="n">badResult</span> <span class="k">=</span> <span class="n">contains</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">bad</span><span class="o">)</span>
<span class="c1">// badResult: Boolean = false
</span>
<span class="k">val</span> <span class="n">bad2</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">// Alternatively..
// bad2: scala.collection.immutable.Vector[Int] = Vector(10, 5, 1)
</span>
<span class="k">val</span> <span class="n">badResult2</span> <span class="k">=</span> <span class="n">contains</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">bad2</span><span class="o">)</span>
<span class="c1">// badResult2: Boolean = false
</span></code></pre></div></div>

<p>The issue here is the user knows more about the representation than they
should. The function <code class="highlighter-rouge">add</code> enforces the sorted invariant on each insert,
and the function <code class="highlighter-rouge">contains</code> leverages this to do an efficient look-up.
Because the <code class="highlighter-rouge">Vector</code> definition of <code class="highlighter-rouge">Repr</code> is exposed, the user is
free to create any <code class="highlighter-rouge">Vector</code> they wish which may violate the invariant,
thus breaking <code class="highlighter-rouge">contains</code>.</p>

<p>In general, the <strong>name</strong> of the representation type is needed but the
<strong>definition</strong> is not. If the definition is hidden, the user is only able to
work with the type to the extent the module allows. This is precisely
the notion of information hiding. If this can be enforced by the type
system, modules can be swapped in and out without worrying about breaking
client code.</p>

<h1 id="quantification">Quantification</h1>
<p>It turns out there is a <a href="http://dl.acm.org/citation.cfm?id=6042" title="On understanding types, data abstraction, and polymorphism - Luca Cardelli, Peter Wegner">well understood principle</a>
behind this idea called <em>existential quantification</em>. Contrast with
universal quantification which says “for all”, existential quantification
says “there is a.”</p>

<p>Below is an encoding of universal quantification via parametric polymorphism.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Universal</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">A</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Here <code class="highlighter-rouge">Universal#apply</code> says <em>for all</em> choices of <code class="highlighter-rouge">A</code>, a function <code class="highlighter-rouge">A =&gt; A</code> can be
written. In the <a href="http://homepages.inf.ed.ac.uk/wadler/topics/history.html#propositions-as-types" title="Propositions as Types - Philip Wadler">Curry-Howard Isomorphism</a>, a profound
relationship between logic and computation, this translates to “for all propositions
<code class="highlighter-rouge">A</code>, <code class="highlighter-rouge">A</code> implies <code class="highlighter-rouge">A</code>.” It is therefore acceptable to write the following, which picks
<code class="highlighter-rouge">A</code> to be <code class="highlighter-rouge">Int</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">intInstantiatedU</span><span class="o">(</span><span class="n">u</span><span class="k">:</span> <span class="kt">Universal</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
<span class="c1">// intInstantiatedU: (u: Universal)Int =&gt; Int
</span></code></pre></div></div>

<p>Existential quantification can also be written in Scala.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Existential</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">A</span>

  <span class="k">def</span> <span class="n">apply</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">A</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note that this is just one way of encoding existentials - for a deeper
discussion, refer to the excellent <a href="/blog/2015/07/13/type-members-parameters.html" title="Type members are [almost] type parameters">Type Parameters and Type Members</a>
blog series.</p>

<p>The type parameter on <code class="highlighter-rouge">apply</code> has been moved up to a type member of the trait.
Practically, this means every instance of <code class="highlighter-rouge">Existential</code> must pick <strong>one</strong> choice of
<code class="highlighter-rouge">A</code>, whereas in <code class="highlighter-rouge">Universal</code> the <code class="highlighter-rouge">A</code> was parameterized and therefore free. In the
language of logic, <code class="highlighter-rouge">Existential#apply</code> says “there is a” or “there exists some <code class="highlighter-rouge">A</code> such that
<code class="highlighter-rouge">A</code> implies <code class="highlighter-rouge">A</code>.” This “there is a” is the crux of the error when trying
to write a corresponding <code class="highlighter-rouge">intExistential</code> function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">intInstantiatedE</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Existential</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
<span class="c1">// &lt;console&gt;:19: error: type mismatch;
//  found   : i.type (with underlying type Int)
//  required: e.A
//          (i: Int) =&gt; e.apply(i)
//                              ^
</span></code></pre></div></div>

<p>In code, the type in <code class="highlighter-rouge">Existential</code> is chosen per-instance, so there is no way
of knowing what the actual type chosen is. In logical terms, the only guarantee is
that there exists some proposition that satisfies the implication, but it is not
necessarily the case (and often is not) it holds for all propositions.</p>

<h1 id="abstract-types">Abstract types</h1>
<p>In the ML family of languages (e.g. Standard ML, OCaml), existential quantification
and thus information hiding, is achieved through <a href="http://dl.acm.org/citation.cfm?id=45065" title="Abstract types have existential type">type members</a>.
Programs are organized into <a href="https://realworldocaml.org/v1/en/html/files-modules-and-programs.html" title="Real World OCaml: Files, Modules, and Programs">modules</a> which are what contain these
types.</p>

<p>In Scala, this translates to organizing code with the object system, using the same
type member feature to hide representation. The earlier example of <code class="highlighter-rouge">IntSet</code> can then
be written:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** Abstract signature */</span>
<span class="k">trait</span> <span class="nc">IntSet</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Repr</span>

  <span class="k">def</span> <span class="n">empty</span><span class="k">:</span> <span class="kt">Repr</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">repr</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span>
  <span class="k">def</span> <span class="n">contains</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">repr</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="o">}</span>

<span class="cm">/** Concrete implementation */</span>
<span class="k">object</span> <span class="nc">VectorIntSet</span> <span class="k">extends</span> <span class="nc">IntSet</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="nc">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">empty</span><span class="k">:</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="nc">Vector</span><span class="o">.</span><span class="n">empty</span>

  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">repr</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="o">(</span><span class="n">isMember</span><span class="o">,</span> <span class="n">indexOf</span><span class="o">)</span> <span class="k">=</span> <span class="n">binarySearch</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">repr</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isMember</span><span class="o">)</span> <span class="n">repr</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="k">val</span> <span class="o">(</span><span class="n">prefix</span><span class="o">,</span> <span class="n">suffix</span><span class="o">)</span> <span class="k">=</span> <span class="n">repr</span><span class="o">.</span><span class="n">splitAt</span><span class="o">(</span><span class="n">indexOf</span><span class="o">)</span>
      <span class="n">prefix</span> <span class="o">++</span> <span class="nc">Vector</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">++</span> <span class="n">suffix</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">contains</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">repr</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
    <span class="n">binarySearch</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">repr</span><span class="o">).</span><span class="n">_1</span>
<span class="o">}</span>
</code></pre></div></div>

<p>As long as client code is written against the signature, the
representation cannot be leaked.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">goodUsage</span><span class="o">(</span><span class="n">set</span><span class="k">:</span> <span class="kt">IntSet</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">set._</span>
  <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="n">add</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">add</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">add</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="n">empty</span><span class="o">)))</span>
  <span class="n">contains</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// goodUsage: (set: IntSet)Boolean
</span></code></pre></div></div>

<p>If the user tries to assert the representation type, the type
checker prevents it <strong>at compile time</strong>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">badUsage</span><span class="o">(</span><span class="n">set</span><span class="k">:</span> <span class="kt">IntSet</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">set._</span>
  <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="n">add</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">add</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">empty</span><span class="o">))</span>

  <span class="c1">// Maybe it's a Vector
</span>  <span class="n">s</span><span class="o">.</span><span class="n">reverse</span>
  <span class="n">contains</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
<span class="o">}</span>
<span class="c1">// &lt;console&gt;:23: error: value reverse is not a member of set.Repr
//          s.reverse
//            ^
// &lt;console&gt;:24: error: type mismatch;
//  found   : scala.collection.immutable.Vector[Int]
//  required: set.Repr
//          contains(10, Vector(10, 5, 1))
//                             ^
</span></code></pre></div></div>

<h1 id="parametricity">Parametricity</h1>
<p>Abstract types enforce information hiding at the definition site (the definition
of <code class="highlighter-rouge">IntSet</code> is what hides <code class="highlighter-rouge">Repr</code>). There is another mechanism that enforces information
hiding, which pushes the constraint to the use site.</p>

<p>Consider implementing the following function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Given nothing is known about <code class="highlighter-rouge">a</code>, the only possible thing <code class="highlighter-rouge">foo</code> can do is return <code class="highlighter-rouge">a</code>. If
instead of a type parameter the function was given more information..</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">bar</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"not even going to use `a`"</span>
</code></pre></div></div>

<p>..that information can be leveraged to do unexpected things. This is similar to
the first <code class="highlighter-rouge">IntSet</code> example when knowledge of the underlying <code class="highlighter-rouge">Vector</code> allowed unintended
behavior to occur.</p>

<p>From the outside looking in, <code class="highlighter-rouge">foo</code> is universally quantified - the caller gets to
pick any <code class="highlighter-rouge">A</code> they want. From the inside looking out, it is
<a href="/blog/2016/01/28/existential-inside.html" title="It’s existential on the inside">existentially quantified</a> - the implementation knows only as much
about <code class="highlighter-rouge">A</code> as there are constraints on <code class="highlighter-rouge">A</code> (in this case, nothing).</p>

<p>Consider another function <code class="highlighter-rouge">listReplace</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">listReplace</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Given the type parameters, <code class="highlighter-rouge">listReplace</code> looks fairly constrained. The name and signature
suggests it takes each element of <code class="highlighter-rouge">as</code> and replaces it with <code class="highlighter-rouge">b</code>, returning a new list.
However, even knowledge of <code class="highlighter-rouge">List</code> can lead to type checking implementations with strange behavior.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Completely ignores the input parameters
</span><span class="k">def</span> <span class="n">listReplace</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</code></pre></div></div>

<p>Here, knowledge of <code class="highlighter-rouge">List</code> allows the implementation
to create a list out of thin air and use that in the implementation. If instead <code class="highlighter-rouge">listReplace</code>
only knew about some <code class="highlighter-rouge">F[_]</code> where <code class="highlighter-rouge">F</code> is a <code class="highlighter-rouge">Functor</code>, the implementation becomes much more
constrained.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">listFunctor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">List</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">List</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="n">fa</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="n">replace</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Functor</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">replace</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span> <span class="s">"typelevel"</span><span class="o">)</span>
<span class="c1">// res8: List[String] = List(typelevel, typelevel, typelevel)
</span></code></pre></div></div>

<p>Absent any knowledge of <code class="highlighter-rouge">F</code> other than the ability to <code class="highlighter-rouge">map</code> over it, <code class="highlighter-rouge">replace</code> is
forced to do the correct thing. Put differently, irrelevant information about <code class="highlighter-rouge">F</code> is hidden.</p>

<p>The fundamental idea behind this is known as parametricity, made popular by Philip Wadler’s
seminal <a href="http://dl.acm.org/citation.cfm?id=99404" title="Theorems for free!">Theorems for free!</a> paper. The technique is best summarized by the
following excerpt from the paper:</p>

<blockquote>
  <p>Write down the definition of a polymorphic function on a piece of paper. Tell me its type,
but be careful not to let me see the function’s definition. I will tell you a theorem that
the function satisfies.</p>
</blockquote>

<h1 id="why-types-matter">Why types matter</h1>
<p>Information hiding is a core tenet of good program design, and it is important to make
sure it is enforced. Underlying information hiding is existential quantification,
which can manifest itself in computation through abstract types and
parametricity. Few languages support defining abstract type members, and fewer
yet support higher-kinded types used in the <code class="highlighter-rouge">replace</code> example. It is therefore
to the extent that a language’s type system is expressive that
<a href="https://www.cis.upenn.edu/~bcpierce/tapl/" title="Types and Programming Languages - Benjamin C. Pierce">abstraction can be enforced</a>.</p>

<p><em>This blog post was tested with Scala 2.11.7 using <a href="https://github.com/tpolecat/tut" title="tut: doc/tutorial generator for scala">tut</a>.</em></p>

<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 13 Mar 2016 00:00:00 +0100</pubDate>
        <link>https://typelevel.org/blog/2016/03/13/information-hiding.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/03/13/information-hiding.html</guid>
      </item>
    
      <item>
        <title>Of variance and functors</title>
        
          <dc:creator>adelbertc</dc:creator>
                
        <description><![CDATA[<p>Scala’s type system allows us to annotate type parameters with their variance: covariant, contravariant, invariant.
Variance allows us to define the subtyping relationships between type constructors – that is, under which
conditions <code class="highlighter-rouge">F[A]</code> is a subtype of <code class="highlighter-rouge">F[B]</code>.</p>

<p>Similarly in functional programming, there are covariant functors, contravariant functors, and invariant functors. The
similarity in names is not coincidental.</p>

<h1 id="covariance">Covariance</h1>
<p>The common example is <code class="highlighter-rouge">List[+A]</code> which is covariant in its type parameter, denoted by the <code class="highlighter-rouge">+</code> next to the <code class="highlighter-rouge">A</code>.
A type constructor with a covariant type parameter means that if there is a subtyping relationship between the
type parameter, there is a subtyping relationship between the two instances of the type constructor.
For example if we have a <code class="highlighter-rouge">List[Circle]</code>, we can substitute it anywhere we have a <code class="highlighter-rouge">List[Shape]</code>.</p>

<h2 id="read">Read</h2>
<p>Another example of covariance is in parsing, for example in the following <code class="highlighter-rouge">Read</code> type class.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Read</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">read</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>It makes sense to make <code class="highlighter-rouge">Read</code> covariant because if we can read a subtype, then we can read the supertype by
reading the subtype and throwing away the subtype-specific information. For instance, if we can read a
<code class="highlighter-rouge">Circle</code>, we can read a valid <code class="highlighter-rouge">Shape</code> by reading the <code class="highlighter-rouge">Circle</code> and ignoring any <code class="highlighter-rouge">Circle</code>-specific information.</p>

<h2 id="array">Array</h2>
<p>A type that cannot safely be made covariant is <code class="highlighter-rouge">Array</code>. If <code class="highlighter-rouge">Array</code> were covariant, we could substitute
an <code class="highlighter-rouge">Array[Circle]</code> for an <code class="highlighter-rouge">Array[Shape]</code>. This can get us in a nasty situation.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">circles</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Circle</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="mi">10</span><span class="o">)(</span><span class="nc">Circle</span><span class="o">(..))</span>
<span class="k">val</span> <span class="n">shapes</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Shape</span><span class="o">]</span> <span class="k">=</span> <span class="n">circles</span> <span class="c1">// works only if Array is covariant
</span><span class="n">shapes</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Square</span><span class="o">(..)</span> <span class="c1">// Square is a subtype of Shape
</span></code></pre></div></div>

<p>If <code class="highlighter-rouge">Array</code> was covariant this would compile fine, but fail at runtime. In fact, Java arrays are
covariant and so the analogous Java code would compile, throwing an <code class="highlighter-rouge">ArrayStoreException</code> when
run. The compiler accepts this because it is valid to upcast an <code class="highlighter-rouge">Array[Circle]</code> into an <code class="highlighter-rouge">Array[Shape]</code>,
and it is valid to insert a <code class="highlighter-rouge">Shape</code> into an <code class="highlighter-rouge">Array[Shape]</code>. However the runtime representation of
<code class="highlighter-rouge">shapes</code> is still an <code class="highlighter-rouge">Array[Circle]</code> and inserting a <code class="highlighter-rouge">Square</code> into that isn’t allowed.</p>

<h2 id="read-only-and-covariance">Read-only and covariance</h2>
<p>In general, a type can be made safely covariant if it is read-only. If we know how to read a specific type, we know
how to read a more general type by throwing away any extra information. <code class="highlighter-rouge">List</code> is safe to to make
covariant because it is immutable and we can only ever read information off of it. With <code class="highlighter-rouge">Array</code>, we
cannot make it covariant because we are able to write to it.</p>

<h2 id="functor">Functor</h2>
<p>As we’ve just seen, covariance states that when <code class="highlighter-rouge">A</code> subtypes <code class="highlighter-rouge">B</code>, then <code class="highlighter-rouge">F[A]</code> subtypes <code class="highlighter-rouge">F[B]</code>. Put differently,
if <code class="highlighter-rouge">A</code> can be turned into a <code class="highlighter-rouge">B</code>, then <code class="highlighter-rouge">F[A]</code> can be turned into an <code class="highlighter-rouge">F[B]</code>. We can encode this behavior
literally in the notion of a <code class="highlighter-rouge">Functor</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This is often encoded slightly differently by changing the order of the arguments:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We can implement <code class="highlighter-rouge">Functor</code> for <code class="highlighter-rouge">List</code> and <code class="highlighter-rouge">Read</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">listFunctor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">List</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">List</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">fa</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="nc">Nil</span>
      <span class="k">case</span> <span class="n">a</span> <span class="o">::</span> <span class="n">as</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">::</span> <span class="n">map</span><span class="o">(</span><span class="n">as</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="k">val</span> <span class="n">readFunctor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">Read</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">Read</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Read</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Read</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="k">new</span> <span class="nc">Read</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="n">read</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
          <span class="n">fa</span><span class="o">.</span><span class="n">read</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
            <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">None</span>
            <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
          <span class="o">}</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>With that we can do useful things like</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">circles</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Circle</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Circle</span><span class="o">(..),</span> <span class="nc">Circle</span><span class="o">(..))</span>
<span class="k">val</span> <span class="n">shapes</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Shape</span><span class="o">]</span> <span class="k">=</span> <span class="n">listFunctor</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">circles</span><span class="o">)(</span><span class="n">circle</span> <span class="k">=&gt;</span> <span class="n">circle</span><span class="k">:</span> <span class="kt">Shape</span><span class="o">)</span> <span class="c1">// upcast
</span>
<span class="k">val</span> <span class="n">parseCircle</span><span class="k">:</span> <span class="kt">Read</span><span class="o">[</span><span class="kt">Circle</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="n">parseShape</span><span class="k">:</span> <span class="kt">Read</span><span class="o">[</span><span class="kt">Shape</span><span class="o">]</span> <span class="k">=</span> <span class="n">readFunctor</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">parseCircle</span><span class="o">)(</span><span class="n">circle</span> <span class="k">=&gt;</span> <span class="n">circle</span><span class="k">:</span> <span class="kt">Shape</span><span class="o">)</span> <span class="c1">// upcast
</span></code></pre></div></div>

<p>or more generally:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">upcast</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span> <span class="k">&lt;:</span> <span class="kt">A</span><span class="o">](</span><span class="n">functor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">functor</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">fb</span><span class="o">)(</span><span class="n">b</span> <span class="k">=&gt;</span> <span class="n">b</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">upcast</code>’s behavior does exactly what covariance does – given some supertype <code class="highlighter-rouge">A</code> (<code class="highlighter-rouge">Shape</code>) and a subtype <code class="highlighter-rouge">B</code> (<code class="highlighter-rouge">Circle</code>),
we can mechanically (and safely) turn an <code class="highlighter-rouge">F[B]</code> into an <code class="highlighter-rouge">F[A]</code>. Put differently, anywhere we expect an <code class="highlighter-rouge">F[A]</code> we can provide
an <code class="highlighter-rouge">F[B]</code>, i.e. covariance. For this reason, <code class="highlighter-rouge">Functor</code> is sometimes referred to in full as covariant functor.</p>

<h1 id="contravariance">Contravariance</h1>
<p>Contravariance flips the direction of the relationship in covariance – an <code class="highlighter-rouge">F[Shape]</code> is considered a
subtype of <code class="highlighter-rouge">F[Circle]</code>. This seems strange – when I was first learning about variance I couldn’t
come up with a situation where this would make sense.</p>

<p>If we have a <code class="highlighter-rouge">List[Shape]</code> we cannot safely treat it as a <code class="highlighter-rouge">List[Circle]</code> – doing so comes with all the usual
warnings about downcasting. Similarly if we have a <code class="highlighter-rouge">Read[Shape]</code>, we cannot treat it as a <code class="highlighter-rouge">Read[Circle]</code> –
we know how to parse a <code class="highlighter-rouge">Shape</code>, but we don’t know how to parse any additional information <code class="highlighter-rouge">Circle</code> may need.</p>

<h2 id="show">Show</h2>
<p>It appears fundamentally read-only types cannot be treated as contravariant. However, given that contravariance
is covariance with the direction reversed, can we also reverse the idea of a read-only type? Instead of reading
a value <em>from</em> a <code class="highlighter-rouge">String</code>, we can write a value <em>to</em> a <code class="highlighter-rouge">String</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Show</span><span class="o">[</span><span class="kt">-A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">show</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Show</code> is the other side of <code class="highlighter-rouge">Read</code> – instead of going from a <code class="highlighter-rouge">String</code> to an <code class="highlighter-rouge">A</code>, we go from an <code class="highlighter-rouge">A</code> into
a <code class="highlighter-rouge">String</code>. This reversal allows us to define contravariant behavior – if we are asked to provide a way
to show a <code class="highlighter-rouge">Circle</code> (<code class="highlighter-rouge">Show[Circle]</code>), we can give instead a way to show just a <code class="highlighter-rouge">Shape</code>. This is a valid
substitution because we can show a <code class="highlighter-rouge">Circle</code> by throwing away <code class="highlighter-rouge">Circle</code>-specific information and showing just
the <code class="highlighter-rouge">Shape</code> bits. This means that <code class="highlighter-rouge">Show[Shape]</code> is a subtype of <code class="highlighter-rouge">Show[Circle]</code>, despite <code class="highlighter-rouge">Circle</code> being a
subtype of <code class="highlighter-rouge">Shape</code>.</p>

<p>In general, we can show (or write) a subtype if we know how to show a supertype by tossing away subtype-specific
information (an upcast) and showing the remainder. Again, this means <code class="highlighter-rouge">Show[Supertype]</code> is substitutable, or a
subtype of, <code class="highlighter-rouge">Show[Subtype]</code>.</p>

<p>For similar reasons that read-only types can be made covariant, write-only types can be made contravariant.</p>

<h2 id="array-again">Array, again</h2>
<p><code class="highlighter-rouge">Array</code>s cannot be made contravariant either. If they were, we could do unsafe reads:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">shapes</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Shape</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="mi">10</span><span class="o">)(</span><span class="nc">Shape</span><span class="o">(..),</span> <span class="nc">Shape</span><span class="o">(..))</span>
<span class="k">val</span> <span class="n">circles</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Circle</span><span class="o">]</span> <span class="k">=</span> <span class="n">shapes</span> <span class="c1">// Works only if Array is contravariant
</span><span class="k">val</span> <span class="n">circle</span><span class="k">:</span> <span class="kt">Circle</span> <span class="o">=</span> <span class="n">circles</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">circle</code>, having been read from an <code class="highlighter-rouge">Array[Circle]</code> has type <code class="highlighter-rouge">Circle</code>. To the compiler this would be fine, but
at runtime, the underlying <code class="highlighter-rouge">Array[Shape]</code> may give us a <code class="highlighter-rouge">Shape</code> that is not a <code class="highlighter-rouge">Circle</code> and crash the program.</p>

<h2 id="contravariant">Contravariant</h2>
<p>Our <code class="highlighter-rouge">Functor</code> interface made explicit the behavior of covariance - we can define a similar interface that
captures contravariant behavior. If <code class="highlighter-rouge">B</code> can be used where <code class="highlighter-rouge">A</code> is expected, then <code class="highlighter-rouge">F[A]</code> can be used where an
<code class="highlighter-rouge">F[B]</code> is expected. To encode this explicitly:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Contravariant</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="c1">// Alternative encoding:
</span>  <span class="c1">// def contramap[A, B](f: B =&gt; A): F[A] =&gt; F[B]
</span>
  <span class="c1">// More typical encoding
</span>  <span class="k">def</span> <span class="n">contramap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We can implement an instance for <code class="highlighter-rouge">Show</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">showContravariant</span><span class="k">:</span> <span class="kt">Contravariant</span><span class="o">[</span><span class="kt">Show</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Contravariant</span><span class="o">[</span><span class="kt">Show</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">contramap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Show</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Show</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="k">new</span> <span class="nc">Show</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="n">show</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
          <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
          <span class="n">fa</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
        <span class="o">}</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Here we are saying if we can show an <code class="highlighter-rouge">A</code>, we can show a <code class="highlighter-rouge">B</code> by turning a <code class="highlighter-rouge">B</code> into an <code class="highlighter-rouge">A</code> before showing it.
Upcasting is a specific case of this, when <code class="highlighter-rouge">B</code> is a subtype of <code class="highlighter-rouge">A</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">contraUpcast</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">](</span><span class="n">contra</span><span class="k">:</span> <span class="kt">Contravariant</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">contra</span><span class="o">.</span><span class="n">contramap</span><span class="o">(</span><span class="n">fb</span><span class="o">)((</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span>
</code></pre></div></div>

<p>Going back to <code class="highlighter-rouge">Shape</code>s and <code class="highlighter-rouge">Circle</code>s, we can show a <code class="highlighter-rouge">Circle</code> by upcasting it into a <code class="highlighter-rouge">Shape</code> and showing that.</p>

<h1 id="function-variance">Function variance</h1>
<p>We observed that read-only types are covariant and write-only types are contravariant. This can be
seen in the context of functions and what function types are subtypes of others.</p>

<h2 id="parameters">Parameters</h2>
<p>An example function:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Right now we only care about the input
</span><span class="k">def</span> <span class="n">squiggle</span><span class="o">(</span><span class="n">circle</span><span class="k">:</span> <span class="kt">Circle</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">???</span>

<span class="c1">// or
</span>
<span class="k">val</span> <span class="n">squiggle</span><span class="k">:</span> <span class="kt">Circle</span> <span class="o">=&gt;</span> <span class="nc">Unit</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>What type is a valid subtype of <code class="highlighter-rouge">Circle =&gt; Unit</code>? An important note is we’re not
looking for what subtypes we can <em>pass in</em> to the function, we are looking for a value with a type
that satisfies the entirety of the function type <code class="highlighter-rouge">Circle =&gt; Unit</code>.</p>

<p>A first guess may involve some subtype of <code class="highlighter-rouge">Circle</code> like <code class="highlighter-rouge">Dot</code> (a circle with a radius of 0), such
as <code class="highlighter-rouge">Dot =&gt; Unit</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">squiggle</span><span class="k">:</span> <span class="kt">Circle</span> <span class="o">=&gt;</span> <span class="nc">Unit</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">d</span><span class="k">:</span> <span class="kt">Dot</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">someDotSpecificMethod</span><span class="o">()</span>
</code></pre></div></div>

<p>This doesn’t work – we are asserting with the moral equivalent of a downcast that any
<code class="highlighter-rouge">Circle</code> input to the function is a <code class="highlighter-rouge">Dot</code>, which is not safe to assume.</p>

<p>What if we used a supertype of <code class="highlighter-rouge">Circle</code>?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">squiggle</span><span class="k">:</span> <span class="kt">Circle</span> <span class="o">=&gt;</span> <span class="nc">Unit</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Shape</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">shapeshift</span><span class="o">()</span>
</code></pre></div></div>

<p>This is valid – from the outside looking in we have a function that takes a <code class="highlighter-rouge">Circle</code> and
returns <code class="highlighter-rouge">Unit</code>. Internally, we can take any <code class="highlighter-rouge">Circle</code>, upcast it into a <code class="highlighter-rouge">Shape</code>, and go from there.
Showing things a bit differently reveals better the relationship:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Input</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">A</span> <span class="k">=&gt;</span> <span class="nc">Unit</span>
<span class="k">val</span> <span class="n">inputSubtype</span><span class="k">:</span> <span class="kt">Input</span><span class="o">[</span><span class="kt">Shape</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Shape</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">shapeshift</span><span class="o">()</span>
<span class="k">val</span> <span class="n">input</span><span class="k">:</span> <span class="kt">Input</span><span class="o">[</span><span class="kt">Circle</span><span class="o">]</span> <span class="k">=</span> <span class="n">inputSubtype</span>
</code></pre></div></div>

<p>We have <code class="highlighter-rouge">Input[Shape] &lt;: Input[Circle]</code>, with <code class="highlighter-rouge">Circle &lt;: Shape</code>, so function parameters are contravariant.</p>

<p>The type checker enforces this when we try to use covariant type parameters in contravariant positions.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">trait</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span> <span class="k">def</span> <span class="n">foo</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">42</span> <span class="o">}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">15</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">covariant</span> <span class="k">type</span> <span class="kt">A</span> <span class="kt">occurs</span> <span class="kt">in</span> <span class="kt">contravariant</span> <span class="kt">position</span> <span class="kt">in</span> <span class="k">type</span> <span class="kt">A</span> <span class="kt">of</span> <span class="kt">value</span> <span class="kt">a</span>
       <span class="k">trait</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span> <span class="k">def</span> <span class="n">foo</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">42</span> <span class="o">}</span>
                               <span class="o">^</span>
</code></pre></div></div>

<p>Since type parameters are contravariant, a type in that position cannot also be covariant. To solve this
we “reverse” the constraint imposed by the covariant annotation by parameterizing with a supertype <code class="highlighter-rouge">B</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">trait</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span> <span class="o">{</span> <span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">42</span> <span class="o">}</span>
<span class="n">defined</span> <span class="k">trait</span> <span class="nc">Foo</span>
</code></pre></div></div>

<h2 id="return">Return</h2>
<p>Let’s do the same exercise with function return types.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">squaggle</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=&gt;</span> <span class="nc">Shape</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Since using the supertype seemed to work with parameters, let’s pick a supertype here, <code class="highlighter-rouge">Object</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">squaggle</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=&gt;</span> <span class="nc">Shape</span> <span class="k">=</span>
  <span class="o">(</span><span class="k">_:</span> <span class="kt">Unit</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">somethingThatReturnsObject</span><span class="o">()</span>
</code></pre></div></div>

<p>For similar issues with using a subtype for the input parameter, we cannot use
a supertype for the output. The function type states the return type is <code class="highlighter-rouge">Shape</code>, but we’re
returning an <code class="highlighter-rouge">Object</code> which may or may not be a valid <code class="highlighter-rouge">Shape</code>. As far as the type checker is concerned,
this is invalid and the checker rejects the program.</p>

<p>Trying instead with a subtype:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">squaggle</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=&gt;</span> <span class="nc">Shape</span> <span class="k">=</span>
  <span class="o">(</span><span class="k">_:</span> <span class="kt">Unit</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Circle</span><span class="o">(..)</span>
</code></pre></div></div>

<p>This makes sense – the function type says it returns a <code class="highlighter-rouge">Shape</code> and inside we return a <code class="highlighter-rouge">Circle</code> which is
a perfectly valid <code class="highlighter-rouge">Shape</code>.</p>

<p>As before, rephrasing the type signatures leads to some insights.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Output</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Unit</span> <span class="k">=&gt;</span> <span class="n">A</span>
<span class="k">val</span> <span class="n">outputSubtype</span><span class="k">:</span> <span class="kt">Output</span><span class="o">[</span><span class="kt">Circle</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="k">_:</span> <span class="kt">Unit</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Circle</span><span class="o">(..)</span>
<span class="k">val</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Output</span><span class="o">[</span><span class="kt">Shape</span><span class="o">]</span> <span class="k">=</span> <span class="n">outputSubtype</span>
</code></pre></div></div>

<p>That is <code class="highlighter-rouge">Output[Circle] &lt;: Output[Shape]</code> with <code class="highlighter-rouge">Circle &lt;: Shape</code> – function return types are covariant.</p>

<p>Again the type checker will enforce this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">trait</span> <span class="nc">Bar</span><span class="o">[</span><span class="kt">-A</span><span class="o">]</span> <span class="o">{</span> <span class="k">def</span> <span class="n">bar</span><span class="o">()</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">???</span> <span class="o">}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">15</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">contravariant</span> <span class="k">type</span> <span class="kt">A</span> <span class="kt">occurs</span> <span class="kt">in</span> <span class="kt">covariant</span> <span class="kt">position</span> <span class="kt">in</span> <span class="k">type</span> <span class="o">()</span><span class="kt">A</span> <span class="kt">of</span> <span class="kt">method</span> <span class="kt">bar</span>
       <span class="k">trait</span> <span class="nc">Bar</span><span class="o">[</span><span class="kt">-A</span><span class="o">]</span> <span class="o">{</span> <span class="k">def</span> <span class="n">bar</span><span class="o">()</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">???</span> <span class="o">}</span>
                           <span class="o">^</span>
</code></pre></div></div>

<p>As before, we solve this by “reversing” the contraint imposed by the variance annotation.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">trait</span> <span class="nc">Bar</span><span class="o">[</span><span class="kt">-A</span><span class="o">]</span> <span class="o">{</span> <span class="k">def</span> <span class="n">bar</span><span class="o">[</span><span class="kt">B</span> <span class="k">&lt;:</span> <span class="kt">A</span><span class="o">]()</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> <span class="o">???</span> <span class="o">}</span>
<span class="n">defined</span> <span class="k">trait</span> <span class="nc">Bar</span>
</code></pre></div></div>

<h2 id="all-together-now">All together now</h2>
<p>Function inputs are contravariant and function outputs are covariant. Taking the previous examples together,
a function type <code class="highlighter-rouge">Shape =&gt; Circle</code> can be put in a place expecting a function type <code class="highlighter-rouge">Circle =&gt; Shape</code>.</p>

<p>We arrived at this conclusion by observing the behavior of subtype variance and the corresponding functors. Taken
in the context of functional programming where the only primitive is a function, we can draw a conclusion in
the other direction. Where function inputs are contravariant, types in positions where computations are
done (e.g. input or read-only positions) are also contravariant (similarly for covariance).</p>

<h1 id="invariance">Invariance</h1>
<p>Unannotated type parameters are considered invariant – the only relationship that holds is if a type <code class="highlighter-rouge">A</code>
is equal to a type <code class="highlighter-rouge">B</code>, then <code class="highlighter-rouge">F[A]</code> is equal to <code class="highlighter-rouge">F[B]</code>. Otherwise different instantiations of a
type constructor have no relationship with one another. Given invariant
<code class="highlighter-rouge">F[_]</code>, an <code class="highlighter-rouge">F[Circle]</code> is not a subtype of <code class="highlighter-rouge">F[Shape]</code> – you need to explicitly provide the conversion.</p>

<h2 id="array-once-more">Array once more</h2>
<p><code class="highlighter-rouge">Array</code>s are invariant in Scala because they can be neither covariant nor contravariant. If we make it
covariant, we can get unsafe writes. If we make it contravariant, we can get unsafe reads. Since
read-only types can only be covariant and write-only types contravariant, our compromise is to make
types that support both invariant.</p>

<p>In order to treat an <code class="highlighter-rouge">Array</code> of one type as an <code class="highlighter-rouge">Array</code> of another, we need to have conversions
in both directions. This must be provided manually as the type checker has no way of knowing what the
conversion would be.</p>

<h2 id="invariant">Invariant</h2>
<p>Similar to (covariant) <code class="highlighter-rouge">Functor</code> and <code class="highlighter-rouge">Contravariant</code>, we can write <code class="highlighter-rouge">Invariant</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Invariant</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">imap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>For demonstration purposes we write our own <code class="highlighter-rouge">Array</code> type</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">repr</span> <span class="k">=</span> <span class="nc">ListBuffer</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">read</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
    <span class="n">repr</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">write</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="n">repr</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="k">=</span> <span class="n">a</span>
<span class="o">}</span>
</code></pre></div></div>

<p>and define <code class="highlighter-rouge">Invariant[Array]</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">arrayInvariant</span><span class="k">:</span> <span class="kt">Invariant</span><span class="o">[</span><span class="kt">Array</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Invariant</span><span class="o">[</span><span class="kt">Array</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">imap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
        <span class="c1">// Convert read A to B before returning – covariance
</span>        <span class="k">override</span> <span class="k">def</span> <span class="n">read</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span>
          <span class="n">f</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">read</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>

        <span class="c1">// Convert B to A before writing – contravariance
</span>        <span class="k">override</span> <span class="k">def</span> <span class="n">write</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
          <span class="n">fa</span><span class="o">.</span><span class="n">write</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">g</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<h2 id="serialization">Serialization</h2>
<p>Another example of a read-write type that doesn’t involve <code class="highlighter-rouge">Array</code>s (or mutation) can be
found by just combining the <code class="highlighter-rouge">Read</code> and <code class="highlighter-rouge">Show</code> interfaces:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Serializer</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Read</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">with</span> <span class="nc">Show</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">read</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">show</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Serializer</code> both reads (from a <code class="highlighter-rouge">String</code>) and writes (to a <code class="highlighter-rouge">String</code>). We can’t make it
covariant because that would cause issues with <code class="highlighter-rouge">show</code>, and we can’t make it contravariant
because that would cause issues with <code class="highlighter-rouge">read</code>. Therefore our only choice is to keep it
invariant.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">serializerInvariant</span><span class="k">:</span> <span class="kt">Invariant</span><span class="o">[</span><span class="kt">Serializer</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Invariant</span><span class="o">[</span><span class="kt">Serializer</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">imap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Serializer</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Serializer</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="k">new</span> <span class="nc">Serializer</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="n">read</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">read</span><span class="o">(</span><span class="n">s</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
        <span class="k">def</span> <span class="n">show</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">fa</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">g</span><span class="o">(</span><span class="n">b</span><span class="o">))</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<h1 id="bringing-everything-together">Bringing everything together</h1>
<p>We can see the <code class="highlighter-rouge">Invariant</code> interface is more general than both <code class="highlighter-rouge">Functor</code> and <code class="highlighter-rouge">Contravariant</code> –
where <code class="highlighter-rouge">Invariant</code> requires functions going in both directions, <code class="highlighter-rouge">Functor</code> and <code class="highlighter-rouge">Contravariant</code> only
require one. We can make <code class="highlighter-rouge">Functor</code> and <code class="highlighter-rouge">Contravariant</code> subtypes of <code class="highlighter-rouge">Invariant</code> by ignoring
the direction we don’t care about.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Invariant</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">imap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Contravariant</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Invariant</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">contramap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">imap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">contramap</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">g</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Going back to treating <code class="highlighter-rouge">Array</code> and <code class="highlighter-rouge">Serializer</code> as a read/write store, if we make it read-only (like a read-only
handle on a resource) we can safely treat it as if it were covariant. If we are asked to read
<code class="highlighter-rouge">Shape</code>s and we know how to read <code class="highlighter-rouge">Circle</code>s, we can read a <code class="highlighter-rouge">Circle</code> and upcast it into a <code class="highlighter-rouge">Shape</code>
before handing it over.</p>

<p>Similarly if we make it write-only (like a write-only handle on a resource) we can safely treat
it as contravariant. If we are asked to store <code class="highlighter-rouge">Circle</code>s and we know how to store <code class="highlighter-rouge">Shape</code>s,
we can upcast each <code class="highlighter-rouge">Circle</code> into a <code class="highlighter-rouge">Shape</code> before storing it.</p>

<p>Variance manifests in two levels: one at the type level where subtyping relationships are defined, and
the other at the value level where it is encoded as an interface which certain types can conform to.</p>

<h2 id="one-more-thing">One more thing</h2>
<p>Thus far we have seen the three kinds of variances Scala supports:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">1.</span> <span class="n">invariance</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">B</span> <span class="o">→</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="mf">2.</span> <span class="n">covariance</span><span class="k">:</span> <span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">B</span> <span class="kt">→</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">&lt;:</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="mf">3.</span> <span class="n">contravariance</span><span class="k">:</span> <span class="kt">A</span> <span class="k">&gt;:</span> <span class="kt">B</span> <span class="kt">→</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">&lt;:</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</code></pre></div></div>

<p>This gives us the following graph:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   invariance
     ↑   ↑
    /      \
   -        +
</code></pre></div></div>

<p>Completing the diamond implies a fourth kind of variance, one that takes contravariance and
covariance together. This is known as phantom variance or anyvariance, a variance with no constraints on the
type parameters: <code class="highlighter-rouge">F[A] = F[B]</code> regardless of what <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code> are. Unfortunately Scala’s type system is
missing this kind of variance which leaves us just short of a nice diamond, but we can still encode it
in an interface.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Phantom</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">pmap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Given any <code class="highlighter-rouge">F[A]</code>, we can turn that into an <code class="highlighter-rouge">F[B]</code>, for all choices of <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code>. With this power we can
implement covariant and contravariant functors.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Phantom</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">with</span> <span class="nc">Contravariant</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">pmap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">pmap</span><span class="o">(</span><span class="n">fa</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">contramap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">pmap</span><span class="o">(</span><span class="n">fa</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This completes our diamond of variance.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   invariance
     ↑   ↑
    /      \
   -        +
   ↑        ↑
    \      /
    phantom
</code></pre></div></div>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 04 Feb 2016 00:00:00 +0100</pubDate>
        <link>https://typelevel.org/blog/2016/02/04/variance-and-functors.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/02/04/variance-and-functors.html</guid>
      </item>
    
      <item>
        <title>First batch of talks at the Philadelphia Summit</title>
        
          <dc:creator>larsrh</dc:creator>
                
        <description><![CDATA[<p>The work on the programme for the <a href="/event/2016-03-summit-philadelphia/">Philadelphia Summit</a> is in full swing!
As announced earlier, we’re happy to share with you the first batch of accepted talks.
Don’t worry though, there’s still time until the end of the week to <a href="http://goo.gl/forms/SX3plxsOKb">submit a proposal</a>.</p>

<h3 id="becoming-a-cats-person">Becoming a cat(s) person</h3>

<p>Want to contribute to Cats?
Let’s head over to the Cats Issues list and do some live coding!
Along the way we will see how the codebase is organized, the various bits of automation provided, and how you can use our various channels to get feedback on your work.</p>

<p><img src="/img/media/speakers/adelbertchang.jpeg" class="portrait" />
<em>Adelbert Chang is a Software Engineer at Box and a recent graduate from UC Santa Barbara where he studied Computer Science and researched graph querying and modeling. He enjoys helping with functional programming education and learning more about programming.</em>
<br style="clear: both;" /></p>

<h3 id="direct-syntax-for-monad-comprehensions">Direct syntax for monad comprehensions</h3>

<p>Easy, intuitive, direct-style syntax for monad comprehensions!
Like Scala <code class="highlighter-rouge">async</code> or SBT <code class="highlighter-rouge">.value</code>, but generalized to any monad.
Implemented, ready to be used and requiring only vanilla Scala 2.10/2.11 and blackbox macros.
Future extensions could include automatic use of Applicative where possible, support for more embedded control-flow operations, comprehensions over multiple compatible monads at once for user-defined notions of compatible and compiler tweaks for syntactic improvements.</p>

<p><img src="/img/media/speakers/chrisvogt.jpg" class="portrait" />
<em>Chris Vogt. Slick co-author, Compossible records author, frequent Scala conference/user group speaker, former member of Martin’s team at LAMP/EPFL, based in NYC, Senior Software Engineer at x.ai</em>
<br style="clear: both;" /></p>

<p><img src="/img/media/speakers/chrishodapp.jpg" class="portrait" />
<em>Chris Hodapp. Several-time Scala GSOC student and eventually mentor, author of the ill-fated Comprehensive Comprehensions project. He’s hoping to see tooling and techniques from the FP/Typelevel community improve the leverage of the average developer. Based in the SF Bay Area.</em>
<br style="clear: both;" /></p>

<h3 id="scala-exercises">Scala Exercises</h3>

<p>Scala Exercises is a web based community tool open sourced by 47 Degrees.
It contains multiple koan and free form style exercises maintained by library authors and maintainers to help you master some of the most important tools in the Scala Ecosystem.
Version 2 comes with a brand new backend and exercise tracking where you can login simply using your Github account and track your progress throughout exercises and libraries.
Version 2 will launch with exercises for the stdlib, Cats, Shapeless and other well known libraries and frameworks part of the Scala ecosystem.</p>

<p><img src="/img/media/speakers/raulraja.jpg" class="portrait" />
<em>Raul Raja. Functional programming enthusiast, CTO and Co-founder at 47 Degrees, a functional programming consultancy specialized in Scala.</em>
<br style="clear: both;" /></p>

<h3 id="probabilistic-programming-what-it-is-and-how-it-works">Probabilistic Programming: What It Is and How It Works</h3>

<p>Probabilistic programming is the other Big Thing to happen in machine learning alongside deep learning.
It is also closely tied to functional programming. In this talk I will explain the goals of probabilistic programming and how we can implement a probabilistic programming language in Scala.
Probabilistic models are one of the main approaches in machine learning.
Probabilistic programming aims to make expressive probabilistic models cheaper to develop.
This is achieved by expressing the model within an embedded DSL, and then compiling learning (inference) algorithms from the model description.
This automates one of the main tasks in building a probabilistic model, and provides the same benefits as a compiler for a traditional high-level language.
With the close tie of functional programming to mathematics, and the use of techniques like the free monad, functional programming languages are an ideal platform for embedding probabilistic programming.</p>

<p><img src="/img/media/speakers/noelwelsh.png" class="portrait" />
<em>Noel Welsh is a partner at Underscore, a consultancy that specializes in Scala. He’s been using Scala for 6 years in all sorts of applications. He’s the author of Advanced Scala, which is in the process of being rewritten to use Cats.</em>
<br style="clear: both;" /></p>

<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 28 Jan 2016 00:00:00 +0100</pubDate>
        <link>https://typelevel.org/blog/2016/01/28/summit_programme.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/01/28/summit_programme.html</guid>
      </item>
    
      <item>
        <title>It’s existential on the inside</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><em>This is the eighth of a series of articles on “Type Parameters and
Type Members”.  You may wish to
<a href="/blog/2015/07/13/type-members-parameters.html">check out the beginning</a>,
which introduces the <code class="highlighter-rouge">PList</code> type we refer to throughout this article
without further ado.</em></p>

<p>When you start working with type parameters, nothing makes it
immediately apparent that you are working with universal and
existential types at the same time. It is literally a matter of
perspective.</p>

<p>I will momentarily set aside a lengthy explanation of what this means,
in favor of some diagrams.</p>

<h2 id="universal-outside-existential-inside">Universal outside, existential inside</h2>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">fizzle</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">rec</span><span class="o">(</span><span class="n">pl</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">tl</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">tl</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">pl</span>
    <span class="k">case</span> <span class="nc">PCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">rec</span><span class="o">(</span><span class="nc">PCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">pl</span><span class="o">),</span> <span class="n">xs</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="n">xs</span> <span class="k">=&gt;</span> <span class="n">rec</span><span class="o">(</span><span class="nc">PNil</span><span class="o">(),</span> <span class="n">xs</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="/img/media/ieoti-fizzle.png" alt="Universal outside existential inside" /></p>

<p>The caller can select any <code class="highlighter-rouge">A</code>, but the implementation must work with
whatever <code class="highlighter-rouge">A</code> the caller chooses. So <code class="highlighter-rouge">fizzle</code> is universal in <code class="highlighter-rouge">A</code> from
the outside, but existential in <code class="highlighter-rouge">A</code> from the inside.</p>

<p>So what happens when the caller and callee ‘trade places’?</p>

<h2 id="existential-outside-universal-inside">Existential outside, universal inside</h2>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">wazzle</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">PList</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">n</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">PCons</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="nc">PNil</span><span class="o">())</span>
       <span class="k">else</span> <span class="nc">PCons</span><span class="o">(</span><span class="s">"hi"</span><span class="o">,</span> <span class="nc">PNil</span><span class="o">())</span>
</code></pre></div></div>

<p><img src="/img/media/ieoti-wazzle.png" alt="Existential outside universal inside" /></p>

<p>Now the implementation gets to choose an <code class="highlighter-rouge">A</code>, and the caller must work
with whatever <code class="highlighter-rouge">A</code> the implementation chooses. So <code class="highlighter-rouge">wazzle</code> is universal
in <code class="highlighter-rouge">A</code> from the inside, but existential in <code class="highlighter-rouge">A</code> from the outside.</p>

<p>A good way to think about these two, <code class="highlighter-rouge">fizzle</code> and <code class="highlighter-rouge">wazzle</code>, is that
<code class="highlighter-rouge">fizzle</code> takes a type <em>argument</em> from the caller, but <code class="highlighter-rouge">wazzle</code>
<em>returns</em> a type (alongside the list) to the caller.</p>

<h2 id="universal--outside-existential-inside">Universal (!) outside, existential inside</h2>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">duzzle</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
  <span class="k">case</span> <span class="nc">PCons</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">duzzle</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">duzzle2</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
  <span class="k">case</span> <span class="nc">PCons</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">duzzle2</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="/img/media/ieoti-duzzle.png" alt="Universal outside existential inside" /></p>

<p><code class="highlighter-rouge">wazzle</code> “returns” a type, alongside the list, because the existential
appears as part of the return type. However, <code class="highlighter-rouge">duzzle2</code> places the
existential in argument position. So, as with all type-parameterized
cases, <code class="highlighter-rouge">duzzle</code> among them, this is one where the caller determines
the type.</p>

<p>We’ve <a href="/blog/2015/07/16/method-equiv.html">discussed</a> how you can
prove that <code class="highlighter-rouge">duzzle</code> ≡<em><sub><small>m</small></sub></em> <code class="highlighter-rouge">duzzle2</code>, in a
previous post. Now, it’s time to see why.</p>

<h2 id="type-parameters-are-parameters">Type parameters are parameters</h2>

<p>The caller chooses the value of a type parameter. It also chooses the
value of normal parameters. So, it makes sense to treat them the same.</p>

<p>Let’s try to look at <code class="highlighter-rouge">fizzle</code>’s type this way.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<h2 id="existential-types-are-pairs">Existential types are pairs</h2>

<p>If <code class="highlighter-rouge">wazzle</code> returns a type and a value, it makes sense to treat them
as a returned pair.</p>

<p>Let’s look at <code class="highlighter-rouge">wazzle</code>’s type this way.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Int</span> <span class="k">=&gt;</span> <span class="o">([</span><span class="kt">A</span><span class="o">],</span> <span class="nc">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
</code></pre></div></div>

<p>This corresponds exactly to the <code class="highlighter-rouge">forSome</code> scope
<a href="/blog/2015/07/27/nested-existentials.html">we have explored previously</a>.
So we can interpret <code class="highlighter-rouge">PList[PList[_]]</code> as follows.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">PList</span><span class="o">[</span><span class="kt">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">forSome</span> <span class="o">{</span><span class="k">type</span> <span class="kt">A</span><span class="o">}]</span>  <span class="c1">// explicitly scoped
</span><span class="nc">PList</span><span class="o">[([</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">])]</span>            <span class="c1">// “paired”
</span></code></pre></div></div>

<h2 id="the-duzzles-are-currying">The <code class="highlighter-rouge">duzzle</code>s are currying</h2>

<p>With these two models, we can finally get to the bottom of
<code class="highlighter-rouge">duzzle</code> ≡<em><sub><small>m</small></sub></em> <code class="highlighter-rouge">duzzle2</code>. Here are their
types, rewritten in the forms we’ve just seen.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Int</span>
<span class="o">([</span><span class="kt">A</span><span class="o">],</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">Int</span>
</code></pre></div></div>

<p>Recognize that? They’re just the curried and uncurried forms of the
same function type.</p>

<p>You can also see why the same type change will not work for <code class="highlighter-rouge">wazzle</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Int</span> <span class="k">=&gt;</span> <span class="o">([</span><span class="kt">A</span><span class="o">],</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
<span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>We’ve moved part of the return type into an argument, which is…not the
same.</p>

<h2 id="the-future-of-types">The future of types?</h2>

<p>This formulation of universal and existential types is due to
dependently-typed systems, in which they are “dependent functions” and
“dependent pairs”, respectively, though with significantly more
expressive power than we’re working with here. They come by way of the
description of the Quest programming language in
<a href="http://www.lucacardelli.name/Papers/TypefulProg.pdf">“Typeful Programming” by Luca Cardelli</a>,
which shows in a clear, syntactic way that the dependent view of
universal and existential types is perfectly cromulent to
non-dependent type systems like Scala’s.</p>

<p>It is also the root of my frustration that Scala doesn’t support a
<code class="highlighter-rouge">forAll</code>, like <code class="highlighter-rouge">forSome</code> but for universally-quantified types. After
all, you can’t work with one without the other.</p>

<p>Now we have enough groundwork for
<a href="/blog/2016/05/10/internal-state.html">“Making internal state functional”</a>,
the next part of this series. I suspect it will be a little prosaic at
this point, though.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 28 Jan 2016 00:00:00 +0100</pubDate>
        <link>https://typelevel.org/blog/2016/01/28/existential-inside.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/01/28/existential-inside.html</guid>
      </item>
    
      <item>
        <title>Keynote at the Philadelphia Summit</title>
        
          <dc:creator>larsrh</dc:creator>
                
        <description><![CDATA[<p>While the CfP for the <a href="/event/2016-03-summit-philadelphia/">Philadelphia Summit</a> is still open (<a href="http://goo.gl/forms/SX3plxsOKb">have you submitted a proposal yet?</a>), we can already announce our keynote speaker:</p>

<p><img src="/img/media/speakers/sweirich.jpg" style="float: right; width: 30%; margin-left: 1em;" />
Stephanie Weirich is a Professor at the University of Pennsylvania. Her research centers on programming languages, type theory and machine-assisted reasoning. In particular, she studies generic programming, metaprogramming, dependent type systems, and type inference in the context of functional programming languages. She is currently an Editor of the Journal of Functional Programming and served as the program chair for ICFP in 2010 and the Haskell Symposium in 2009.</p>

<p><br style="clear: both;" /></p>

<p>Stephanie will join the Summit on March 2nd to talk about <em>Dependently-Typed Haskell</em>.
We hope this will give us an exciting opportunity to exchange knowledge between the Haskell and Scala communities.</p>

<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 20 Jan 2016 00:00:00 +0100</pubDate>
        <link>https://typelevel.org/blog/2016/01/20/summit_keynote.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/01/20/summit_keynote.html</guid>
      </item>
    
      <item>
        <title>Assistance and Bursaries for the Typelevel Summits</title>
        
          <dc:creator>davegurnell</dc:creator>
                
        <description><![CDATA[<p><em>Update: The summits are over, which means applying for assistance is not possible any longer.</em></p>

<p>As it says in our <a href="/conduct.html">code of conduct</a>, we are dedicated to creating a harrassment-free, inclusive community of developers. We want to extend this philosophy to the Typelevel Summits in <a href="/event/2016-03-summit-philadelphia/">Philadelphia</a> and <a href="/event/2016-05-summit-oslo/">Oslo</a> by providing assistance and bursaries to help speakers and attendees who would otherwise not be able to join us.</p>

<h3 id="bursaries-for-speakers-and-attendees">Bursaries for Speakers and Attendees</h3>

<p>We are approaching sponsors and commercial partners to arrange bursaries for conference registration, travel and accommodation. Everyone is welcome to apply. However, note that we may not be able to provide funding in all cases.</p>

<h3 id="speaker-assistance-help-with-talk-proposals">Speaker Assistance: Help with Talk Proposals</h3>

<p>Many people don’t submit talk proposals to conferences because they can’t think of something to say or don’t think their ideas are interesting.</p>

<p>We are offering feedback and suggestions on talk proposals to anyone who requests it. Hopefully we can help you turn a rough idea into a compelling abstract to submit alongside abstracts from other potential speakers.</p>

<p>Asking us for help won’t guarantee you a slot in the programme, but it will give you an idea for a talk that would compete against the other submissions.</p>

<p>If you have a good talk idea but for some reason it doesn’t make it into the conference, we will help you find another conference or meetup group for your first public speaking experience.</p>

<h3 id="speaker-assistance-speaker-training">Speaker Assistance: Speaker Training</h3>

<p>Many people are concerned or nervous about public speaking. We are offering free workshops to provide newer speakers with advice for tech speaking, whether your abstract is accepted or not.</p>

<p>Given the international nature of the Summits, we probably won’t be able to organise face-to-face workshops. We will deliver the workshops over Google Hangouts to reach as many attendees as possible.</p>

<h3 id="speaker-assistance-help-with-talk-writing">Speaker Assistance: Help with Talk Writing</h3>

<p>If your abstract is accepted to the conference, we are offering free mentoring services to provide advice and feedback as you turn your abstract into a talk.</p>

<p>We will assign a mentor to each participating speaker. Your mentor will be available to act as a sounding board as your talk develops from an outline to a fully formed presentation.</p>

<h3 id="sound-interesting">Sound Interesting?</h3>

<p>If you are planning on attending or speaking in Philadelphia or Oslo, and you would like to apply for any of the services above, please please fill out the application form linked at the top of the page.</p>

<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 14 Jan 2016 00:00:00 +0100</pubDate>
        <link>https://typelevel.org/blog/2016/01/14/summit_assistance.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2016/01/14/summit_assistance.html</guid>
      </item>
    
      <item>
        <title>Announcement: Typelevel Summits coming up in 2016</title>
        
          <dc:creator>larsrh</dc:creator>
                
        <description><![CDATA[<p>We have a big announcement to make. In 2016, there will be not just one, but
two Typelevel Summits. Also, we’ve updated our website to include an up-to-date
list of Typelevel projects. There’s been much work behind the scenes which we
will talk about in a later post, so stay tuned!  But first, here are some
details about the Summits.</p>

<h3 id="typelevel-summit-us">Typelevel Summit US</h3>

<p>The first Typelevel Summit will be co-located with the Northeast Scala
Symposium in Philadelphia. As Brian Clapper already announced on Twitter, NE
Scala is going to happen on 4th and 5th of March with one day of recorded talks
and one day of unconference. Just today, we finalized the booking of the venue
and are happy to report that the Typelevel Summit will have the same format and
take place on 2nd and 3rd of March at the same venue (The Hub’s Cira Centre,
next to 30th Street Station).</p>

<h3 id="typelevel-summit-europe">Typelevel Summit Europe</h3>

<p>The second Typelevel Summit will be co-located with
<a href="http://2016.flatmap.no/">flatMap(Oslo)</a>. We will meet on the 4th of May after
the conference at the same venue (Teknologihuset). More details are to be
announced!</p>

<h3 id="call-for-speakers-attendance--faqs">Call for Speakers, Attendance, &amp; FAQs</h3>

<p>The planning phase is in full swing and we’ll announce more details soon.
Attendance will probably be limited to about 100. We’re also looking for
sponsors to help pay for the venue and cover other expenses. And we’re also
starting a diversity fund to support people from underrepresented groups, and
to mentor new speakers. If you want to contribute or have any other questions,
please contact us via <a href="mailto:info@typelevel.org">info@typelevel.org</a>.</p>

<p>The Summits are open to all, not just current contributors to and users of the
Typelevel projects, and we are especially keen to encourage participation from
people who are new to them. Whilst many of the Typelevel projects use somewhat
“advanced” Scala, they are a lot more approachable than many people think, and
a major part of Typelevel’s mission is to make the ideas they embody much more
widely accessible. So, if you’re interested in types and pure functional
programming, want to make those ideas commonplace and are willing to abide by
the Typelevel code of conduct, then the Summits are for you and we’d love to
see you there.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Fri, 11 Dec 2015 00:00:00 +0100</pubDate>
        <link>https://typelevel.org/blog/2015/12/11/announcement_summit.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2015/12/11/announcement_summit.html</guid>
      </item>
    
      <item>
        <title>To change types, change values</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><em>This is the seventh of a series of articles on “Type Parameters and
Type Members”.  You may wish to
<a href="/blog/2015/07/13/type-members-parameters.html">start at the beginning</a>;
more specifically, this post is meant as a followup to
<a href="/blog/2015/07/30/values-never-change-types.html">the previous entry</a>.
However, in a first for this series, it stands on its own, as
introductory matter.</em></p>

<p>A program is a system for converting data from one format to another,
which we have endowed with the color of magic.  In typed programming,
we use a constellation of types to mediate this transformation; a
function’s result can only be passed as another function’s argument to
the extent to which those parts of the functions’ types unify.</p>

<p>We rely on the richness of our types in these descriptions.  So it is
natural to want the types to change as you move to different parts of
the process; each change reflects the reality of what has just
happened.  For example, when you parse a string into an AST, your
program’s state has changed types, from <code class="highlighter-rouge">String</code> to <code class="highlighter-rouge">MyAST</code>.</p>

<p>But, as we have just seen, due to decisions we have made to simplify
our lives,
<a href="/blog/2015/07/30/values-never-change-types.html">values cannot change types</a>,
no matter how important it is to the sanity of our code.  At the same
time, we don’t want to give up the richness of using more than one
type to describe our data.</p>

<p>Fortunately, there is a solution that satisfies these competing
concerns: to change types, change values.  You can’t do anything about
the values you have, but you can create new ones of the right type,
and use those instead.</p>

<h2 id="type-changing-is-program-organization">Type-changing is program organization</h2>

<p>In values with complex construction semantics, it is common to write
imperative programs that leave “holes” in the data structures using
the terrible <code class="highlighter-rouge">null</code> misfeature of Java, Scala, and many other
languages.  This looks something like this.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Document</span><span class="o">(</span><span class="n">filename</span><span class="k">:</span> <span class="kt">Path</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// this structure has three parts:
</span>  <span class="k">var</span> <span class="n">text</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="kc">null</span> <span class="c1">// ← a body of text,
</span>  <span class="k">var</span> <span class="n">wordIndex</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="kc">null</span>
    <span class="c1">// ↑ an index of words to every
</span>    <span class="c1">// occurrence in the text,
</span>  <span class="k">var</span> <span class="n">mostPopular</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="kc">null</span>
    <span class="c1">// ↑ the most frequently used words
</span>    <span class="c1">// in the text, and their number of
</span>    <span class="c1">// occurrences
</span><span class="o">...</span>
</code></pre></div></div>

<p>Now, we must fill in these variables, by computing and assigning to
each in turn.  First, we compute the corpus text.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">initText</span><span class="o">()</span>
</code></pre></div></div>

<p>Then, we compute and fill in the word index.  If we didn’t fill in
<code class="highlighter-rouge">text</code> first, this compiles, but crashes at runtime.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">initWordIndex</span><span class="o">()</span>
</code></pre></div></div>

<p>Finally, we figure out which words are most popular.  If we didn’t
fill in <code class="highlighter-rouge">wordIndex</code> first, this compiles, but crashes.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">initMostPopular</span><span class="o">()</span>
</code></pre></div></div>

<p>How do I know that?  Well, I have to inspect the definitions of these
three methods.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="n">initText</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="n">text</span> <span class="k">=</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">filename</span><span class="o">.</span><span class="n">toFile</span><span class="o">).</span><span class="n">mkString</span>

  <span class="k">def</span> <span class="n">initWordIndex</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">words</span> <span class="k">=</span> <span class="s">"""\w+"""</span><span class="o">.</span><span class="n">r</span> <span class="n">findAllMatchIn</span> <span class="n">text</span>
    <span class="n">wordIndex</span> <span class="k">=</span> <span class="n">words</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]()){</span>
      <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">mtch</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="k">val</span> <span class="n">word</span> <span class="k">=</span> <span class="n">mtch</span><span class="o">.</span><span class="n">matched</span>
        <span class="k">val</span> <span class="n">idx</span> <span class="k">=</span> <span class="n">mtch</span><span class="o">.</span><span class="n">start</span>
        <span class="n">m</span> <span class="o">+</span> <span class="o">(</span><span class="n">word</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">idx</span> <span class="o">::</span> <span class="n">m</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)))</span>
      <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">initMostPopular</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="n">mostPopular</span> <span class="k">=</span> <span class="n">wordIndex</span><span class="o">.</span><span class="n">mapValues</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">size</span><span class="o">).</span><span class="n">toList</span>
      <span class="o">.</span><span class="n">sortBy</span><span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="mi">0</span> <span class="o">-</span> <span class="n">p</span><span class="o">.</span><span class="n">_2</span><span class="o">).</span><span class="n">take</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
</code></pre></div></div>

<p>This method of organizing object initialization is popular because,
among other properties:</p>

<ol>
  <li>it <em>seems</em> self-documenting,</li>
  <li>you don’t have to pass data around, and</li>
  <li>steps can be customized by subclassing and overriding.</li>
</ol>

<p>However!  It has the tremendous drawback of preventing the compiler
from helping you get the order of initialization correct.  Go, look;
see if you can spot why I said the latter two calls would crash if you
don’t get the order exactly right.  Now, I have four questions for
you.</p>

<ol>
  <li>Would you trust yourself to notice these implicit dependencies
every time you look at this code?</li>
  <li>Suppose you commented on the dependencies.  Would you trust these
comments to be updated when the initialization details change?</li>
  <li>Would you trust subclasses that customize the initialization to
respect the order in which we call these three <code class="highlighter-rouge">init</code> functions?</li>
  <li>Could you keep track of this if the initialization was
significantly more complex?  (This <em>is</em> a toy example for a blog
post, after all.)</li>
</ol>

<p>Ironically, as your initialization becomes more complex, the compiler
becomes less able to help you with uninitialized-variable warnings and
the like.  But, this is not the natural order of things; it is a
consequence of using imperative variable initialization but not
representing this
<a href="https://github.com/facebook/flow/releases/tag/v0.14.0">variable refinement</a>
in the type system.  By initializing in a different way, we can
recover type safety.</p>

<div class="side-note">
  The implications of refinement, linked above, are much less severe
  than those of unrestricted type-changing of a variable.  So Flow did
  not solve, nor did it aim to solve, those difficulties by
  introducing the refinement feature.
</div>

<h2 id="the-four-types-of-document">The four types of <code class="highlighter-rouge">Document</code></h2>

<p>If we consider <code class="highlighter-rouge">Document</code> as the simple product of its three state
variables, with some special functions associated with them as
whatever <code class="highlighter-rouge">Document</code> methods we intend to support, we have a simple
3-tuple.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]],</span>
 <span class="nc">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)])</span>
</code></pre></div></div>

<p>Let us no longer pretend that it is any more complicated than that.</p>

<p>But this cannot be mutated to fill these in as they are initialized,
you say!  Yes, that’s right, we want a <em>type-changing</em> transformation.
By <em>changing values</em>, this is easy.  There are three phases of
initialization, so four states, including uninitialized.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Path</span>
<span class="nc">String</span>
<span class="o">(</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]])</span>
<span class="o">(</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]],</span> <span class="nc">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)])</span>
</code></pre></div></div>

<p>For interesting phases, such as the final one, we might create a <code class="highlighter-rouge">case
class</code> to hold its contents, instead.  Let us call that class, for
this example, <code class="highlighter-rouge">Doc</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Doc</span>
  <span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">wordIndex</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]],</span>
   <span class="n">mostPopular</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)])</span>
</code></pre></div></div>

<p>Finally, we can build 3 functions to take us through these steps.
Each begins by taking one as an argument, and produces the next state
as a return type.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="n">initText</span><span class="o">(</span><span class="n">filename</span><span class="k">:</span> <span class="kt">Path</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
    <span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">filename</span><span class="o">.</span><span class="n">toFile</span><span class="o">).</span><span class="n">mkString</span>

  <span class="k">def</span> <span class="n">initWordIndex</span><span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">words</span> <span class="k">=</span> <span class="s">"""\w+"""</span><span class="o">.</span><span class="n">r</span> <span class="n">findAllMatchIn</span> <span class="n">text</span>
    <span class="o">(</span><span class="n">text</span><span class="o">,</span> <span class="n">words</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]()){</span>
       <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">mtch</span><span class="o">)</span> <span class="k">=&gt;</span>
       <span class="k">val</span> <span class="n">word</span> <span class="k">=</span> <span class="n">mtch</span><span class="o">.</span><span class="n">matched</span>
       <span class="k">val</span> <span class="n">idx</span> <span class="k">=</span> <span class="n">mtch</span><span class="o">.</span><span class="n">start</span>
       <span class="n">m</span> <span class="o">+</span> <span class="o">(</span><span class="n">word</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">idx</span> <span class="o">::</span> <span class="n">m</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)))</span>
     <span class="o">})</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">initMostPopular</span><span class="o">(</span><span class="n">twi</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]))</span><span class="k">:</span> <span class="kt">Doc</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="o">(</span><span class="n">text</span><span class="o">,</span> <span class="n">wordIndex</span><span class="o">)</span> <span class="k">=</span> <span class="n">twi</span>
    <span class="nc">Doc</span><span class="o">(</span><span class="n">text</span><span class="o">,</span> <span class="n">wordIndex</span><span class="o">,</span>
        <span class="n">wordIndex</span><span class="o">.</span><span class="n">mapValues</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">size</span><span class="o">).</span><span class="n">toList</span>
          <span class="o">.</span><span class="n">sortBy</span><span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="mi">0</span> <span class="o">-</span> <span class="n">p</span><span class="o">.</span><span class="n">_2</span><span class="o">).</span><span class="n">take</span><span class="o">(</span><span class="mi">10</span><span class="o">))</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>If we have a <code class="highlighter-rouge">Path</code>, we can get a <code class="highlighter-rouge">Doc</code> by <code class="highlighter-rouge">(initText _) andThen
initWordIndex andThen initMostPopular: Path =&gt; Doc</code>.  But that hardly
replicates the rich runtime behavior of our imperative version, does
it?  That is, we can do reordering of operations in a larger context
with <code class="highlighter-rouge">Document</code>, but not <code class="highlighter-rouge">Doc</code>.  Let us see what that means.</p>

<h2 id="many-docs">Many docs</h2>

<p>Dealing with one document in isolation is one thing, but suppose we
have a structure of <code class="highlighter-rouge">Document</code>s.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">DocumentTree</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">SingleDocument</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">doc</span><span class="k">:</span> <span class="kt">Document</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">DocumentTree</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">DocumentCategory</span>
  <span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">members</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">DocumentTree</span><span class="o">])</span>
  <span class="k">extends</span> <span class="nc">DocumentTree</span>
</code></pre></div></div>

<p>In the imperative mode, we can batch and reorder initialization.  Say,
for example, we don’t initialize <code class="highlighter-rouge">Document</code> when we create it.  This
tree then contains <code class="highlighter-rouge">Document</code>s that contain only <code class="highlighter-rouge">Path</code>s.  We can walk
the tree, doing step 1 for every <code class="highlighter-rouge">Document</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// add this to DocumentTree
</span>  <span class="k">def</span> <span class="n">foreach</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Document</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">SingleDocument</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">d</span><span class="o">)</span>
      <span class="k">case</span> <span class="nc">DocumentCategory</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">dts</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">dts</span> <span class="n">foreach</span> <span class="o">(</span><span class="k">_</span> <span class="n">foreach</span> <span class="n">f</span><span class="o">)</span>
    <span class="o">}</span>

<span class="c1">// now we can initialize the text everywhere,
// given some dtree: DocumentTree
</span><span class="n">dtree</span> <span class="n">foreach</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">initText</span><span class="o">())</span>
</code></pre></div></div>

<p>The way software does, it got more complex.  And we can be ever less
sure that we’re doing things right, under this arrangement.</p>

<h2 id="the-four-phases-problem-stuck-in-a-tree">The four phases problem, stuck in a tree</h2>

<p>Our tree only supports one type of document.  We could choose the
final one, <code class="highlighter-rouge">Doc</code>, but there is no way to replicate more exotic
document tree initializations like the one above.</p>

<p>Instead, we want the type of the tree to adapt along with the document
changes.  If we have four states, <em>Foo</em>, <em>Bar</em>, <em>Baz</em>, and <em>Quux</em>, we
want four different kinds of <code class="highlighter-rouge">DocumentTree</code> to go along with them.  In
a language with type parameters, this is easy: we can model those four
as <code class="highlighter-rouge">DocTree[Foo]</code>, <code class="highlighter-rouge">DocTree[Bar]</code>, <code class="highlighter-rouge">DocTree[Baz]</code>, and
<code class="highlighter-rouge">DocTree[Quux]</code>, respectively, by adding a type parameter.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span>
<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">SingleDoc</span><span class="o">[</span><span class="kt">D</span><span class="o">](</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">doc</span><span class="k">:</span> <span class="kt">D</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">DocCategory</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span>
  <span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">members</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">]])</span>
  <span class="k">extends</span> <span class="nc">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span>
</code></pre></div></div>

<p>Now we need a replacement for the <code class="highlighter-rouge">foreach</code> that we used with the
unparameterized <code class="highlighter-rouge">DocumentTree</code> to perform each initialization step on
every <code class="highlighter-rouge">Document</code> therein.  Now that <code class="highlighter-rouge">DocTree</code> is agnostic with respect
to the specific document type, this is a little more abstract, but
quite idiomatic.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// add this to DocTree
</span>  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">D2</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">D</span> <span class="o">=&gt;</span> <span class="n">D2</span><span class="o">)</span><span class="k">:</span> <span class="kt">DocTree</span><span class="o">[</span><span class="kt">D2</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">SingleDoc</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">SingleDoc</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">d</span><span class="o">))</span>
      <span class="k">case</span> <span class="nc">DocCategory</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">dts</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nc">DocCategory</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">dts</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="n">map</span> <span class="n">f</span><span class="o">))</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>It’s worth comparing these side by side.  Now we should be able to
step through initialization of <code class="highlighter-rouge">DocTree</code> with <code class="highlighter-rouge">map</code>, just as with
<code class="highlighter-rouge">DocumentTree</code> and <code class="highlighter-rouge">foreach</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">dtp</span><span class="k">:</span> <span class="kt">DocTree</span><span class="o">[</span><span class="kt">Path</span><span class="o">]</span> <span class="k">=</span> <span class="nc">DocCategory</span><span class="o">(</span><span class="s">"rt"</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="nc">SingleDoc</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="nc">Paths</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"hello.md"</span><span class="o">))))</span>
<span class="n">dtp</span><span class="k">:</span> <span class="kt">tmtp7.DocTree</span><span class="o">[</span><span class="kt">java.nio.file.Path</span><span class="o">]</span> <span class="k">=</span> <span class="nc">DocCategory</span><span class="o">(</span><span class="n">rt</span><span class="o">,</span><span class="nc">List</span><span class="o">(</span><span class="nc">SingleDoc</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span><span class="n">hello</span><span class="o">.</span><span class="n">md</span><span class="o">)))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">dtp</span> <span class="n">map</span> <span class="nc">Doc</span><span class="o">.</span><span class="n">initText</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">tmtp7.DocTree</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">DocCategory</span><span class="o">(</span><span class="n">rt</span><span class="o">,</span><span class="nc">List</span><span class="o">(</span><span class="nc">SingleDoc</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span><span class="n">contents</span> <span class="n">of</span> <span class="n">the</span> <span class="n">hello</span><span class="o">.</span><span class="n">md</span> <span class="n">file</span><span class="o">!)))</span>
</code></pre></div></div>

<h2 id="you-wouldnt-avoid-writing-functions-would-you">You wouldn’t avoid writing functions, would you?</h2>

<p>There is nothing magical about <code class="highlighter-rouge">DocTree</code> that makes it especially
amenable to the introduction of a type parameter.  This is <em>not</em> a
feature whose proper use is limited to highly abstract or
general-purpose data structures; with its <code class="highlighter-rouge">String</code>s and <code class="highlighter-rouge">Int</code>s strewn
about, it is <em>utterly</em> domain-specific, “business” code.</p>

<p>In fact, if we were likely to annotate <code class="highlighter-rouge">Doc</code>s with more data, <code class="highlighter-rouge">Doc</code>
would be a perfect place to add a type parameter!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// suppose we add some "extra" data
</span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Doc</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">wordIndex</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]],</span>
   <span class="n">mostPopular</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)],</span>
   <span class="n">extra</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span>
</code></pre></div></div>

<p>You can use a type parameter to represent one simple slot in an
otherwise concretely specified structure, as above.  You can
<a href="https://bitbucket.org/ermine-language/ermine-writers/src/9ec9a98c30bc9924cc49888895f8832e8ce4f8e1/writers/html/src/main/scala/com/clarifi/reporting/writers/HTMLDeps.scala?at=default#HTMLDeps.scala-37">use one to represent 10 slots</a>.</p>

<p>Parameterized types are the type system’s version of functions.  They
aren’t just for collections, abstract code, or highly general-purpose
libraries: they’re for <em>your</em> code!</p>

<p>Unless you are going to suggest that <em>functions</em> are “too academic”.
Or that functions have no place in “business logic”.  Or perhaps that,
while it would be nice to define functions to solve this, that, and
sundry, you’ll just do the quick no-defining-functions hack for now
and maybe come back to add some functions later when “paying off
technical debt”.  <em>Then</em>, I’m not sure what to say.</p>

<h2 id="the-virtuous-circle-of-fp-and-types">The virtuous circle of FP and types</h2>

<p>Now we are doing something very close to functional programming.
Moreover, we were led here not by a desire for referential
transparency, nor for purity, but merely for a way to represent the
states of our program in a more well-typed way.</p>

<p>In this series of posts, I have deliberately avoided discussion of
functional programming until this section; my chosen subject is types,
not functional programming.  But the features we have been considering
unavoidably coalesce here into an empirical argument for functional
programming.  Type parameters let us elegantly lift transformations
from one part of our program to another; the intractable complexities
of imperative type-changing direct us to program more functionally, by
computing new values instead of changing old ones, if we want access
to these features.  This, in turn, encourages ever more of our program
to be written in a functional style, just as the switch to different
<code class="highlighter-rouge">Doc</code> representations induced a switch to different document tree
representations, <code class="highlighter-rouge">map</code> instead of <code class="highlighter-rouge">foreach</code>.</p>

<h2 id="paying-it-back">Paying it Back</h2>

<p>Likewise, the use of functional programming style feeds back, in the
aforementioned virtuous circle, to encourage the use of stronger
types.</p>

<p>When we wanted stronger guarantees about the initialization of our
documents, and thereby also of the larger structures incorporating
them, we turned to the most powerful tool we have at our disposal for
describing and ensuring such guarantees: the type system.  In so
doing, we induced an explosion of explicit data representations; where
we had two, we now have eight, whose connections to each other are
mediated by the types of functions involved.</p>

<p>With the increase in the number of explicit concepts in the code comes
a greater need for an automatic method of keeping track of all these
connections.  The type system is ideally suited to this role.</p>

<div class="side-note">
  We induced more <em>explicit</em> data representation, not more
  representations overall.  The imperative <code>Document</code> has
  four stages of initialization, at each of which it exhibits
  different behavior.  All we have done is expose this fact to the
  type system level, at which our usage can be checked.
</div>

<h2 id="dont-miss-one">Don’t miss one!</h2>

<p>As it is declared, the type-changing <code class="highlighter-rouge">DocTree#map</code> has another
wonderful advantage over <code class="highlighter-rouge">DocumentTree#foreach</code>.</p>

<p>Let us say that each category should also have a document of its own,
not just a list of subtrees.  In refactoring, we adjust the
definitions of <code class="highlighter-rouge">DocumentCategory</code> or <code class="highlighter-rouge">DocCategory</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// imperative version
</span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">DocumentCategory</span>
  <span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">doc</span><span class="k">:</span> <span class="kt">Document</span><span class="o">,</span>
   <span class="n">members</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">DocumentTree</span><span class="o">])</span>
   <span class="k">extends</span> <span class="nc">DocumentTree</span>

<span class="c1">// functional version
</span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">DocCategory</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span>
  <span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">doc</span><span class="k">:</span> <span class="kt">D</span><span class="o">,</span>
   <span class="n">members</span><span class="k">:</span> <span class="kt">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">])</span>
  <span class="k">extends</span> <span class="nc">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span>
</code></pre></div></div>

<p>So far, so good.  Next, neither <code class="highlighter-rouge">foreach</code> nor <code class="highlighter-rouge">map</code> compile anymore.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TmTp7.scala:70: wrong number of arguments for pattern
⤹ tmtp7.DocumentCategory(name: String,doc: tmtp7.Document,
⤹                        members: List[tmtp7.DocumentTree])
      case DocumentCategory(_, dts) =&gt;
                           ^
TmTp7.scala:71: not found: value d
        f(d)
          ^
TmTp7.scala:91: wrong number of arguments for pattern
⤹ tmtp7.DocCategory[D](name: String,doc: D,members: List[tmtp7.DocTree[D]])
      case DocCategory(c, dts) =&gt;
                      ^
TmTp7.scala:92: not enough arguments for method
⤹ apply: (name: String, doc: D, members: List[tmtp7.DocTree[D]]
⤹        )tmtp7.DocCategory[D] in object DocCategory.
Unspecified value parameter members.
        DocCategory(c, dts map (_ map f))
                   ^
</code></pre></div></div>

<p>So let us fix <code class="highlighter-rouge">foreach</code> in the simplest way possible.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//                 added ↓
</span>    <span class="k">case</span> <span class="nc">DocumentCategory</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">dts</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span>
</code></pre></div></div>

<p>This compiles.  It is wrong, and we can figure out exactly why by
trying the same shortcut with <code class="highlighter-rouge">map</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="k">case</span> <span class="nc">DocCategory</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">dts</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nc">DocCategory</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">dts</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="n">map</span> <span class="n">f</span><span class="o">))</span>
</code></pre></div></div>

<p>We are treating the <code class="highlighter-rouge">d: D</code> like the <code class="highlighter-rouge">name: String</code>, just passing it
through.  It is “ignored” in precisely the same way as the <code class="highlighter-rouge">foreach</code>
ignores the new data.  But this version does not compile!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TmTp7</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">90</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">d.</span><span class="k">type</span> <span class="o">(</span><span class="kt">with</span> <span class="kt">underlying</span> <span class="k">type</span> <span class="kt">D</span><span class="o">)</span>
 <span class="kt">required:</span> <span class="kt">D2</span>
        <span class="nc">DocCategory</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">dts</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="n">map</span> <span class="n">f</span><span class="o">))</span>
                       <span class="o">^</span>
</code></pre></div></div>

<p>More broadly, <code class="highlighter-rouge">map</code> must return a <code class="highlighter-rouge">DocTree[D2]</code>.  By implication, the
second argument must be a <code class="highlighter-rouge">D2</code>, not a <code class="highlighter-rouge">D</code>.  We can fix it by using
<code class="highlighter-rouge">f</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="nc">DocCategory</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">d</span><span class="o">),</span> <span class="n">dts</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="n">map</span> <span class="n">f</span><span class="o">))</span>
</code></pre></div></div>

<p>Likewise, we should make a similar fix to <code class="highlighter-rouge">DocumentTree#foreach</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">case</span> <span class="nc">DocumentCategory</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">dts</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">f</span><span class="o">(</span><span class="n">d</span><span class="o">)</span>
      <span class="n">dts</span> <span class="n">foreach</span> <span class="o">(</span><span class="k">_</span> <span class="n">foreach</span> <span class="n">f</span><span class="o">)</span>
</code></pre></div></div>

<p>But only in the case of <code class="highlighter-rouge">map</code> did we get help from the compiler.
That’s because <code class="highlighter-rouge">DocumentTree</code> is not the only thing to gain a type
parameter in this new design.  When we made <code class="highlighter-rouge">DocTree</code> take one, it was
only natural to define <code class="highlighter-rouge">map</code> with one, too.</p>

<p>We can see how this works out by looking at both <code class="highlighter-rouge">foreach</code> and <code class="highlighter-rouge">map</code>
as the agents of our practical goal: transformation of the tree by
transforming the documents therein.  <code class="highlighter-rouge">foreach</code> works like this.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              document transformer
               (Document =&gt; Unit)
 DocumentTree ~~~~~~~~~~~~~~~~~~~&gt; DocumentTree
 ------------                      -----------------
initial state                      final state
  (old tree)                       (same type, “new”
                                    but same tree)
</code></pre></div></div>

<p>The way <code class="highlighter-rouge">map</code> looks at <code class="highlighter-rouge">DocTree</code> is very similar, and we give it the
responsibilities that <code class="highlighter-rouge">foreach</code> had, so it is unsurprising that the
“shape” we imagine for transformation is similar.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>               document transformer
                    (D =&gt; D2)
    DocTree[D] ~~~~~~~~~~~~~~~~~~~~&gt; DocTree[D2]
 -------------                       ----------------
 initial state                       final state
  (old tree)                         (changed type,
                                      changed value!)
</code></pre></div></div>

<p>The replacement of <code class="highlighter-rouge">D</code> with <code class="highlighter-rouge">D2</code> also means that values of type <code class="highlighter-rouge">D</code>
cannot occur anywhere in the result, as <code class="highlighter-rouge">D</code> is abstract, so only
appears as <code class="highlighter-rouge">doc</code> by virtue of being the type parameter passed to
<code class="highlighter-rouge">DocTree</code> and its data constructors (er, “subclasses”).</p>

<p>As our result type is <code class="highlighter-rouge">DocTree[D2]</code>, we have two options, considering
only the result type:</p>

<ol>
  <li>return a <code class="highlighter-rouge">DocTree</code> with no <code class="highlighter-rouge">D2</code>s in its representation, one role of
<code class="highlighter-rouge">None</code> and <code class="highlighter-rouge">Nil</code> in <code class="highlighter-rouge">Option</code> and <code class="highlighter-rouge">List</code> respectively, or</li>
  <li>make <code class="highlighter-rouge">D2</code>s from the <code class="highlighter-rouge">D</code>s in the <code class="highlighter-rouge">DocTree[D]</code> we have in hand, by
passing them to the ‘document transformer’ <code class="highlighter-rouge">D =&gt; D2</code>.</li>
</ol>

<p>Similarly, no <code class="highlighter-rouge">DocTree[D]</code> values can appear anywhere in the result.
As with the <code class="highlighter-rouge">D</code>s, they must all be transformed or dropped, with a
different ‘empty’ <code class="highlighter-rouge">DocTree</code> chosen.</p>

<h2 id="the-dangers-of-simplifying">The dangers of “simplifying”</h2>

<p>Suppose we instead defined <code class="highlighter-rouge">map</code> as follows.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">D</span> <span class="o">=&gt;</span> <span class="n">D</span><span class="o">)</span><span class="k">:</span> <span class="kt">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span>
</code></pre></div></div>

<p>If you subscribe to the idea of type parameters being for wonky
academics, this is “simpler”.  And it’s fine, I suppose, if you only
have one <code class="highlighter-rouge">D</code> in mind, one document type in mind.  Setting aside that
we have four, there is another problem.  Let’s take a look at the
“shape” of this transformation.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>               document transformer
                     (D =&gt; D)
    DocTree[D] ~~~~~~~~~~~~~~~~~~~~&gt; DocTree[D]
 -------------                       ----------------
 initial state                       final state
  (old tree)                         (but no promise,
                                      same type!)
</code></pre></div></div>

<p>The problem with a <code class="highlighter-rouge">D =&gt; D</code> transformer is that we can’t make promises
that all our data passed through it.  After all, a source <code class="highlighter-rouge">d</code> has the
same type as <code class="highlighter-rouge">f(d)</code>.  We could even get away with</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">D</span> <span class="o">=&gt;</span> <span class="n">D</span><span class="o">)</span><span class="k">:</span> <span class="kt">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">map[D2]</code> is strictly more general.  <strong>Even if we have only one <code class="highlighter-rouge">D</code> in
mind for <code class="highlighter-rouge">DocTree</code>, it still pays to type-parameterize it and to add
‘type-changing’ extra type parameters like <code class="highlighter-rouge">D2</code>.</strong></p>

<h2 id="the-dangers-of-missing-values">The dangers of missing values</h2>

<p>Have you ever started getting a new bill, then missed a payment
because you thought you were covered for the month?</p>

<p>Have you ever gone on vacation and, in your relief at having not left
anything important at home, left something behind when packing for
your return trip?</p>

<p>This kind of thing cannot be characterized in the manner of “well, I
would just get a runtime error if I didn’t have a type checker, so
it’s fine.”  Yet it simply falls out of the system we have chosen;
moreover, we have barely begun to consider the possibilities.</p>

<p>In this series, I have focused on existential types, which we can in
one sense consider merely abstract types that the compiler checks that
we treat as independent, like <code class="highlighter-rouge">D</code> and <code class="highlighter-rouge">D2</code>.  Existential types are
only one natural outcome of the system of type abstraction brought to
us by type parameters; there are many more interesting conclusions,
like the ones described above.</p>

<p>Next, in
<a href="/blog/2016/01/28/existential-inside.html">“It’s existential on the inside”</a>,
we will see how deeply intertwined universal and existential types
really are.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Mon, 21 Sep 2015 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2015/09/21/change-values.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2015/09/21/change-values.html</guid>
      </item>
    
      <item>
        <title>Symbolic operators and type classes for Cats</title>
        
          <dc:creator>non</dc:creator>
                
        <description><![CDATA[<p>This post is an introduction into how operators are implemented in Cats and has been originally published in <a href="https://gist.github.com/non/3abdb35a72c39276d3d9">August 2015</a>.
Some more details can be found in the <a href="/blog/2015/08/06/machinist.html">previous post</a>.</p>

<p>One of the simplest and most recognizable type classes is the semigroup.
This type class abstracts over the ability to combine values of a certain
type in an associative manner.</p>

<div class="side-note">
  What does <em>associativity</em> mean?
  We call an operation $\oplus$ associative, if for all $a$, $b$ and $c$, $a \oplus (b \oplus c) = (a \oplus b) \oplus c$ holds.
  Read more about this in the <a href="https://github.com/non/algebra#algebraic-properties-and-terminology">README of the algebra repository</a>.
</div>

<p>Cats provides <code class="highlighter-rouge">cats.Semigroup[A]</code> to model semigroups.
The <code class="highlighter-rouge">combine</code> method takes two values of the type <code class="highlighter-rouge">A</code> and returns an <code class="highlighter-rouge">A</code> value.</p>

<p>In addition, Cats defines syntax allowing the binary operator <code class="highlighter-rouge">|+|</code> to be
used in place of the <code class="highlighter-rouge">combine</code> method.</p>

<h2 id="small-example">Small example</h2>

<p>Here is a small method that provides a generic way to combine the elements
of a list:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Semigroup</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">def</span> <span class="n">gsum</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Semigroup</span><span class="o">](</span><span class="n">values</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">values</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="nc">None</span> <span class="k">else</span> <span class="nc">Some</span><span class="o">(</span><span class="n">values</span><span class="o">.</span><span class="n">reduceLeft</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">|+|</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div></div>

<p>(A similar method is built into Cats as <code class="highlighter-rouge">Semigroup.combineAllOption</code>.)</p>

<h2 id="how-does-it-work">How does it work?</h2>

<p>One of the parts of <code class="highlighter-rouge">gsum</code> that might be hard to understand is where
the <code class="highlighter-rouge">|+|</code> method comes from. Since <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> are totally generic values
(of type <code class="highlighter-rouge">A</code>) how can we call a method on them?</p>

<p>To boil the example down further, consider this simpler example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.implicits._</span>
<span class="mi">19</span> <span class="o">|+|</span> <span class="mi">20</span> <span class="c1">// produces 39
</span></code></pre></div></div>

<p>How does this work? We know that the <code class="highlighter-rouge">Int</code> type does not have a <code class="highlighter-rouge">|+|</code> method.
Experienced Scala developers will suspect that implicits play a role here,
but what are the details?</p>

<h2 id="in-detail">In detail</h2>

<p>Let’s walk through how the expression <code class="highlighter-rouge">19 |+| 20</code> is compiled.</p>

<p>First, a <code class="highlighter-rouge">|+|</code> method is needed on <code class="highlighter-rouge">Int</code>. Since
<a href="https://github.com/scala/scala/blob/v2.11.7/src/library/scala/Int.scala"><code class="highlighter-rouge">Int</code></a>
does not provide one, the compiler searches for an implicit conversion to a
type that <em>does</em> have a <code class="highlighter-rouge">|+|</code> method.</p>

<p>Due to our import, it will find the
<a href="https://github.com/non/cats/blob/82dbf4076572dfbb6e29dd49875f5e5d929f80be/core/src/main/scala/cats/syntax/semigroup.scala#L8"><code class="highlighter-rouge">semigroupSyntax[A]</code></a>
method, which returns a type that has a <code class="highlighter-rouge">|+|</code> method (specifically
<a href="https://github.com/non/cats/blob/82dbf4076572dfbb6e29dd49875f5e5d929f80be/core/src/main/scala/cats/syntax/semigroup.scala#L12"><code class="highlighter-rouge">SemigroupOps[A]</code></a>).
However, <code class="highlighter-rouge">semigroupSyntax</code> requires an implicit <code class="highlighter-rouge">Semigroup[A]</code> value to be in scope.
Do we have a <code class="highlighter-rouge">Semigroup[Int]</code> in scope?</p>

<p>Yes we do. Our import also provides an implicit value <a href="https://github.com/non/cats/blob/82dbf4076572dfbb6e29dd49875f5e5d929f80be/std/src/main/scala/cats/std/anyval.scala#L23"><code class="highlighter-rouge">intGroup</code></a>
of type <code class="highlighter-rouge">AdditiveCommutativeGroup[Int]</code>. Leaving aside what <em>additive</em>, <em>commutative</em>,
and <em>group</em> mean here, this is a subtype of <code class="highlighter-rouge">Semigroup[Int]</code>, so it matches.</p>

<p>Let’s continue with our current example. At this point we have gone from:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">19</span> <span class="o">|+|</span> <span class="mi">20</span> <span class="c1">// produces 39
</span></code></pre></div></div>

<p>to:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">semigroupSyntax</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">19</span><span class="o">)(</span><span class="n">intGroup</span><span class="o">)</span> <span class="o">|+|</span> <span class="mi">20</span>
</code></pre></div></div>

<p>But we aren’t out of the woods yet! We still need to see how this expression
is evaluated.</p>

<h2 id="of-macros-and-machinists">Of macros and machinists</h2>

<p>Looking at how the <code class="highlighter-rouge">|+|</code> method is
<a href="https://github.com/non/cats/blob/82dbf4076572dfbb6e29dd49875f5e5d929f80be/core/src/main/scala/cats/syntax/semigroup.scala#L13">implemented</a>
reveals the cryptic <code class="highlighter-rouge">macro Ops.binop[A, A]</code>. What is this?</p>

<p>Following the rabbit hole farther, we come to
<a href="https://github.com/non/cats/blob/82dbf4076572dfbb6e29dd49875f5e5d929f80be/macros/src/main/scala/cats/macros/Ops.scala#L6"><code class="highlighter-rouge">cats.macros.Ops</code></a>
which provides the macro implementation that <code class="highlighter-rouge">|+|</code> is using. Aside from a
<a href="https://github.com/non/cats/blob/82dbf4076572dfbb6e29dd49875f5e5d929f80be/macros/src/main/scala/cats/macros/Ops.scala#L18">suggestively named</a>
item in the <code class="highlighter-rouge">operatorNames</code> map, we don’t have any clues what is going on.</p>

<p>The <a href="https://github.com/typelevel/machinist">machinist</a> project was created
to optimize exactly this kind of implicit syntax problem. What will happen here
is that <code class="highlighter-rouge">operatorNames</code> describes how to rewrite expressions using type
classes. Long-story short, we will transform:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">semigroupSyntax</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">19</span><span class="o">)(</span><span class="n">intGroup</span><span class="o">)</span> <span class="o">|+|</span> <span class="mi">20</span>
</code></pre></div></div>

<p>into:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">intGroup</span><span class="o">.</span><span class="n">combine</span><span class="o">(</span><span class="mi">19</span><span class="o">,</span> <span class="mi">20</span><span class="o">)</span>
</code></pre></div></div>

<p>The aforementioned suggestive map item tells us that we should rewrite the <code class="highlighter-rouge">|+|</code> operator
to method calls on the given type class (i.e. <code class="highlighter-rouge">intGroup</code>) using <code class="highlighter-rouge">.combine</code>.</p>

<h2 id="finishing-up">Finishing up</h2>

<p>Just to confirm that we’re done, let’s look at what <code class="highlighter-rouge">intGroup.combine</code> will do.
We started with a call to <code class="highlighter-rouge">AdditiveCommutativeGroup[Int]</code>, which will find
<a href="https://github.com/non/algebra/blob/v0.3.1/std/shared/src/main/scala/algebra/std/int.scala#L12"><code class="highlighter-rouge">intAlgebra</code></a>.
Then we call the <a href="https://github.com/non/algebra/blob/v0.3.1/core/src/main/scala/algebra/ring/Additive.scala#L93"><code class="highlighter-rouge">.additive</code></a>
method on it to produce a <code class="highlighter-rouge">CommutativeGroup[Int]</code>.</p>

<p>So putting that together, we can see that calling <code class="highlighter-rouge">intGroup.combine(19, 20)</code>
will call <code class="highlighter-rouge">intAlgebra.plus(19, 20)</code>, and that this is defined as <code class="highlighter-rouge">19 + 20</code>,
as we would expect.</p>

<p>Whew!</p>

<h2 id="conclusion">Conclusion</h2>

<p>This is a lot of machinery. The incredibly terse and expressive syntax it
enables is quite nice, but you can see that even leaving out one import
will cause the whole edifice to come tumbling down.</p>

<p>The easiest way to use Cats is to just import <code class="highlighter-rouge">cats.implicits._</code>. That
way, you can be sure that you have all of it. There are individual imports
from <code class="highlighter-rouge">cats.syntax</code> and <code class="highlighter-rouge">cats.std</code> which can be used to pinpoint the exact
values and method you want to put into scope, but getting these right
can be a bit tricky, especially for newcomers.</p>

<p>Some more examples of Machinist can be found in the <a href="https://github.com/typelevel/machinist/blob/v0.4.1/README.md#examples">README</a>.</p>

<h2 id="errata">Errata</h2>

<p>You may also decide that the syntax convenience is not worth it. To write our
original example without syntax implicits (but still using implicit values)
you could say:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Semigroup</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">def</span> <span class="n">gsum</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">values</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">s</span><span class="k">:</span> <span class="kt">Semigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">values</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="nc">None</span> <span class="k">else</span> <span class="nc">Some</span><span class="o">(</span><span class="n">values</span><span class="o">.</span><span class="n">reduceLeft</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">combine</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)))</span>

<span class="c1">// values.reduceLeft(s.combine) would also work
</span></code></pre></div></div>

<p>Whether to use syntax implicits or explicit method calls is mostly a matter
of preference. Personally, I like using syntax explicits to help make generic
code read in a clearer manner, but as always, your mileage may vary.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Fri, 07 Aug 2015 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2015/08/07/symbolic-operators.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2015/08/07/symbolic-operators.html</guid>
      </item>
    
      <item>
        <title>Machinist vs. value classes</title>
        
          <dc:creator>non</dc:creator>
                
        <description><![CDATA[<p>This article is about <a href="https://github.com/typelevel/machinist">machinist</a>, a stand-alone project which started out as part of the <a href="https://github.com/non/spire">spire</a> project and has been originally published in <a href="https://gist.github.com/non/a6ff3c0796e566db20d1">October 2014</a>.
The original description can be found on <a href="/blog/2013/10/13/spires-ops-macros.html">this blog</a>.
You should read that linked post first if you are not familiar with how Machinist works.</p>

<h2 id="introduction">Introduction</h2>

<p><a href="https://github.com/typelevel/machinist/issues/2">Machinist Issue #2</a> asks:</p>

<blockquote>
  <p>Is it correct, that this stuff is completely obsolete now due to
value classes or are there still some use cases? An example of using
value class for zero-cost implicit enrichment: […]</p>
</blockquote>

<p>The short answer is that value classes existed before the Machinist macros were implemented, and they do not solve the same problem Machinist solves.</p>

<p>This article is the long answer.</p>

<h2 id="the-base-case">The base case</h2>

<p>The Machinist’s goal is to remove <em>any</em> overhead that would distinguish
using a type class “directly” from using it indirectly via an implicit
operator.</p>

<p>Imagine we have the following “toy” type class:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Div</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">div</span><span class="o">(</span><span class="n">lhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">rhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Div</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="nc">DivString</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Div</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">div</span><span class="o">(</span><span class="n">lhs</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">rhs</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">lhs</span> <span class="o">+</span> <span class="s">"/"</span> <span class="o">+</span> <span class="n">rhs</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This allows us to write generic code such as:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Test1</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">gen</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Div</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">div</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">test</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">gen</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We have a generic method <code class="highlighter-rouge">gen</code> that works with any type we have a <code class="highlighter-rouge">Div[A]</code> instance for, and we verify that it works using a <code class="highlighter-rouge">test</code> method that operates on some strings. So far, so good. But obviously, calling <code class="highlighter-rouge">ev.div</code> is a bit ugly.</p>

<h2 id="implicit-conversion-with-a-value-class">Implicit conversion with a value class</h2>

<p>We can make the <code class="highlighter-rouge">gen</code> method look a bit nicer by using an implicit conversion. Here’s the code:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Test3</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">DivOps</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">val</span> <span class="n">lhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span> <span class="o">{</span>
    <span class="k">def</span> <span class="o">/(</span><span class="n">rhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Div</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">div</span><span class="o">(</span><span class="n">lhs</span><span class="o">,</span> <span class="n">rhs</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Test3</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">Test3.DivOps</span>
  <span class="k">def</span> <span class="n">gen</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Div</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>
  <span class="k">def</span> <span class="n">test</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">gen</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now, we can just say <code class="highlighter-rouge">x / y</code> and have that call <code class="highlighter-rouge">Div#div</code> automatically. We also don’t need a reference to <code class="highlighter-rouge">ev: Div[A]</code> so we can use the nicer <code class="highlighter-rouge">[A: Div]</code> syntax.</p>

<p>With a normal implicit conversion, every call to <code class="highlighter-rouge">gen</code> would construct an instance of <code class="highlighter-rouge">Test3.DivOps</code>. However, since we have defined <code class="highlighter-rouge">Test3.DivOps</code> as a value class (by extending <code class="highlighter-rouge">AnyVal</code>), the object instantiation is ellided. Instead, the method call is dispatched to <code class="highlighter-rouge">Test3.DivOps.$div$extension</code> which calls <code class="highlighter-rouge">ev.div</code>.</p>

<p>We often talk about value classes as not having a <em>cost</em>. Since no class is instantiated, we are not required to pay a cost in allocations, but we do still pay a cost in indirection (instead of calling <code class="highlighter-rouge">ev.div</code> directly as in <code class="highlighter-rouge">Test1</code> we have an intermediate extension method).</p>

<p>You can see the difference in the output from <code class="highlighter-rouge">javap</code>.</p>

<p>In the case of <code class="highlighter-rouge">Test1.gen</code>, the call to <code class="highlighter-rouge">ev.div</code> and return are all handled with 5 instructions (8 bytes of bytecode):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// cost.Test1.gen(A, A, Div[A]): A
0: aload_3
1: aload_1
2: aload_2
3: invokeinterface #16,  3           // InterfaceMethod cost/Div.div:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
8: areturn
</code></pre></div></div>

<p>In the case of <code class="highlighter-rouge">Test3.gen</code>, there is extra ceremony setting up the companion objects, and a call to the extension method (<code class="highlighter-rouge">$div$extension</code>), which is defined in <code class="highlighter-rouge">Test3.DivOps</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// cost.Test3.gen(A, A, Div[A]): A
0: getstatic     #25                 // Field cost/Test3$DivOps$.MODULE$:Lcost/Test3$DivOps$;
3: getstatic     #16                 // Field cost/Test3$.MODULE$:Lcost/Test3$;
6: aload_1
7: invokevirtual #18                 // Method cost/Test3$.DivOps:(Ljava/lang/Object;)Ljava/lang/Object;
10: aload_2
11: aload_3
12: invokevirtual #28                 // Method cost/Test3$DivOps$.$div$extension:(Ljava/lang/Object;Ljava/lang/Object;Lcost/Div;)Ljava/lang/Object;
15: areturn

// cost.Test3.DivOps.$div$extension(A, A, Div[A]): A
0: aload_3
1: aload_1
2: aload_2
3: invokeinterface #20,  3           // InterfaceMethod cost/Div.div:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
8: areturn
</code></pre></div></div>

<p>In fact the bytecode for the extension method is uncannily similar to that of <code class="highlighter-rouge">Test1.gen</code>, but in this case <code class="highlighter-rouge">Test3.gen</code> involves 8 more instructions (15 bytes).</p>

<p>In some cases these bytecode differences might not be significant (for example if the running time of <code class="highlighter-rouge">Div[A].div</code> is expected to dwarf the cost of method dispatch). However, when type classes are used to support primitive operations (such as addition or comparisons) it’s likely that this overhead might be significant.</p>

<h2 id="enter-machinist">Enter machinist</h2>

<p>Machinist is based on a set of macros that were introduced in <a href="https://github.com/non/spire">Spire</a> to remove the performance penalties associated with generic math implementations. These macros were based on an even earlier approach which used a compiler plugin.</p>

<p>The basic approach has not changed: at compile-time we can detect situations where we build an object just to assemble a method call with the arguments to its constructor. In these cases we rewrite the tree, removing the object allocation and making the method call directly. Machinist’s documentation goes to some trouble to explain it, but basically, we want to be able to write code like <code class="highlighter-rouge">Test3.gen</code> but have it interpreted as <code class="highlighter-rouge">Test1.gen</code>. That is literally the entire purpose of machinist.</p>

<p>Here’s a construction that works for this example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Test2</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">DivOps</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">lhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Div</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="o">{</span>
    <span class="k">def</span> <span class="o">/(</span><span class="n">rhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">macro</span> <span class="n">machinist</span><span class="o">.</span><span class="nc">DefaultOps</span><span class="o">.</span><span class="n">binop</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">]</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Test2</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">Test2.DivOps</span>
  <span class="k">def</span> <span class="n">gen</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Div</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>
  <span class="k">def</span> <span class="n">test</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">gen</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We use the <code class="highlighter-rouge">machinist.DefaultOps</code> object to provide an instance of the <code class="highlighter-rouge">binop</code> macros, which will rewrite <code class="highlighter-rouge">DivOps(x)(ev).$div(y)</code> into <code class="highlighter-rouge">ev.div(x, y)</code>.</p>

<p>Here’s what we end up with in bytecode:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// cost.Test2.gen(A, A, Div[A]): A
0: aload_3
1: aload_1
2: aload_2
3: invokeinterface #26,  3           // InterfaceMethod cost/Div.div:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
8: areturn
</code></pre></div></div>

<p>As you can see, the sourcecode for <code class="highlighter-rouge">Test2.gen</code> is identical to <code class="highlighter-rouge">Test3.gen</code>, and the bytecode for <code class="highlighter-rouge">Test2.gen</code> is identical to that of <code class="highlighter-rouge">Test1.gen</code>. Success!</p>

<h2 id="caveats">Caveats</h2>

<p>There are a few caveats that are worth mentioning:</p>

<h3 id="managing-compilation-units">Managing compilation units</h3>

<p>The issue that sparked this article used the operator <code class="highlighter-rouge">+/+</code>. Machinist claims to be able to support any symbolic operator. Why didn’t we use that operator here?</p>

<p>The answer has to do with how Scala macros work. Scala requires that macros be defined in a separate “compilation unit” from the one they are invoked in. This makes it very awkward to create a code snippet that both defines and uses a macro. In this case, it means that we can’t extend <code class="highlighter-rouge">machinist.Ops</code> to define new symbolic operators in the same file that demonstrates their use. This is why we used <code class="highlighter-rouge">/</code> (which maps to <code class="highlighter-rouge">div</code> and is a “default operator”).</p>

<p>You can arrange your “real” projects so that they are not affected by this limitation.</p>

<h3 id="use-outside-of-generic-methods">Use outside of generic methods</h3>

<p>Now that we’ve demonstrated the cost that implicit conversions to value classes impose, you might imagine wanting to perform this transformation on <em>all</em> your implicit conversions.</p>

<p>Unfortunately, Machinist is not sufficiently general to support this. Right now its macros support a number of different “shapes” but assume generic method which dispatches to an implicit evidence parameter. It might be possible to write macros which inline the method body of a concrete implicit class, but that’s outside the scope of the project.</p>

<h2 id="postscript-messy-details">Postscript: messy details</h2>

<p>This article throws around a lot of source code and bytecode.  Below are included the files needed to build the demo (<code class="highlighter-rouge">cost.scala</code> and <code class="highlighter-rouge">build.sbt</code>) as well as the <code class="highlighter-rouge">javap</code> output from the three test classes, and the value class.</p>

<h3 id="costscala">cost.scala</h3>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="nn">cost</span>

<span class="k">import</span> <span class="nn">language.implicitConversions</span>
<span class="k">import</span> <span class="nn">scala.language.experimental.macros</span>

<span class="k">trait</span> <span class="nc">Div</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">div</span><span class="o">(</span><span class="n">lhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">rhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Div</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="nc">DivString</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Div</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">div</span><span class="o">(</span><span class="n">lhs</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">rhs</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">lhs</span> <span class="o">+</span> <span class="s">"/"</span> <span class="o">+</span> <span class="n">rhs</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Test1</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">gen</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Div</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">div</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">test</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">gen</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Test2</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">DivOps</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">lhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Div</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="o">{</span>
    <span class="k">def</span> <span class="o">/(</span><span class="n">rhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">macro</span> <span class="n">machinist</span><span class="o">.</span><span class="nc">DefaultOps</span><span class="o">.</span><span class="n">binop</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">]</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Test2</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">Test2.DivOps</span>
  <span class="k">def</span> <span class="n">gen</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Div</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>
  <span class="k">def</span> <span class="n">test</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">gen</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Test3</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">DivOps</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">val</span> <span class="n">lhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span> <span class="o">{</span>
    <span class="k">def</span> <span class="o">/(</span><span class="n">rhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Div</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">div</span><span class="o">(</span><span class="n">lhs</span><span class="o">,</span> <span class="n">rhs</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Test3</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">Test3.DivOps</span>
  <span class="k">def</span> <span class="n">gen</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Div</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>
  <span class="k">def</span> <span class="n">test</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">gen</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="buildsbt">build.sbt</h3>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">name</span> <span class="o">:=</span> <span class="s">"cost"</span>

<span class="n">scalaVersion</span> <span class="o">:=</span> <span class="s">"2.11.2"</span>

<span class="n">resolvers</span> <span class="o">+=</span> <span class="s">"bintray/non"</span> <span class="n">at</span> <span class="s">"http://dl.bintray.com/non/maven"</span>

<span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">"org.typelevel"</span> <span class="o">%%</span> <span class="s">"machinist"</span> <span class="o">%</span> <span class="s">"0.2.2"</span>
</code></pre></div></div>

<h3 id="test1out">Test1.out</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Compiled from "cost.scala"
public class cost.Test1 {
  public &lt;A extends java/lang/Object&gt; A gen(A, A, cost.Div&lt;A&gt;);
    Code:
       0: aload_3       
       1: aload_1       
       2: aload_2       
       3: invokeinterface #16,  3           // InterfaceMethod cost/Div.div:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
       8: areturn       

  public java.lang.String test();
    Code:
       0: aload_0       
       1: ldc           #27                 // String foo
       3: ldc           #29                 // String bar
       5: getstatic     #35                 // Field cost/Div$.MODULE$:Lcost/Div$;
       8: invokevirtual #39                 // Method cost/Div$.DivString:()Lcost/Div;
      11: invokevirtual #41                 // Method gen:(Ljava/lang/Object;Ljava/lang/Object;Lcost/Div;)Ljava/lang/Object;
      14: checkcast     #43                 // class java/lang/String
      17: areturn       

  public cost.Test1();
    Code:
       0: aload_0       
       1: invokespecial #47                 // Method java/lang/Object."&lt;init&gt;":()V
       4: return        
}
</code></pre></div></div>

<h3 id="test2out">Test2.out</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Compiled from "cost.scala"
public class cost.Test2 {
  public static &lt;A extends java/lang/Object&gt; cost.Test2$DivOps&lt;A&gt; DivOps(A, cost.Div&lt;A&gt;);
    Code:
       0: getstatic     #16                 // Field cost/Test2$.MODULE$:Lcost/Test2$;
       3: aload_0       
       4: aload_1       
       5: invokevirtual #18                 // Method cost/Test2$.DivOps:(Ljava/lang/Object;Lcost/Div;)Lcost/Test2$DivOps;
       8: areturn       

  public &lt;A extends java/lang/Object&gt; A gen(A, A, cost.Div&lt;A&gt;);
    Code:
       0: aload_3       
       1: aload_1       
       2: aload_2       
       3: invokeinterface #26,  3           // InterfaceMethod cost/Div.div:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
       8: areturn       

  public java.lang.String test();
    Code:
       0: aload_0       
       1: ldc           #37                 // String foo
       3: ldc           #39                 // String bar
       5: getstatic     #44                 // Field cost/Div$.MODULE$:Lcost/Div$;
       8: invokevirtual #48                 // Method cost/Div$.DivString:()Lcost/Div;
      11: invokevirtual #50                 // Method gen:(Ljava/lang/Object;Ljava/lang/Object;Lcost/Div;)Ljava/lang/Object;
      14: checkcast     #52                 // class java/lang/String
      17: areturn       

  public cost.Test2();
    Code:
       0: aload_0       
       1: invokespecial #56                 // Method java/lang/Object."&lt;init&gt;":()V
       4: return        
}
</code></pre></div></div>

<h3 id="test3out">Test3.out</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Compiled from "cost.scala"
public class cost.Test3 {
  public static java.lang.Object DivOps(java.lang.Object);
    Code:
       0: getstatic     #16                 // Field cost/Test3$.MODULE$:Lcost/Test3$;
       3: aload_0       
       4: invokevirtual #18                 // Method cost/Test3$.DivOps:(Ljava/lang/Object;)Ljava/lang/Object;
       7: areturn       

  public &lt;A extends java/lang/Object&gt; A gen(A, A, cost.Div&lt;A&gt;);
    Code:
       0: getstatic     #25                 // Field cost/Test3$DivOps$.MODULE$:Lcost/Test3$DivOps$;
       3: getstatic     #16                 // Field cost/Test3$.MODULE$:Lcost/Test3$;
       6: aload_1       
       7: invokevirtual #18                 // Method cost/Test3$.DivOps:(Ljava/lang/Object;)Ljava/lang/Object;
      10: aload_2       
      11: aload_3       
      12: invokevirtual #28                 // Method cost/Test3$DivOps$.$div$extension:(Ljava/lang/Object;Ljava/lang/Object;Lcost/Div;)Ljava/lang/Object;
      15: areturn       

  public java.lang.String test();
    Code:
       0: aload_0       
       1: ldc           #39                 // String foo
       3: ldc           #41                 // String bar
       5: getstatic     #46                 // Field cost/Div$.MODULE$:Lcost/Div$;
       8: invokevirtual #50                 // Method cost/Div$.DivString:()Lcost/Div;
      11: invokevirtual #52                 // Method gen:(Ljava/lang/Object;Ljava/lang/Object;Lcost/Div;)Ljava/lang/Object;
      14: checkcast     #54                 // class java/lang/String
      17: areturn       

  public cost.Test3();
    Code:
       0: aload_0       
       1: invokespecial #58                 // Method java/lang/Object."&lt;init&gt;":()V
       4: return        
}
</code></pre></div></div>

<h3 id="test3divopsout">Test3.DivOps.out</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Compiled from "cost.scala"
public class cost.Test3$DivOps$ {
  public static final cost.Test3$DivOps$ MODULE$;

  public static {};
    Code:
       0: new           #2                  // class cost/Test3$DivOps$
       3: invokespecial #12                 // Method "&lt;init&gt;":()V
       6: return        

  public final &lt;A extends java/lang/Object&gt; A $div$extension(A, A, cost.Div&lt;A&gt;);
    Code:
       0: aload_3       
       1: aload_1       
       2: aload_2       
       3: invokeinterface #20,  3           // InterfaceMethod cost/Div.div:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
       8: areturn       

  public final &lt;A extends java/lang/Object&gt; int hashCode$extension(A);
    Code:
       0: aload_1       
       1: invokevirtual #32                 // Method java/lang/Object.hashCode:()I
       4: ireturn       

  public final &lt;A extends java/lang/Object&gt; boolean equals$extension(A, java.lang.Object);
    Code:
       0: aload_2       
       1: astore_3      
       2: aload_3       
       3: instanceof    #36                 // class cost/Test3$DivOps
       6: ifeq          15
       9: iconst_1      
      10: istore        4
      12: goto          18
      15: iconst_0      
      16: istore        4
      18: iload         4
      20: ifeq          61
      23: aload_2       
      24: ifnonnull     31
      27: aconst_null   
      28: goto          38
      31: aload_2       
      32: checkcast     #36                 // class cost/Test3$DivOps
      35: invokevirtual #40                 // Method cost/Test3$DivOps.lhs:()Ljava/lang/Object;
      38: astore        5
      40: aload_1       
      41: aload         5
      43: invokestatic  #45                 // Method scala/runtime/BoxesRunTime.equals:(Ljava/lang/Object;Ljava/lang/Object;)Z
      46: ifeq          53
      49: iconst_1      
      50: goto          54
      53: iconst_0      
      54: ifeq          61
      57: iconst_1      
      58: goto          62
      61: iconst_0      
      62: ireturn       

  public cost.Test3$DivOps$();
    Code:
       0: aload_0       
       1: invokespecial #47                 // Method java/lang/Object."&lt;init&gt;":()V
       4: aload_0       
       5: putstatic     #49                 // Field MODULE$:Lcost/Test3$DivOps$;
       8: return        
}
</code></pre></div></div>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 06 Aug 2015 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2015/08/06/machinist.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2015/08/06/machinist.html</guid>
      </item>
    
      <item>
        <title>Values never change types</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><em>This is the sixth of a series of articles on “Type Parameters and
Type Members”.  If you haven’t yet, you should
<a href="/blog/2015/07/13/type-members-parameters.html">start at the beginning</a>,
which introduces code we refer to throughout this article without
further ado.</em></p>

<p>In a subtyping language such as Java or Scala, first-class
existentials are a helpful ally for modeling values and methods that
abstract over subtypes in different ways.  In a language with
mutation, such as Java or Scala, existentials help deal with certain
kinds of state changes without violating type safety.</p>

<p>But values, <em>themselves</em>, never change types.  When you first practice
with existentials, the Java and Scala compilers seem to become
veritable minefields of type errors—do something slightly different in
your code, and everything falls apart.  But this is just about
<a href="http://blog.higher-order.com/blog/2014/12/21/maximally-powerful/">nothing being a free lunch</a>:
<strong>the wide variety of values meeting any given existential type,
combined with the possibility for mutation, means a sound typechecker
must be very conservative about what it permits when using those
values</strong>.</p>

<p>So, in this article, we’ll explore some of these type error pitfalls,
see why it’s perfectly reasonable for the compilers to complain about
these pieces of code, and fix the errors using the equivalence rules
we’ve learned about in previous articles.  This is a big topic, so in
the next article, we’ll talk about taking advantage of the freedoms
that the compilers are concerned about in this one.</p>

<h2 id="aliasing-prevents-replacement">Aliasing prevents replacement</h2>

<p>Let’s say you have a list of strings, <code class="highlighter-rouge">strs: List[String]</code>.  But you
want that value to change: you want it to be a <code class="highlighter-rouge">List[Int]</code> instead.
Maybe every value in the list parses to an integer and you want to
“map in place”; maybe you want to use <code class="highlighter-rouge">-1</code> for every string that can’t
be parsed.</p>

<p>Generic systems like those of Java, Scala, and the ML family don’t let
you do this for a few reasons.</p>

<p>First, with regard to structures like <code class="highlighter-rouge">List</code>, let’s suppose we are
adding this feature to the type system, and that the list has type
<code class="highlighter-rouge">List[String]</code> before replacement, and <code class="highlighter-rouge">List[Int]</code> after.  What type
does it have when we’re halfway done?  The type system requires us to
<em>guarantee</em> that there are no strings, only ints, left once we’re
done; how do we track our progress?  Remember that vague promises of
“I tested the code” are meaningless to the type system; you have to
<em>prove</em> it mathematically.  This is a solvable problem, but the known
solutions far complicate the type system beyond the design goals of
these languages: the cost is far too high for the benefit.</p>

<p>Second, let us suppose that we’ve solved the first problem.  Or, let
us suppose that we introduce a structure for which this isn’t a
problem.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">OneThing</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">var</span> <span class="n">value</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span>
</code></pre></div></div>

<p>There, no chance of “halfway done” there!  But something else happens.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">strs</span><span class="k">:</span> <span class="kt">OneThing</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">OneThing</span><span class="o">(</span><span class="s">"hi"</span><span class="o">)</span>
<span class="n">strs</span><span class="o">.</span><span class="n">value</span> <span class="k">=</span> <span class="mi">42</span>
<span class="c1">// won't compile, just a thought experiment
</span></code></pre></div></div>

<p>Now, presumably, completely aside from the value, the variable <code class="highlighter-rouge">strs</code>
has <em>changed types</em> to <code class="highlighter-rouge">OneThing[Int]</code>.  Not just the value in it, the
variable itself.  OK, so what if that variable came from someplace
else?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">replaceWithInt</span><span class="o">(</span><span class="n">ote</span><span class="k">:</span> <span class="kt">OneThing</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
  <span class="n">t</span><span class="o">.</span><span class="n">value</span> <span class="k">=</span> <span class="mi">42</span>

<span class="k">val</span> <span class="n">strs</span><span class="k">:</span> <span class="kt">OneThing</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">OneThing</span><span class="o">(</span><span class="s">"hi"</span><span class="o">)</span>
<span class="n">replaceWithInt</span><span class="o">(</span><span class="n">strs</span><span class="o">)</span>
<span class="c1">// also won't compile, thought experiment
</span></code></pre></div></div>

<p>Now, the type of <code class="highlighter-rouge">replaceWithInt</code> must contain a note that “by the
way, the type of <code class="highlighter-rouge">ote</code>, and any variables that refer to it, and any
variables that refer to <em>those</em> variables, and so on until it stops,
will change as a result of this call”.</p>

<p>This is a problem of <em>aliases</em>, all the locations that may refer to a
value.  If you change the type of the value, you also have to update
every reference to it, at compile time!  This is <em>the type system</em>;
your promise that you have no other references is not good enough.
You have to <em>prove</em> it.</p>

<p>As with the previous problem, the known solutions to this problem
would complicate the type systems of Java and Scala beyond their
design goals.  In a sense, <strong>this aspect of their type systems can be
considered to encourage functional programming</strong>.  A type-changing map
that builds a new list of the new type, or what have you, instead of
mutating the old one, is <em>trivial</em> in the Java/Scala generics systems.
There are no chances of aliasing problems, because no one could
possibly have an unknown reference to the value you just constructed.
This is a even more obvious design choice in the ML family languages,
which make no secret of favoring functional programming.</p>

<h2 id="assignment-rewrites-existentials">Assignment rewrites existentials</h2>

<p><a href="/blog/2015/07/16/method-equiv.html">We saw earlier</a> that a simple get from a
<code class="highlighter-rouge">List&lt;?&gt;</code>, followed by adding that value right back to the same list,
didn’t work, but if we took that <code class="highlighter-rouge">xs</code> and passed it to a
type-parameterized version, everything worked fine.  Why is that?</p>

<p>If you have a <em>mutable</em> variable of an existential type, the
existentialized part of the type may have different [type] values at
different parts of the program.  Let’s use
<a href="/blog/2015/07/23/type-projection.html#a-good-reason-to-use-type-members">the <code class="highlighter-rouge">StSource</code> from the projection post</a>.
Note that the <code class="highlighter-rouge">S</code> member is existential, because we did not bind it.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">mxs</span><span class="k">:</span> <span class="kt">StSource</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">StSource</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">toString</span><span class="o">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>
<span class="c1">// at this point in the program, the S is Int
</span><span class="k">val</span> <span class="n">s1</span> <span class="k">=</span> <span class="n">mxs</span><span class="o">.</span><span class="n">init</span>
<span class="c1">// now I'm going to change mxs
</span><span class="n">mxs</span> <span class="k">=</span> <span class="nc">StSource</span><span class="o">(</span><span class="s">"ab"</span><span class="o">)(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">.</span><span class="n">reverse</span><span class="o">))</span>
<span class="c1">// at this point in the program, the S is String
</span><span class="n">mxs</span><span class="o">.</span><span class="n">emit</span><span class="o">(</span><span class="n">s1</span><span class="o">)</span>

<span class="nc">TmTp6</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">14</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">tmtp6.Tmtp4Funs.s1.</span><span class="k">type</span> <span class="o">(</span><span class="kt">with</span> <span class="kt">underlying</span> <span class="k">type</span> <span class="kt">tmtp4.StSource</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span><span class="k">#</span><span class="kt">S</span><span class="o">)</span>
 <span class="n">required</span><span class="k">:</span> <span class="k">_</span><span class="err">2</span><span class="kt">.S</span> <span class="kt">where</span> <span class="kt">val</span> <span class="k">_</span><span class="err">2</span><span class="kt">:</span> <span class="kt">tmtp4.StSource</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="n">mxs</span><span class="o">.</span><span class="n">emit</span><span class="o">(</span><span class="n">s1</span><span class="o">)</span>
         <span class="o">^</span>
</code></pre></div></div>

<p>And it’s good that this happens, because the value we got from <code class="highlighter-rouge">init</code>
is definitely incompatible with the argument type to <code class="highlighter-rouge">emit</code>.</p>

<p>If we don’t want to track when this happens—and we certainly can’t
decide, in all cases, when a mutable variable such as this has been
overwritten so as to change its existentials, given the freedoms
afforded by Java—how can we treat a mutable variable with existentials
as safe?  The type system makes a simplifying assumption: <em>every
reference to the variable gets fresh values to fill in the
existentials</em>.</p>

<p>If it helps, you can think of a mutable variable as an <em>immutable</em>
variable that wraps its type with an extra layer.  In fact, that’s
<a href="https://github.com/scala/scala/blob/v2.11.7/src/library/scala/runtime/ObjectRef.java#L14-L17">what scalac does when you capture a <code class="highlighter-rouge">var</code></a>.
So <code class="highlighter-rouge">mxs</code> is, in a sense, of type <code class="highlighter-rouge">Ref[StSource[String]]</code>, where</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Ref</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">value</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="n">update</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>
</code></pre></div></div>

<p>So, by substitution, the variable <code class="highlighter-rouge">mxs</code> is really a pair of functions,
<code class="highlighter-rouge">() =&gt; StSource[String]</code> and <code class="highlighter-rouge">StSource[String] =&gt; Unit</code>.  The “getter”
returns <code class="highlighter-rouge">StSource[String]</code>; each time you invoke that getter, you
might get an <code class="highlighter-rouge">StSource[String]</code> with a different <code class="highlighter-rouge">S</code> member, because
the <code class="highlighter-rouge">forSome</code> effectively occurs inside the body, as described in
<a href="/blog/2015/07/27/nested-existentials.html#what-if-we-list-different-existentials">the substitutions of “Nested existentials”</a>.</p>

<p>Of course, this means you can take advantage of this in your own
designs, to get <em>some</em> of the behavior of a type-changing value
mutation.  The use of variable references to delineate existentials
means that, even when we replace <code class="highlighter-rouge">mxs</code> above, the behavior of the
variable in the context of an instance hasn’t really changed, so
nothing about the containing value’s type has changed.  We thus
preserve our property, that values never change types.</p>

<p>When you make a single reference, it has to be consistent; subsequent
mutations have no effect on the value we got from that reference.  So
we can pass that reference somewhere that asserts that this doesn’t
happen in its own context, such as a type-parameterized
≡<em><sub><small>m</small></sub></em> method.  If you have a mutable variable
of type <code class="highlighter-rouge">List&lt;T&gt;</code>, even if you don’t know what <code class="highlighter-rouge">T</code> is, you know that
any updates to that variable will keep the same <code class="highlighter-rouge">T</code>.</p>

<h2 id="making-variables-read-only-matters">Making variables read-only matters</h2>

<p>If I change the variable to <code class="highlighter-rouge">final</code> in Java, and remove mutation, I
shouldn’t have this problem anymore.  Surprisingly, I do; this is what
happened in
<a href="/blog/2015/07/16/method-equiv.html">the original <code class="highlighter-rouge">copyToZero</code> example</a>,
where the argument was declared <code class="highlighter-rouge">final</code>.  I assume that this is just a
simplifying assumption in <code class="highlighter-rouge">javac</code>, that the extra guarantee of
unchanging existentials offered by <code class="highlighter-rouge">final</code> isn’t understood by the
compiler.</p>

<p>In the case of Scala, though, <strong>when you are using existential type
members, Scala can understand the implications of an immutable
variable, declared with <code class="highlighter-rouge">val</code></strong>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">imxs</span><span class="k">:</span> <span class="kt">StSource</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">StSource</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">toString</span><span class="o">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>
<span class="k">val</span> <span class="n">s1</span> <span class="k">=</span> <span class="n">imxs</span><span class="o">.</span><span class="n">init</span>
<span class="c1">// you can do whatever you want here; the compiler will stop you from
// changing imxs
</span><span class="n">imxs</span><span class="o">.</span><span class="n">emit</span><span class="o">(</span><span class="n">s1</span><span class="o">)</span>
</code></pre></div></div>

<p>It can’t pull off this trick for type parameters, having just as much
trouble as Java there.  So this is another reason for
<a href="/blog/2015/07/13/type-members-parameters.html">our original rule of thumb</a>.</p>

<h2 id="naming-the-existential">Naming the existential</h2>

<p>The benefit we get from
<a href="/blog/2015/07/16/method-equiv.html">passing <code class="highlighter-rouge">copyToZeroP</code>’s argument to <code class="highlighter-rouge">copyToZeroT</code></a>
is that we <em>name</em> the existential for the single reference to the
argument that we make.  We name it <code class="highlighter-rouge">T</code> there, for the scope of its
invocation.</p>

<p>Likewise, in Scala, each <code class="highlighter-rouge">val</code> introduces, while it is in scope, each
existential member it has, as a type name.  There are
<a href="http://www.scala-lang.org/files/archive/spec/2.11/03-types.html#paths">a lot of rules in Scala</a>
for exactly when this happens, but you may want to simply experiment.
We got a hint of what that name is
<a href="/blog/2015/07/23/type-projection.html#type-parameters-see-existentially">when we used <code class="highlighter-rouge">StSource</code> existentially in the REPL</a>.
Here’s the previous example again, with a type annotation for <code class="highlighter-rouge">s1</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">imxs</span><span class="k">:</span> <span class="kt">StSource</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">StSource</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">toString</span><span class="o">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>
<span class="k">val</span> <span class="n">s1</span><span class="k">:</span> <span class="kt">imxs.S</span> <span class="o">=</span> <span class="n">imxs</span><span class="o">.</span><span class="n">init</span>
<span class="n">imxs</span><span class="o">.</span><span class="n">emit</span><span class="o">(</span><span class="n">s1</span><span class="o">)</span>
</code></pre></div></div>

<p>We have gained convenience, not power, with this <em>path-dependent
types</em> feature; we can always pass into a type-parameterized local
method, with only the inconvenience of having to write out the whole
polymorphic method and call dance.  Moreover, this is nowhere near
<a href="/blog/2015/07/23/type-projection.html#a-failed-attempt-at-simplified-emitting">a solution to the type projection problem</a>;
there are too many things that a type parameter can do that we can’t
with this feature.  But we’ll dive into that in a later post.</p>

<h2 id="by-name-existential-arguments-arent-equivalent">By-name existential arguments aren’t equivalent!</h2>

<p>There is another little corner case in method equivalence to consider.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">copyToZeroNP</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">PList</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="k">def</span> <span class="n">copyToZeroNT</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">PList</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span>
</code></pre></div></div>

<p>These method types are not equivalent!  That’s because <code class="highlighter-rouge">copyToZeroNP</code>
can be called with a by-name <em>that evaluates to a list with a
different element type each time</em>; <code class="highlighter-rouge">copyToZeroNT</code> doesn’t allow this.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">time</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">t</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">PCons</span><span class="o">(</span><span class="s">"even"</span><span class="o">,</span> <span class="nc">PNil</span><span class="o">())</span>
  <span class="k">else</span> <span class="nc">PCons</span><span class="o">(</span><span class="mi">66</span><span class="o">,</span> <span class="nc">PNil</span><span class="o">())</span>
<span class="o">}</span>

<span class="n">copyToZeroNP</span><span class="o">(</span><span class="n">time</span><span class="o">)</span>  <span class="c1">// ok
</span><span class="n">copyToZeroNT</span><span class="o">(</span><span class="n">time</span><span class="o">)</span>  <span class="c1">// not ok
</span></code></pre></div></div>

<p>In effect, <code class="highlighter-rouge">=&gt;</code> is like a type constructor; we can think of these
arguments as <code class="highlighter-rouge">byname[PList[_]]</code> and <code class="highlighter-rouge">byname[PList[T]]</code>.  So we have
exactly the same problem as we had with
<a href="/blog/2015/07/27/nested-existentials.html#method-equivalence-%E2%80%A6-broken"><code class="highlighter-rouge">plenLength</code> and <code class="highlighter-rouge">plenLengthTP</code></a>.</p>

<p>Unfortunately,
<a href="https://issues.scala-lang.org/browse/SI-9419">Scala currently accepts this, where it shouldn’t</a>.</p>

<p>The difference between these two methods gives us a hint about working
with existentials: if we can shift the scope for a given existential
outside the function that keeps giving us different types on every
reference, we might have an easier time working with it, even if we
can’t change it to a <code class="highlighter-rouge">val</code>; maybe it needs to be lazy and not saved,
for example.  So, despite the occasional convenience of path-dependent
types, <strong>type parameterized methods are still your best friends when
working with existential types</strong>.</p>

<p>In
<a href="/blog/2015/09/21/change-values.html">the next article, “To change types, change values”</a>,
we’ll look at some programs that make use of the two kinds of “type
changing” discussed above.  After that, we’ll finally talk about
methods that <em>return</em> values of existential type, rather than merely
taking them as arguments.</p>

<p><em>This article was tested with Scala 2.11.7.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 30 Jul 2015 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2015/07/30/values-never-change-types.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2015/07/30/values-never-change-types.html</guid>
      </item>
    
      <item>
        <title>Nested existentials</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><em>This is the fifth of a series of articles on “Type Parameters and
Type Members”.  If you haven’t yet, you should
<a href="/blog/2015/07/13/type-members-parameters.html">start at the beginning</a>,
which introduces code we refer to throughout this article without
further ado.</em></p>

<p>Let’s consider a few values of type <code class="highlighter-rouge">MList</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">estrs</span><span class="k">:</span> <span class="kt">MList</span> <span class="o">=</span> <span class="nc">MCons</span><span class="o">(</span><span class="s">"hi"</span><span class="o">,</span> <span class="nc">MCons</span><span class="o">(</span><span class="s">"bye"</span><span class="o">,</span> <span class="nc">MNil</span><span class="o">()))</span><span class="k">:</span> <span class="kt">MList.Aux</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>

<span class="k">val</span> <span class="n">eints</span><span class="k">:</span> <span class="kt">MList</span> <span class="o">=</span> <span class="nc">MCons</span><span class="o">(</span><span class="mi">21</span><span class="o">,</span> <span class="nc">MCons</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="nc">MNil</span><span class="o">()))</span><span class="k">:</span> <span class="kt">MList.Aux</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

<span class="k">val</span> <span class="n">ebools</span><span class="k">:</span> <span class="kt">MList</span> <span class="o">=</span> <span class="nc">MCons</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="nc">MCons</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="nc">MNil</span><span class="o">()))</span><span class="k">:</span> <span class="kt">MList.Aux</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>
</code></pre></div></div>

<p>Recall
<a href="/blog/2015/07/13/type-members-parameters.html#why-all-the-type-t">from the first part</a>
that the equivalent type in <code class="highlighter-rouge">PList</code> style is <code class="highlighter-rouge">PList[_]</code>.  Now, these
variables all have the “same” type, by virtue of forgetting what their
specific element type is, though you know that every value of, for
example, <code class="highlighter-rouge">estrs</code> has the same type.</p>

<h2 id="what-if-we-list-different-existentials">What if we list <em>different</em> existentials?</h2>

<p>Lists hold values of the same type, and as you might expect, you can
put these three lists in another list:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">elists</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">MList</span><span class="o">]</span> <span class="k">=</span> 
  <span class="nc">PCons</span><span class="o">(</span><span class="n">estrs</span><span class="o">,</span> <span class="nc">PCons</span><span class="o">(</span><span class="n">eints</span><span class="o">,</span> <span class="nc">PCons</span><span class="o">(</span><span class="n">ebools</span><span class="o">,</span> <span class="nc">PNil</span><span class="o">())))</span>
</code></pre></div></div>

<p>Again, the equivalent is <code class="highlighter-rouge">PList[PList[_]]</code>.  We can see what this
means merely by doing substitution in the <code class="highlighter-rouge">PList</code> type.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">PList</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">extends</span> <span class="nc">PList</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">PCons</span><span class="o">(</span><span class="n">head</span><span class="k">:</span> <span class="kt">MList</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">PList</span><span class="o">)</span>
<span class="c1">// don't compile this, it's a thought process
</span></code></pre></div></div>

<p>Equivalently, <code class="highlighter-rouge">head</code> would have type <code class="highlighter-rouge">PList[_]</code>, a homogeneous list of
unknown element type, just like <code class="highlighter-rouge">MList</code>.</p>

<h2 id="method-equivalence--broken">Method equivalence … broken?</h2>

<p>But we come to a problem.  Suppose we wish to count the elements of
doubly-nested lists.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">plenLength</span><span class="o">(</span><span class="n">xss</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">PList</span><span class="o">[</span><span class="k">_</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="n">plenLengthTP</span><span class="o">(</span><span class="n">xss</span><span class="o">)</span>

<span class="k">def</span> <span class="n">plenLengthTP</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xss</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">PList</span><span class="o">[</span><span class="kt">T</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="n">xss</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
    <span class="k">case</span> <span class="nc">PCons</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">plengthT</span><span class="o">(</span><span class="n">h</span><span class="o">)</span> <span class="o">+</span> <span class="n">plenLengthTP</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
  <span class="o">}</span>

<span class="nc">TmTp5</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">16</span><span class="kt">:</span> <span class="kt">no</span> <span class="k">type</span> <span class="kt">parameters</span> <span class="kt">for</span> <span class="kt">method</span> <span class="kt">plenLengthTP:</span>
<span class="kt">⤹</span> <span class="o">(</span><span class="kt">xss:</span> <span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">T</span><span class="o">]])</span><span class="nc">Int</span> <span class="n">exist</span> <span class="n">so</span> <span class="n">that</span> <span class="n">it</span>
<span class="o">⤹</span> <span class="n">can</span> <span class="n">be</span> <span class="n">applied</span> <span class="n">to</span> <span class="n">arguments</span> <span class="o">(</span><span class="n">tmtp</span><span class="o">.</span><span class="nc">PList</span><span class="o">[</span><span class="kt">tmtp.PList</span><span class="o">[</span><span class="k">_</span><span class="o">]])</span>
 <span class="o">---</span> <span class="n">because</span> <span class="o">---</span>
<span class="n">argument</span> <span class="n">expression</span><span class="ss">'s </span><span class="k">type</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">compatible</span> <span class="kt">with</span> <span class="kt">formal</span> <span class="kt">parameter</span> <span class="k">type</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">tmtp.PList</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">?T</span><span class="o">]]</span>
</code></pre></div></div>

<p>According to our equivalence test, neither of these methods works to
implement the other!  This despite
<a href="/blog/2015/07/13/type-members-parameters.html#when-is-existential-ok">the “simple rule” we have already discussed</a>.
Here’s the error the other way.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TmTp5</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">20</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">tmtp.PList</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>
</code></pre></div></div>

<p>The problem with calling <code class="highlighter-rouge">plenLengthTP</code> from <code class="highlighter-rouge">plenLength</code> is <em>there is
no one <code class="highlighter-rouge">T</code> we can choose, even an unspeakable one, to call
<code class="highlighter-rouge">plenLengthTP</code></em>.  That’s what the <code class="highlighter-rouge">?T</code> and the “no type parameters”
phrasing in the first error above means.</p>

<p>This is an accurate compiler error because <code class="highlighter-rouge">PList[PList[_]]</code> means
<code class="highlighter-rouge">PList[PList[E] forSome {type E}]</code>.  Let’s see the substitution again.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">PList</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">extends</span> <span class="nc">PList</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">PCons</span><span class="o">(</span><span class="n">head</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="k">forSome</span> <span class="o">{</span><span class="k">type</span> <span class="kt">E</span><span class="o">},</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">PList</span><span class="o">)</span>
<span class="c1">// don't compile this, it's a thought process
</span></code></pre></div></div>

<p>Java has the same problem.  See?</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">llLength</span><span class="o">(</span><span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">xss</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">llLengthTP</span><span class="o">(</span><span class="n">xss</span><span class="o">);</span>
<span class="o">}</span>

<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="nf">llLengthTP</span><span class="o">(</span><span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">xss</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// we only care about types in this example</span>
<span class="o">}</span>

<span class="n">TmTp5</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">7</span><span class="o">:</span>  <span class="nl">error:</span> <span class="n">method</span> <span class="n">llLengthTP</span> <span class="n">in</span> <span class="kd">class</span> <span class="nc">TmTp5</span>
<span class="err">⤹</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">applied</span> <span class="n">to</span> <span class="n">given</span> <span class="n">types</span><span class="o">;</span>
    <span class="k">return</span> <span class="nf">llLengthTP</span><span class="o">(</span><span class="n">xss</span><span class="o">);</span>
           <span class="o">^</span>

<span class="c1">// or, with llLengthTP calling llLength</span>
<span class="n">TmTp5</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">11</span><span class="o">:</span>  <span class="nl">error:</span> <span class="n">incompatible</span> <span class="nl">types:</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
<span class="err">⤹</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">converted</span> <span class="n">to</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;?&gt;&gt;</span>
    <span class="k">return</span> <span class="nf">llLength</span><span class="o">(</span><span class="n">xss</span><span class="o">);</span>
                    <span class="o">^</span>
</code></pre></div></div>

<p>This discovery, which I made for myself
<a href="https://bitbucket.org/ermine-language/ermine-writers/src/c63d4060a74f1c8520ea1c8c3ba51ebd5d269780/writers/javafx/src/main/java/com/clarifi/reporting/writers/jfx/table/JFXTables.java?at=default#JFXTables.java-163">in the depths of the Ermine Java code</a>
(though it was certainly already well-known to others), was my first
clue, personally, that the term
<a href="/blog/2015/07/16/method-equiv.html#why-are-existentials-harder-to-think-about">“wildcard” was a lie, as discussed in a previous part</a>.</p>

<h2 id="scoping-existential-quantifiers">Scoping existential quantifiers</h2>

<p>The difference is, in Scala, we can write an equivalent for
<code class="highlighter-rouge">plenLengthTP</code>, using the Scala-only
<a href="http://www.artima.com/pins1ed/combining-scala-and-java.html#29.3"><code class="highlighter-rouge">forSome</code> <em>existential quantifier</em></a>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">plenLengthE</span><span class="o">(</span><span class="n">xss</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">PList</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span> <span class="k">forSome</span> <span class="o">{</span><span class="k">type</span> <span class="kt">E</span><span class="o">})</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="n">plenLengthTP</span><span class="o">(</span><span class="n">xss</span><span class="o">)</span>
</code></pre></div></div>

<p>Of course, this type doesn’t mean the same thing as <code class="highlighter-rouge">plenLength</code>’s
type; for both <code class="highlighter-rouge">plenLengthE</code> and <code class="highlighter-rouge">plenLengthTP</code>, we demand proof that
each sublist in the argument has the same element type, which is not a
condition satisfied by either <code class="highlighter-rouge">PList[PList[_]]</code> or its equivalent
<code class="highlighter-rouge">PList[MList]</code>.</p>

<div class="side-note">
  <p>The reason you can’t invoke <code>plenLength</code> from
  <code>plenLengthTP</code> is complicated, even for this article.  In
  short, <code>plenLength</code> demands evidence that,
  <em>supposing</em> <code>PList</code> had a method taking an
  argument of the element type,
  e.g. <code>def lookAt(x: T): Unit</code>, it could do things like
  <code>xss.lookAt(PList("hi", PNil()))</code>.  In
  <code>plenLengthTP</code>, this hypothetical method could only be
  invoked with empty lists, or lists gotten by inspecting
  <code>xss</code> itself.</p>

  <p>That no such method exists is irrelevant for the purposes of this
  reasoning; we have written the definition of <code>PList</code> in a
  way that scalac assumes that such a method may exist.  You can
  determine the consequences yourself by adding the
  <code>lookAt</code> method to <code>PList</code>, repeating the
  above substitution for <code>PList</code>, and thinking about the
  meaning of the resulting <code>def lookAt(x:
  PList[E] forSome {type E}): Unit</code>.</p>
</div>

<p>Let’s examine the meaning of the type
<code class="highlighter-rouge">PList[PList[E]] forSome {type E}</code>.  It requires a little bit more
mental suspension.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Let there be some unknown (abstract)
</span><span class="k">type</span> <span class="kt">E</span>
<span class="c1">// then the structure of the value is
</span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">PList</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">extends</span> <span class="nc">PList</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">PCons</span><span class="o">(</span><span class="n">head</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">E</span><span class="o">],</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">PList</span><span class="o">)</span>
<span class="c1">// don't compile this, it's a thought process
</span></code></pre></div></div>

<p>By moving the <code class="highlighter-rouge">forSome</code> <em>existential scope</em> outside the outer <code class="highlighter-rouge">PList</code>,
we also move the existential type variable outside of the whole
structure, substituting <em>the same</em> variable for each place we’re
expanding the type under consideration.  Once the <code class="highlighter-rouge">forSome</code> scope
extends over the whole type, Scala can pick that type as the parameter
to <code class="highlighter-rouge">plenLengthTP</code>.</p>

<p>This isn’t possible in Java at all; <code class="highlighter-rouge">PList&lt;PList&lt;?&gt;&gt;</code> is your only
choice, as <strong><code class="highlighter-rouge">?</code> in Java, like <code class="highlighter-rouge">_</code> in Scala, is always scoped to
exactly one level outside</strong>.  So in Java, you simply can’t write
<code class="highlighter-rouge">plenLengthE</code>’s type.  Luckily, the type-parameter equivalent is
perfectly expressible.</p>

<h2 id="what-happens-when-i-move-the-existential-scope">What happens when I move the existential scope?</h2>

<p>Of course, moving the scope makes the type mean something different,
which you can tell by counting how many <code class="highlighter-rouge">E</code>s there will be in a value.
A <code class="highlighter-rouge">PList[PList[_]]</code> is a list of lists where each list may have a
different, unknown element type, like <code class="highlighter-rouge">elists</code>.  A
<code class="highlighter-rouge">PList[PList[E]] forSome {type E}</code> is a list of lists where you still
don’t know the inner element type, but you know it’s the same for each
sublist.  We can tell that because, in the expansion, there’s only one
<code class="highlighter-rouge">E</code>, whereas the expansion for the former has an <code class="highlighter-rouge">E</code> introduced in
each <code class="highlighter-rouge">head</code> value.</p>

<p>So for the latter it is type-correct to, say, move elements from one
sublist to another; you know that, whichever pair of sublists you
choose to make this trade, they have the same element type.  But you
<em>don’t know that</em> for <code class="highlighter-rouge">PList[PList[_]]</code>.</p>

<p>Similarly, also by substitution, <code class="highlighter-rouge">PList[_] =&gt; Int</code> is a function that
takes <code class="highlighter-rouge">PList</code>s of any element type and returns <code class="highlighter-rouge">Int</code>, like <code class="highlighter-rouge">plengthE</code>.
You can figure this out by substituting for
<a href="https://github.com/scala/scala/blob/v2.11.7/src/library/scala/Function1.scala#L32-L36"><code class="highlighter-rouge">Function1#apply</code></a>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">v1</span><span class="k">:</span> <span class="kt">T1</span><span class="o">)</span><span class="k">:</span> <span class="kt">R</span>
<span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">v1</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span>
</code></pre></div></div>

<p>But <code class="highlighter-rouge">(PList[E] =&gt; Int) forSome {type E}</code> is a function that takes
<code class="highlighter-rouge">PList</code>s of <em>one specific</em> element type that we don’t know.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Let there be some unknown (abstract)
</span><span class="k">type</span> <span class="kt">E</span>
<span class="c1">// then the method is
</span><span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">v1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span>
</code></pre></div></div>

<p>It’s easy to use existential scoping to create functions that are
impossible to call and other values that are impossible to use besides
functions.  This is almost one of those:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">badlength</span><span class="k">:</span> <span class="o">(</span><span class="kt">PList</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">forSome</span> <span class="o">{</span><span class="k">type</span> <span class="kt">E</span><span class="o">}</span> <span class="k">=</span> <span class="n">plengthE</span>
<span class="n">badlength</span><span class="o">(???</span> <span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span>

<span class="nc">TmTp5</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">29</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="n">where</span> <span class="k">type</span> <span class="kt">E</span>
<span class="n">badlength</span><span class="o">(???</span> <span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span>
              <span class="o">^</span>
</code></pre></div></div>

<p>But in this case, there is one way we can call this function: with an
empty list.  Whatever the <code class="highlighter-rouge">E</code> is, it will be inferred when we call
<code class="highlighter-rouge">PNil()</code>.  So <code class="highlighter-rouge">badlength(PNil())</code> works.</p>

<p>There is a broader theme here hinted at by the interaction between
<code class="highlighter-rouge">PNil</code> and <code class="highlighter-rouge">badlength</code>: <strong>the most efficient, most easily understood
way to work with values of existential type is with type-parameterized
methods</strong>.  But we’ll get to that later.</p>

<h2 id="back-to-type-members">Back to type members</h2>

<p>Let us translate the working existential variant we discovered above
to the <code class="highlighter-rouge">PList[MList]</code> form of the function, though.  What is the
existential equivalent to <code class="highlighter-rouge">mlenLengthTP</code>?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">mlenLengthTP</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xss</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">MList.Aux</span><span class="o">[</span><span class="kt">T</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="n">xss</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
    <span class="k">case</span> <span class="nc">PCons</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">mlength</span><span class="o">(</span><span class="n">h</span><span class="o">)</span> <span class="o">+</span> <span class="n">mlenLengthTP</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="n">mlenLength</span><span class="o">(</span><span class="n">xss</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">MList</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="n">mlenLengthTP</span><span class="o">(</span><span class="n">xss</span><span class="o">)</span>

<span class="nc">TmTp5</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">38</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">tmtp.MList</span><span class="o">]</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">tmtp.MList.Aux</span><span class="o">[</span><span class="kt">this.T</span><span class="o">]]</span>
  <span class="n">mlenLengthTP</span><span class="o">(</span><span class="n">xss</span><span class="o">)</span>
               <span class="o">^</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">MList</code> is equivalent to <code class="highlighter-rouge">MList {type T = E} forSome {type E}</code>.  We
can prove that directly in Scala.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">MList</span> <span class="kt">=:=</span> <span class="o">(</span><span class="kt">MList</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="kt">=</span> <span class="kt">E</span><span class="o">}</span> <span class="k">forSome</span> <span class="o">{</span><span class="k">type</span> <span class="kt">E</span><span class="o">})]</span>
<span class="n">res0</span><span class="k">:</span> <span class="o">=:=[</span><span class="kt">tmtp.MList</span>,<span class="kt">tmtp.MList</span><span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="kt">=</span> <span class="kt">E</span><span class="o">}</span> <span class="k">forSome</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">E</span> <span class="o">}]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>That’s why we could use <code class="highlighter-rouge">runStSource</code> to infer a type parameter for
the existential <code class="highlighter-rouge">S</code> in
<a href="/blog/2015/07/23/type-projection.html#type-parameters-see-existentially">the last post</a>:
the scope is on the outside, so there’s exactly one type parameter to
infer.  So the scoping problem now looks very similar to the
<code class="highlighter-rouge">PList</code>-in-<code class="highlighter-rouge">PList</code> problem, and we can write:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">mlenLengthE</span><span class="o">(</span><span class="n">xss</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">MList.Aux</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span> <span class="k">forSome</span> <span class="o">{</span><span class="k">type</span> <span class="kt">E</span><span class="o">})</span>
  <span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">mlenLengthTP</span><span class="o">(</span><span class="n">xss</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="a-triangular-generalization">A triangular generalization</h2>

<p>Once again, <code class="highlighter-rouge">mlenLengthE</code> demands proof that each sublist of <code class="highlighter-rouge">xss</code> has
the same element type, by virtue of the position of its <code class="highlighter-rouge">forSome</code>
scope.  We can’t satisfy that with <code class="highlighter-rouge">elists</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mlenLengthE</span><span class="o">(</span><span class="n">elists</span><span class="o">)</span>
</code></pre></div></div>

<p>Or, we <em>shouldn’t</em> be able to, anyway.
<a href="https://issues.scala-lang.org/browse/SI-9410">Sometimes, the wrong thing happens.</a>
We get the right error when we try to invoke <code class="highlighter-rouge">mlenLengthTP</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mlenLengthTP</span><span class="o">(</span><span class="n">elists</span><span class="o">)</span>

<span class="nc">TmTp5</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">43</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">tmtp.MList</span><span class="o">]</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">tmtp.PList</span><span class="o">[</span><span class="kt">tmtp.MList.Aux</span><span class="o">[</span><span class="kt">this.T</span><span class="o">]]</span>
    <span class="o">(</span><span class="n">which</span> <span class="n">expands</span> <span class="n">to</span><span class="o">)</span>  <span class="n">tmtp</span><span class="o">.</span><span class="nc">PList</span><span class="o">[</span><span class="kt">tmtp.MList</span><span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="kt">=</span> <span class="kt">this.T</span><span class="o">}]</span>
<span class="n">mlenLengthTP</span><span class="o">(</span><span class="n">elists</span><span class="o">)</span>
             <span class="o">^</span>
</code></pre></div></div>

<p>So we have <code class="highlighter-rouge">mlenLengthE</code> $\equiv_m$ <code class="highlighter-rouge">mlenLengthTP</code>.  <code class="highlighter-rouge">mlenLength</code>,
however, is incompatible with both; neither is more general than the
other!  What we really want is a function that is more general than
all three, and subsumes all their definitions.  Here it is, in two
variants: one half-type-parameterized, the other wholly existential.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">mlenLengthTP2</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">MList</span><span class="o">](</span><span class="n">xss</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="n">xss</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
    <span class="k">case</span> <span class="nc">PCons</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">mlength</span><span class="o">(</span><span class="n">h</span><span class="o">)</span> <span class="o">+</span> <span class="n">mlenLengthTP2</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="n">mlenLengthE2</span><span class="o">(</span><span class="n">xss</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="k">_</span> <span class="k">&lt;:</span> <span class="kt">MList</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="n">xss</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
    <span class="k">case</span> <span class="nc">PCons</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">mlength</span><span class="o">(</span><span class="n">h</span><span class="o">)</span> <span class="o">+</span> <span class="n">mlenLengthTP2</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>We’ve woven a tangled web, so here are, restated, the full
relationships for the <code class="highlighter-rouge">MList</code>-in-<code class="highlighter-rouge">PList</code> functions above.</p>

<ol>
  <li><code class="highlighter-rouge">mlenLengthTP2</code> $\equiv_m$ <code class="highlighter-rouge">mlenLengthE2</code></li>
  <li><code class="highlighter-rouge">mlenLengthTP</code> $\equiv_m$ <code class="highlighter-rouge">mlenLengthE</code></li>
  <li>$\neg($<code class="highlighter-rouge">mlenLength</code> $&lt;:_m$ <code class="highlighter-rouge">mlenLengthE</code>$)$</li>
  <li>$\neg($<code class="highlighter-rouge">mlenLengthE</code> $&lt;:_m$ <code class="highlighter-rouge">mlenLength</code>$)$</li>
  <li>$\neg($<code class="highlighter-rouge">mlenLength</code> $&lt;:_m$ <code class="highlighter-rouge">mlenLengthTP</code>$)$</li>
  <li>$\neg($<code class="highlighter-rouge">mlenLengthTP</code> $&lt;:_m$ <code class="highlighter-rouge">mlenLength</code>$)$</li>
  <li><code class="highlighter-rouge">mlenLengthTP2</code> $&lt;_m$ <code class="highlighter-rouge">mlenLengthTP</code></li>
  <li><code class="highlighter-rouge">mlenLengthTP2</code> $&lt;_m$ <code class="highlighter-rouge">mlenLength</code></li>
  <li><code class="highlighter-rouge">mlenLengthTP2</code> $&lt;_m$ <code class="highlighter-rouge">mlenLengthE</code></li>
  <li><code class="highlighter-rouge">mlenLengthE2</code> $&lt;_m$ <code class="highlighter-rouge">mlenLengthTP</code></li>
  <li><code class="highlighter-rouge">mlenLengthE2</code> $&lt;_m$ <code class="highlighter-rouge">mlenLength</code></li>
  <li><code class="highlighter-rouge">mlenLengthE2</code> $&lt;_m$ <code class="highlighter-rouge">mlenLengthE</code></li>
</ol>

<p>Moreover, the full existential in <code class="highlighter-rouge">mlenLengthE2</code> is shorthand for:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">PList</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="k">forSome</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">MList</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">E2</span>
  <span class="o">}</span> <span class="k">forSome</span> <span class="o">{</span><span class="k">type</span> <span class="kt">E2</span><span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>…a nested existential, though not in the meaning I intend in the title
of this article.  You can prove it with <code class="highlighter-rouge">=:=</code>, as above.</p>

<p>And I say all this simply as a means of saying that <em>this</em> is what
you’re signing up for when you decide to “simplify” your code by using
type members instead of parameters and leaving off the refinements
that make them concrete.</p>

<p>In
<a href="/blog/2015/07/30/values-never-change-types.html">the next part, “Values never change types”</a>,
we’ll get some idea of why working with existential types can be so
full of compiler errors, especially when allowing for mutation and
impure functions.</p>

<p><em>This article was tested with Scala 2.11.7 and Java 1.8.0_45.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Mon, 27 Jul 2015 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2015/07/27/nested-existentials.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2015/07/27/nested-existentials.html</guid>
      </item>
    
      <item>
        <title>Type projection isn't that specific</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><em>This is the fourth of a series of articles on “Type Parameters and
Type Members”.  If you haven’t yet, you should
<a href="/blog/2015/07/13/type-members-parameters.html">start at the beginning</a>,
which introduces code we refer to throughout this article without
further ado.</em></p>

<p>In the absence of the <code class="highlighter-rouge">Aux</code> trick presented at the end of
<a href="/blog/2015/07/19/forget-refinement-aux.html#why-t0-what%E2%80%99s-aux">the previous article</a>,
the continuous use of structural refinement to accomplish basic tasks
admittedly imposes a high cognitive load.  That is to say, it’s a lot
of work to say something that ought to be very simple.</p>

<p>Some people go looking for a solution, and find something that almost
seems to make sense:
<a href="http://www.scala-lang.org/files/archive/spec/2.11/03-types.html#type-projection">type projection</a>,
or <code class="highlighter-rouge">MList#T</code> in terms of
<a href="/blog/2015/07/13/type-members-parameters.html#two-lists-all-alike">our ongoing example</a>.
But <strong>type projection is, in almost all cases, too vague to really
solve problems you have using type members</strong>.</p>

<h2 id="a-good-reason-to-use-type-members">A good reason to use type members</h2>

<p>Let’s see a simple example.  Here’s a sort of “value emitter”, that
operates in the space of some state, emitting a new value with each
step.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">StSource</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">S</span>
  <span class="k">def</span> <span class="n">init</span><span class="k">:</span> <span class="kt">S</span>            <span class="c1">// create the initial state
</span>  <span class="k">def</span> <span class="n">emit</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">S</span><span class="o">)</span> <span class="c1">// emit a value, and update state
</span><span class="o">}</span>

<span class="k">object</span> <span class="nc">StSource</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Aux</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S0</span><span class="o">]</span> <span class="k">=</span> <span class="nc">StSource</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span><span class="k">type</span> <span class="kt">S</span> <span class="o">=</span> <span class="n">S0</span><span class="o">}</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S0</span><span class="o">](</span><span class="n">i</span><span class="k">:</span> <span class="kt">S0</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">S0</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">S0</span><span class="o">))</span><span class="k">:</span> <span class="kt">Aux</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S0</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">StSource</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">type</span> <span class="kt">S</span> <span class="o">=</span> <span class="n">S0</span>
      <span class="k">def</span> <span class="n">init</span> <span class="k">=</span> <span class="n">i</span>
      <span class="k">def</span> <span class="n">emit</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S0</span><span class="o">)</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Unlike <code class="highlighter-rouge">MList</code>, there are actually good reasons to use type members
for the “state” in this sort of type definition; i.e. there are
reasonable designs in which you want to use member <code class="highlighter-rouge">S</code> existentially.
Thus, depending on how we intend to use it, it seems to meet our first
rule of thumb about when to use type members, as described in
<a href="/blog/2015/07/13/type-members-parameters.html#when-is-existential-ok">the first article of this series</a>.</p>

<h2 id="a-failed-attempt-at-simplified-emitting">A failed attempt at simplified emitting</h2>

<p>So, under this theory, you’ve got some values of type <code class="highlighter-rouge">StSource[A]</code>
lying around.  And you want a simple function to take a source and its
state, and return the “next” value and the new state.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">runStSource</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ss</span><span class="k">:</span> <span class="kt">StSource</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">s</span><span class="k">:</span> <span class="kt">??</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">??</span><span class="o">)</span> <span class="k">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">emit</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
</code></pre></div></div>

<p>But what do you put where the <code class="highlighter-rouge">??</code> is?  The surprising guess is often
<code class="highlighter-rouge">StSource[A]#S</code>.  After all, it means “the <code class="highlighter-rouge">StSource</code>’s <code class="highlighter-rouge">S</code>”, and
we’re trying to talk about an <code class="highlighter-rouge">StSource</code>’s <code class="highlighter-rouge">S</code>, right?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">runStSource</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ss</span><span class="k">:</span> <span class="kt">StSource</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">s</span><span class="k">:</span> <span class="kt">StSource</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">#</span><span class="n">S</span><span class="o">)</span>
  <span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">StSource</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">#</span><span class="n">S</span><span class="o">)</span> <span class="k">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">emit</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>

<span class="nc">TmTp4</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">22</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">s.</span><span class="k">type</span> <span class="o">(</span><span class="kt">with</span> <span class="kt">underlying</span> <span class="k">type</span> <span class="kt">tmtp4.StSource</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">#</span><span class="kt">S</span><span class="o">)</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">ss.S</span>
  <span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">StSource</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">#</span><span class="n">S</span><span class="o">)</span> <span class="k">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">emit</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
                                 <span class="o">^</span>
</code></pre></div></div>

<p>Setting aside that it won’t compile with the above signature—the usual
outcome of experiments with type projection, that the types aren’t
strong enough to be workable without cheating by casting—the reality
<em>sounds</em> so close to the above that it is understandable that type
projection is often confused with something useful.</p>

<div class="side-note">
  There <em>are</em> uses for type projection.  But they are so rare, so
  exotic (they look
  <a href="https://github.com/scalaz/scalaz/blob/bdd6d5653313b10af08efdc6884cbbefe41051a2/core/src/main/scala/scalaz/Unapply.scala#L404-L409">like this</a>),
  and even the legitimate ones better off rewritten to avoid them,
  that the safer assumption is that you’ve gone down the wrong path if
  you’re trying to use them at all.  My suggestion can usually be
  phrased something like “move it to a companion object”.
</div>

<p>In reality, <code class="highlighter-rouge">StSource[A]#S</code> means <em>some</em> <code class="highlighter-rouge">StSource</code>’s <code class="highlighter-rouge">S</code>.  Not the
one you gave, just any particular one.  It’s the supertype of all
possible <code class="highlighter-rouge">S</code> choices.  So, the failure of the above signature is like
the failure of <code class="highlighter-rouge">mdropFirstE</code> from
<a href="/blog/2015/07/16/method-equiv.html#when-are-two-methods-less-alike">the second post of this series</a>:
a failure to relate types strongly enough.  The problem with
<code class="highlighter-rouge">mdropFirstE</code> was failure to relate the result type to argument type,
whereas the problem with <code class="highlighter-rouge">runStSource</code> is to fail to relate the two
arguments’ types to each other.</p>

<h2 id="type-parameters-see-existentially">Type parameters see existentially</h2>

<p>As with <code class="highlighter-rouge">mdropFirstE</code>, one correct solution here is, again, lifting the
member to a method type parameter.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">runStSource</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S</span><span class="o">](</span><span class="n">ss</span><span class="k">:</span> <span class="kt">StSource.Aux</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">S</span><span class="o">],</span> <span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">S</span><span class="o">)</span> <span class="k">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">emit</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
</code></pre></div></div>

<p>The surprising feature of this sort of signature is that it can be
invoked on <code class="highlighter-rouge">ss</code> arguments of type <code class="highlighter-rouge">StSource[A]</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val ss: StSource[Int] = StSource(0){i: Int =&gt; (i, i)}
ss: tmtp4.StSource[Int] = tmtp4.StSource$$anon$1@300b5011

scala&gt; runStSource(ss, ss.init)
res0: (Int, ss.S) = (0,0)
</code></pre></div></div>

<p>In other words, <strong>methods can assign names to unspecified, existential
type members</strong>.  So even though we have a value whose type doesn’t
refine <code class="highlighter-rouge">S</code>, Scala still infers this type as the <code class="highlighter-rouge">S</code> argument to pass
to <code class="highlighter-rouge">runStSource</code>.</p>

<p>By analogy with type parameters, though, this isn’t too surprising.
<a href="/blog/2015/07/16/method-equiv.html">We’ve already seen</a>
that <code class="highlighter-rouge">copyToZeroE</code> inferred its argument’s existential parameter to
pass along to the named parameter to <code class="highlighter-rouge">copyToZeroP</code>, in the second part
of this series.  We even saw it apply directly to type members when
<code class="highlighter-rouge">mdropFirstE</code> was able to invoke <code class="highlighter-rouge">mdropFirstT</code>.  However, for whatever
reason, we’re used to existential parameters being able to do this;
even Java manages the task.  But it just seems <em>odder</em> that merely
calling a method can create a whole refinement <code class="highlighter-rouge">{...}</code> raincloud, from
scratch, filling in the blanks with sensible types along the way.</p>

<p>It’s completely sound, though.  An <code class="highlighter-rouge">StSource</code> [that exists as a value]
<em>must</em> have an <code class="highlighter-rouge">S</code>, even if we existentialized it away.  So, as with
<code class="highlighter-rouge">_</code>s, let’s just give it a name to pass as the inferred type
parameter.  It makes a whole lot more sense than supposing
<code class="highlighter-rouge">StSource[A]#S</code> will just do what I mean.</p>

<p>In a future post, we’ll use this “infer the whole refinement” feature
to demonstrate that some of the most magical-seeming Scala type system
features aren’t really so magical.  But before we get to that, we need
to see just why existentials are anything but “wildcards”, and why it
doesn’t <em>always</em> make sense to be able to lift existentials like <code class="highlighter-rouge">S</code>
to type parameters.  That’s coming in
<a href="/blog/2015/07/27/nested-existentials.html">the next post, “Nested existentials”</a>.</p>

<p><em>This article was tested with Scala 2.11.7.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 23 Jul 2015 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2015/07/23/type-projection.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2015/07/23/type-projection.html</guid>
      </item>
    
      <item>
        <title>What happens when I forget a refinement?</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><em>This is the third of a series of articles on “Type Parameters and
Type Members”.  If you haven’t yet, you should
<a href="/blog/2015/07/13/type-members-parameters.html">start at the beginning</a>,
which introduces code we refer to throughout this article without
further ado.</em></p>

<p>As I mentioned
<a href="/blog/2015/07/16/method-equiv.html#when-are-two-methods-less-alike">in the previous article</a>,
the error of the <code class="highlighter-rouge">mdropFirstE</code> signature, taking <code class="highlighter-rouge">MList</code> and returning
merely <code class="highlighter-rouge">MList</code>, was to fail to relate the input element type to the
output element type.  This mistake is an easy one to make when failure
is the default behavior.</p>

<p>By contrast, <strong>when we try this with <code class="highlighter-rouge">PList</code>, the compiler helpfully
points out our error</strong>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">pdropFirst</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">PList</span><span class="o">)</span><span class="k">:</span> <span class="kt">PList</span> <span class="o">=</span> <span class="o">???</span>

<span class="nc">TmTp3</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">6</span><span class="kt">:</span> <span class="kt">class</span> <span class="kt">PList</span> <span class="kt">takes</span> <span class="k">type</span> <span class="kt">parameters</span>
  <span class="k">def</span> <span class="n">pdropFirst</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">PList</span><span class="o">)</span><span class="k">:</span> <span class="kt">PList</span> <span class="o">=</span> <span class="o">???</span>
                             <span class="o">^</span>
<span class="nc">TmTp3</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">6</span><span class="kt">:</span> <span class="kt">class</span> <span class="kt">PList</span> <span class="kt">takes</span> <span class="k">type</span> <span class="kt">parameters</span>
  <span class="k">def</span> <span class="n">pdropFirst</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">PList</span><span class="o">)</span><span class="k">:</span> <span class="kt">PList</span> <span class="o">=</span> <span class="o">???</span>
                     <span class="o">^</span>
</code></pre></div></div>

<h2 id="what-happens-when-i-misspell-a-refinement">What happens when I misspell a refinement?</h2>

<p>There is another mistake that type members open you up to. I have been
using the very odd type parameter—and member—name <code class="highlighter-rouge">T</code>.
Java developers will find this choice very ordinary, but the name of
choice for the discerning Scala programmer is <code class="highlighter-rouge">A</code>.  So suppose I
attempted to correct <code class="highlighter-rouge">mdropFirstE</code>’s type as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">mdropFirstE2</span><span class="o">[</span><span class="kt">T0</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">MList</span> <span class="o">{</span><span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="kt">T0</span><span class="o">})</span> <span class="k">=</span>
  <span class="n">xs</span><span class="o">.</span><span class="n">uncons</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">MNil</span><span class="o">()</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">tail</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>This method compiles, but I cannot invoke it!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">mdropFirstE2</span><span class="o">(</span><span class="nc">MNil</span><span class="o">[</span><span class="kt">Int</span><span class="o">]())</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">20</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">tmtp.MNil</span><span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">Int</span><span class="o">}</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">tmtp.MList</span><span class="o">{</span><span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="kt">?</span><span class="o">}</span>
       <span class="n">mdropFirstE2</span><span class="o">(</span><span class="nc">MNil</span><span class="o">[</span><span class="kt">Int</span><span class="o">]())</span>
                             <span class="o">^</span>

<span class="o">&gt;</span> <span class="n">mdropFirstE2</span><span class="o">(</span><span class="nc">MCons</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">42</span><span class="o">,</span> <span class="nc">MNil</span><span class="o">[</span><span class="kt">Int</span><span class="o">]()))</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">20</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">tmtp.MCons</span><span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">Int</span><span class="o">}</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">tmtp.MList</span><span class="o">{</span><span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="kt">?</span><span class="o">}</span>
       <span class="n">mdropFirstE2</span><span class="o">(</span><span class="nc">MCons</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">42</span><span class="o">,</span> <span class="nc">MNil</span><span class="o">[</span><span class="kt">Int</span><span class="o">]()))</span>
                              <span class="o">^</span>
</code></pre></div></div>

<p>That’s because <code class="highlighter-rouge">MList {type A = T0}</code> is a perfectly reasonable
intersection type: values of this type have <em>both</em> the type <code class="highlighter-rouge">MList</code> in
their supertype tree somewhere, <em>and</em> a type member named <code class="highlighter-rouge">A</code>, which
is bound to <code class="highlighter-rouge">T0</code>.  In terms of subtyping relationships:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">MList</span> <span class="o">{</span><span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">T0</span><span class="o">}</span> <span class="k">&lt;:</span> <span class="nc">MList</span>
<span class="c1">// and unrelatedly,
</span><span class="nc">MList</span> <span class="o">{</span><span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">T0</span><span class="o">}</span> <span class="k">&lt;:</span> <span class="o">{</span><span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">T0</span><span class="o">}</span>
</code></pre></div></div>

<p>That <code class="highlighter-rouge">MList</code> has no such type member <code class="highlighter-rouge">A</code> is irrelevant to the
intersection and refinement of types in Scala.  This type means “an
instance of the trait <code class="highlighter-rouge">MList</code>, with a type member named <code class="highlighter-rouge">A</code> set
to <code class="highlighter-rouge">T0</code>”.  This type member <code class="highlighter-rouge">A</code> could come from another trait mixed
with <code class="highlighter-rouge">MList</code> or an inline subclass.  Whether such a thing is
impossible to instantiate—due to <code class="highlighter-rouge">sealed</code>, <code class="highlighter-rouge">final</code>, or anything
else—is also irrelevant; <strong>types with no values are meaningful and
useful in both Java and Scala</strong>.</p>

<h2 id="why-t0--whats-aux">Why <code class="highlighter-rouge">T0</code>?  What’s <code class="highlighter-rouge">Aux</code>?</h2>

<p>A few of the methods on <code class="highlighter-rouge">MList</code> we have seen so far take a type
parameter <code class="highlighter-rouge">T0</code> instead of <code class="highlighter-rouge">T</code>.  This is just a mnemonic trick; I’m
saying “I would write <code class="highlighter-rouge">T</code> here if <code class="highlighter-rouge">scalac</code> would let me”, which I have
borrowed from
<a href="https://github.com/scalaz/scalaz/blob/v7.1.3/core/src/main/scala/scalaz/Unapply.scala#L217"><code class="highlighter-rouge">scalaz.Unapply</code></a>.
Let’s try to implement <code class="highlighter-rouge">def MNil</code> taking a <code class="highlighter-rouge">T</code> instead.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">MNil</span><span class="o">[</span><span class="kt">T</span><span class="o">]()</span><span class="k">:</span> <span class="kt">MNil</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">T</span><span class="o">}</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">MNil</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">T</span>
  <span class="o">}</span>

<span class="c1">// Scala complains, though:
</span><span class="nc">TmTp3</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">15</span><span class="kt">:</span> <span class="kt">illegal</span> <span class="kt">cyclic</span> <span class="kt">reference</span> <span class="kt">involving</span> <span class="k">type</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="nc">MNil</span><span class="o">[</span><span class="kt">T</span><span class="o">]()</span><span class="k">:</span> <span class="kt">MNil</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">T</span><span class="o">}</span> <span class="k">=</span>
                                <span class="o">^</span>
</code></pre></div></div>

<p>This is a scoping problem; the refinement type makes the member <code class="highlighter-rouge">T</code>
shadow our method type parameter <code class="highlighter-rouge">T</code>.  We dealt with the problem in
<code class="highlighter-rouge">MList#uncons</code> and <code class="highlighter-rouge">MCons#tail</code> as well, way back in section “Two
lists, all alike” of
<a href="/blog/2015/07/13/type-members-parameters.html#two-lists-all-alike">the first part</a>,
in those cases by outer-scoping the <code class="highlighter-rouge">T</code> as
<code class="highlighter-rouge">self.T</code> instead.</p>

<p><strong>When defining a type with members, you should define an <code class="highlighter-rouge">Aux</code> type
in your companion that converts the member to a type parameter.</strong> The
name <code class="highlighter-rouge">Aux</code> is a convention I have borrowed from
<a href="https://github.com/milessabin/shapeless/blob/shapeless-2.2.4/core/src/main/scala/shapeless/ops/hlists.scala#L1501">Shapeless ops</a>.
This is pretty much boilerplate; in this case, add this to
<code class="highlighter-rouge">object MList</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Aux</span><span class="o">[</span><span class="kt">T0</span><span class="o">]</span> <span class="k">=</span> <span class="nc">MList</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">T0</span><span class="o">}</span>
</code></pre></div></div>

<p>Now you can write <code class="highlighter-rouge">MList.Aux[Int]</code> instead of <code class="highlighter-rouge">MList {type T = Int}</code>.
Here’s <code class="highlighter-rouge">mdropFirstT</code>’s signature rewritten in this style.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">mdropFirstT2</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">MList.Aux</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">MList.Aux</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Furthermore, because the member <code class="highlighter-rouge">T</code> is not in scope for <code class="highlighter-rouge">Aux</code>’s type
parameter position, you can take method type parameters named <code class="highlighter-rouge">T</code> and
sensibly write <code class="highlighter-rouge">MList.Aux[T]</code> without the above error.  You can see
this in the immediately preceding example.  But, stepping back a bit,
this should be considered an advantage for type parameters more
generally; <code class="highlighter-rouge">PList</code> doesn’t have this problem in the first place.</p>

<p><strong>Using <code class="highlighter-rouge">Aux</code> also helps you avoid the errors of forgetting to specify
or misspelling a type member</strong>, as described at the beginning of this
article.  With <code class="highlighter-rouge">Aux</code>, as with ordinary parameterized types, a missing
argument is caught by the compiler, and misspelling the parameter name
is impossible.</p>

<p>In
<a href="/blog/2015/07/23/type-projection.html">the next part, “Type projection isn’t that specific”</a>,
we’ll see why something that, at first glance, seems
like a workable alternative to either refinement or the <code class="highlighter-rouge">Aux</code> trick,
doesn’t work out as well as people wish it would.</p>

<p><em>This article was tested with Scala 2.11.7.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 19 Jul 2015 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2015/07/19/forget-refinement-aux.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2015/07/19/forget-refinement-aux.html</guid>
      </item>
    
      <item>
        <title>When are two methods alike?</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><em>This is the second of a series of articles on “Type Parameters and
Type Members”.  If you haven’t yet, you should
<a href="/blog/2015/07/13/type-members-parameters.html">start at the beginning</a>,
which introduces code we refer to throughout this article without
further ado.</em></p>

<p><a href="/blog/2015/07/13/type-members-parameters.html#when-is-existential-ok">In the last part</a>,
we just saw two method types that, though different, are effectively
the same: those of <code class="highlighter-rouge">plengthT</code> and <code class="highlighter-rouge">plengthE</code>.  We have rules for
deciding when an existential parameter can be lifted into a method
type parameter—or a method type parameter lowered to an
existential—but there are other pairs of method types I want to
explore that are the same, or very close.  So let’s talk about how we
determine this equivalence.</p>

<p>A method <em>R</em> is more general than or as general as <em>Q</em> if <em>Q</em> may be
implemented by only making a call to <em>R</em>, passing along the arguments.
By more general, we mean <em>R</em> can be invoked in all the situations that
<em>Q</em> can be invoked in, and more besides.  Let us call the result of
this test $R &lt;:_m Q$ (where $&lt;:_m$ is pronounced “party duck”); if
the test of <em>Q</em> making a call to <em>R</em> fails, then $\neg(R &lt;:_m Q)$.</p>

<p>If $Q &lt;:_m R$ and $R &lt;:_m Q$, then the two method types are
<em>equivalent</em>; that is, neither has more expressive power than the
other, since each can be implemented merely by invoking the other and
doing nothing else.  We write this as $Q \equiv_m R$.  Likewise, if
$R &lt;:_m Q$ and $\neg(Q &lt;:_m R)$, that is, <em>Q</em> can be written by
calling <em>R</em>, but not vice versa, then <em>R</em> is <em>strictly more general</em>
than <em>Q</em>, or $R &lt;_m Q$.</p>

<p>What the concrete method—the one actually doing stuff, not invoking
the other one—does is irrelevant, for the purposes of this test,
because this is about types.  That matters because sometimes, in
Scala, as in Java, the body will compile in one of the methods, but
not the other.  Let’s see an example that doesn’t compile.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.collection.mutable.ArrayBuffer</span>

<span class="k">def</span> <span class="n">copyToZero</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">ArrayBuffer</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
  <span class="n">xs</span> <span class="o">+=</span> <span class="n">xs</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="nc">TmTp2</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">9</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="o">(</span><span class="kt">some</span> <span class="kt">other</span><span class="o">)</span><span class="k">_</span><span class="kt">$1</span><span class="o">(</span><span class="kt">in</span> <span class="kt">value</span> <span class="kt">xs</span><span class="o">)</span>
 <span class="kt">required:</span> <span class="k">_</span><span class="kt">$1</span><span class="o">(</span><span class="kt">in</span> <span class="kt">value</span> <span class="kt">xs</span><span class="o">)</span>
    <span class="kt">xs</span> <span class="kt">+=</span> <span class="kt">xs</span><span class="o">(</span><span class="err">0</span><span class="o">)</span>
            <span class="kt">^</span>
</code></pre></div></div>

<p>Likewise, the Java version has a similar problem, though the error
message doesn’t give as good a hint as to what’s going on.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kt">void</span> <span class="nf">copyToZero</span><span class="o">(</span><span class="kd">final</span> <span class="n">List</span><span class="o">&lt;?&gt;</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">xs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
<span class="o">}</span>

<span class="n">TmTp2</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">11</span><span class="o">:</span>  <span class="nl">error:</span> <span class="n">no</span> <span class="n">suitable</span> <span class="n">method</span> <span class="n">found</span> <span class="k">for</span> <span class="nf">add</span><span class="o">(</span><span class="n">CAP</span><span class="err">#</span><span class="mi">1</span><span class="o">)</span>
        <span class="n">xs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
          <span class="o">^</span>
</code></pre></div></div>

<p>Luckily, in both Java and Scala, we have an <em>equivalent</em> method type,
from lifting the existential (misleadingly called <em>wildcard</em> in Java
terminology) to a method type parameter.</p>

<p>We can apply this transformation to put the method implementation
somewhere it will compile.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">copyToZeroE</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">ArrayBuffer</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
  <span class="n">copyToZeroP</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>

<span class="k">private</span> <span class="k">def</span> <span class="n">copyToZeroP</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">ArrayBuffer</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
  <span class="n">xs</span> <span class="o">+=</span> <span class="n">xs</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</code></pre></div></div>

<p>Similarly, in Java,</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">copyToZeroE</span><span class="o">(</span><span class="kd">final</span> <span class="n">List</span><span class="o">&lt;?&gt;</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">copyToZeroP</span><span class="o">(</span><span class="n">xs</span><span class="o">);</span>
<span class="o">}</span>

<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">copyToZeroP</span><span class="o">(</span><span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">T</span> <span class="n">zv</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="n">xs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">zv</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The last gives a hint as to what’s going on, both here and in the
compiler errors above: in <code class="highlighter-rouge">copyToZeroP</code>’s body, the list element type
has a name, <code class="highlighter-rouge">T</code>; we can use the name to create variables, and the
compiler can rely on the name as well.  The compiler, ideally,
shouldn’t care about whether the name can be written, but that one of
the above compiles and the other doesn’t is telling.</p>

<p>If you were to define a variable to hold the result of getting the
first element in the list in either version of <code class="highlighter-rouge">copyToZeroE</code>, how
would you do that?  In Java, the reason this doesn’t work is
straightforward: you would have to declare the variable to be of type
<code class="highlighter-rouge">Object</code>, but that type isn’t specific enough to allow the variable to
be used as an argument to <code class="highlighter-rouge">xs.add</code>.</p>

<p>Scala’s type-inferred variables don’t help here; Scala considers the
existential type to be scoped to <code class="highlighter-rouge">xs</code>, and makes the definition of
<code class="highlighter-rouge">zv</code> independent of <code class="highlighter-rouge">xs</code> by breaking the type relationship, and
crushing the inferred type of <code class="highlighter-rouge">zv</code> to <code class="highlighter-rouge">Any</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">copyToZeroE</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">ArrayBuffer</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">zv</span> <span class="k">=</span> <span class="n">xs</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
  <span class="n">xs</span> <span class="o">+=</span> <span class="n">zv</span>
<span class="o">}</span>

<span class="nc">TmTp2</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">19</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">zv.</span><span class="k">type</span> <span class="o">(</span><span class="kt">with</span> <span class="kt">underlying</span> <span class="k">type</span> <span class="kt">Any</span><span class="o">)</span>
 <span class="kt">required:</span> <span class="k">_</span><span class="kt">$1</span>
    <span class="n">xs</span> <span class="o">+=</span> <span class="n">zv</span>
          <span class="o">^</span>
</code></pre></div></div>

<p>When we call the type-parameterized variant to implement the
existential variant, with the real implementation residing in the
former, we are just helping the compiler along by using the equivalent
method type; in the simpler case of the former, both <code class="highlighter-rouge">scalac</code> and
<code class="highlighter-rouge">javac</code> manage to infer that the type <code class="highlighter-rouge">T</code> should be the (otherwise
unspeakable) existential.  <strong>Method equivalence and generality make it
possible to write methods, safely, that could not be written
directly.</strong></p>

<h2 id="why-are-existentials-harder-to-think-about">Why are existentials harder to think about?</h2>

<p>I think we, as humans, may have even more difficulty with the lack of
names for existentials than the compilers do.  The name “unspeakable”,
which I have borrowed from Jon Skeet’s <em>C# in Depth</em>, is telling: even
in our heads, our thought processes are shaped by language.  We tame
the mathematics of programming with symbols, with names.  Existentials
and their “unspeakable” names rob us of the tools to talk about them,
to think about them.</p>

<p>Java has done its practitioners two great disservices here.  One: by
calling its existentials “wildcards”.  They are not “wildcards”, in
any commonly or uncommonly understood sense.  If you suppose your
preexisting notions of “wildcards” to apply to these much more exotic
creatures, you will confidently stroll into the darkness until you
trip and fall off a cliff.  They are only <em>superficially</em> “wildcards”.
The effect of this sorry attempt at avoiding new terminology is
chiefly to cheat Java programmers out of learning what’s really going
on.  (We will explore some of this more exotic behavior
<a href="/blog/2015/07/27/nested-existentials.html">in a later post</a>.)</p>

<p>Two: by
<a href="https://docs.oracle.com/javase/tutorial/extra/generics/methods.html">encouraging use of existential signatures</a>
like <code class="highlighter-rouge">mdropFirstE</code> over parameterized versions like <code class="highlighter-rouge">mdropFirstT</code> that
do not require the same kind of mental gymnastics.</p>

<p>For lifting these type parameters is how we can reclaim the power we
lost in the debacle of the unspeakable names.  We name them, and in so
doing can once more talk and think about them without exhausting
ourselves by gesticulating wildly, comforting ourselves with
fairytales of “wildcards”.  Because in parameter lifting, we have
found a <em>true</em> analogy.</p>

<h2 id="when-are-two-methods-less-alike">When are two methods less alike?</h2>

<p>Now, let’s examine another pair of methods, and apply our test to
them.</p>

<p>Let’s say we want to write the equivalent of this method for <code class="highlighter-rouge">MList</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">pdropFirst</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">PNil</span><span class="o">()</span>
    <span class="k">case</span> <span class="nc">PCons</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">t</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>According to the <code class="highlighter-rouge">PList</code> ⇔ <code class="highlighter-rouge">MList</code> conversion rules given
<a href="/blog/2015/07/13/type-members-parameters.html#when-is-existential-ok">in the previous article</a>,
section “Why all the <code class="highlighter-rouge">{type T = ...}</code>?”, the equivalent for <code class="highlighter-rouge">MList</code>
should be</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">mdropFirstT</span><span class="o">[</span><span class="kt">T0</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">MList</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">T0</span><span class="o">})</span>
  <span class="k">:</span> <span class="kt">MList</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">T0</span><span class="o">}</span> <span class="k">=</span>
  <span class="n">xs</span><span class="o">.</span><span class="n">uncons</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">MNil</span><span class="o">()</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">tail</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Let us try to drop the refinements.  That seems to compile:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">mdropFirstE</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">MList</span><span class="o">)</span><span class="k">:</span> <span class="kt">MList</span> <span class="o">=</span>
  <span class="n">xs</span><span class="o">.</span><span class="n">uncons</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">MNil</span><span class="o">()</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">tail</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>It certainly looks nicer.  However, while <code class="highlighter-rouge">mdropFirstE</code> can be
implemented by calling <code class="highlighter-rouge">mdropFirstT</code>, passing the type parameter
<code class="highlighter-rouge">xs.T</code>, the opposite is not true; <code class="highlighter-rouge">mdropFirstT</code> $&lt;_m$ <code class="highlighter-rouge">mdropFirstE</code>,
or, <code class="highlighter-rouge">mdropFirstT</code> is <em>strictly more general</em>.</p>

<p>In this case, the reason is that <code class="highlighter-rouge">mdropFirstE</code> fails to relate the
argument’s <code class="highlighter-rouge">T</code> to the result’s <code class="highlighter-rouge">T</code>; you could implement <code class="highlighter-rouge">mdropFirstE</code>
as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">mdropFirstE</span><span class="o">[</span><span class="kt">T0</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">MList</span><span class="o">)</span><span class="k">:</span> <span class="kt">MList</span> <span class="o">=</span>
  <span class="nc">MCons</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">42</span><span class="o">,</span> <span class="nc">MNil</span><span class="o">())</span>
</code></pre></div></div>

<p>The stronger type of <code class="highlighter-rouge">mdropFirstT</code> forbids such shenanigans.  However,
I can just tell you that largely because I’m already comfortable with
existentials; how could you figure that out if you’re just starting
out with these tools?  You don’t have to; the beauty of the
equivalence test is that you can apply it mechanically.  <strong>Knowing
nothing about the mechanics of the parameterization and existentialism
of the types involved, you can work out with the equivalence test</strong>
that <code class="highlighter-rouge">mdropFirstT</code> $&lt;_m$ <code class="highlighter-rouge">mdropFirstE</code>, and therefore, that you can’t
get away with simply dropping the refinements.</p>

<h2 id="method-likeness-and-subtyping-all-alike">Method likeness and subtyping, all alike</h2>

<p>If you know what the symbol <code class="highlighter-rouge">&lt;:</code> means in Scala, or perhaps you’ve
read
<a href="http://www.scala-lang.org/files/archive/spec/2.11/03-types.html#relations-between-types">SLS §3.5 “Relations between types”</a>,
you might think, “gosh, method equivalence and generality look awfully
familiar.”</p>

<p>Indeed, the thing we’re talking about is very much like subtyping and
type equality!  In fact, every type-equal pair of methods <em>M</em>₁ and
<em>M</em>₂ also pass our method equivalence test, and every pair of methods
<em>M</em>₃ and <em>M</em>₄ where $M_3 &lt;: M_4$ passes our <em>M</em>₄-calls-<em>M</em>₃ test.
So $M_1 \equiv M_2$ implies $M_1 \equiv_m M_2$, and
$M_3 &lt;: M_4$ implies $M_3 &lt;:_m M_4$.</p>

<p>We even follow many of the same rules as the type relations.  We have
transitivity: if <em>M</em>₁ can call <em>M</em>₂ to implement itself, and <em>M</em>₂ can
call <em>M</em>₃ to implement itself, obviously we can snap the pointer and
have <em>M</em>₁ call <em>M</em>₃ directly.  Likewise, every method type is
equivalent to itself: reflexivity.  Likewise, if a method <em>M</em>₁ is
strictly more general than <em>M</em>₂, obviously <em>M</em>₂ cannot be strictly
more general than <em>M</em>₁: antisymmetricity.  And we even copy the
relationship between ≡ and &lt;: themselves: just as $T_1 \equiv T_2$
implies $T_1 &lt;: T_2$, so $R \equiv_m Q$ implies $R &lt;:_m Q$.</p>

<p>Scala doesn’t understand the notion of method equivalence we’ve
defined above, though.  So you can’t, say, implement an abstract
method in a subclass using an equivalent or more general form, at
least directly; you have to <code class="highlighter-rouge">override</code> the Scala way, and call the
alternative form yourself, if that’s what you want.</p>

<p>I do confess to one oddity in my terminology: <strong>the method that has
more specific type is <em>the more general method</em>.</strong> I hope the example
of <code class="highlighter-rouge">mdropFirstT</code> $&lt;:_m$ <code class="highlighter-rouge">mdropFirstE</code> justifies my choice.
<code class="highlighter-rouge">mdropFirstT</code> has more specific type, and rejects more
implementations, such as the one that returns a list with <code class="highlighter-rouge">42</code> in it
above.  Thus, it has fewer implementations, in the same way that more
specific types have fewer values inhabiting them.  But it can be used
in more circumstances, so it is “more general”.  The generality in
terms of when a method can be used is directly proportional to the
specificity of its type.</p>

<h2 id="javas-edge-of-insanity">Java’s edge of insanity</h2>

<p>Now we have enough power to demonstrate that Scala’s integration with
Java generics is faulty.  Or, more fairly, that Java’s generics are
faulty.</p>

<p>Consider this method type, in Scala:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">goshWhatIsThis</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
</code></pre></div></div>

<p>This is a pretty specific method type; there are not too many
implementations.  Of course you can always perform a side effect; we
don’t track that in Scala’s type system.  But what can it return?
Just <code class="highlighter-rouge">t</code>.</p>

<p>Specifically, you can’t return <code class="highlighter-rouge">null</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TmTp2</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">36</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">Null</span><span class="o">(</span><span class="kt">null</span><span class="o">)</span>
 <span class="kt">required:</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="n">goshWhatIsThis</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="kc">null</span>
                                   <span class="o">^</span>
</code></pre></div></div>

<p>Well now, let’s convert this type to Java:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">holdOnNow</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We got away with that!  And, indeed, we can call <code class="highlighter-rouge">holdOnNow</code> to
implement <code class="highlighter-rouge">goshWhatIsThis</code>, and vice versa; they’re <em>equivalent</em>.  But
the type says we can’t return <code class="highlighter-rouge">null</code>!</p>

<p>The problem is that Java adds an implicit upper bound, because it
assumes generic type parameters can only have class types chosen for
them; in Scala terms, <code class="highlighter-rouge">[T &lt;: AnyRef]</code>.  If we encode this constraint
in Scala, Scala gives us the correct error.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">holdOnNow</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">AnyRef</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="nc">TmTp2</span><span class="o">.</span><span class="n">holdOnNow</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>

<span class="k">def</span> <span class="n">goshWhatIsThis</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">holdOnNow</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>

<span class="nc">TmTp2</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">38</span><span class="kt">:</span> <span class="kt">inferred</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">do</span> <span class="n">not</span> <span class="n">conform</span>
<span class="o">⤹</span> <span class="n">to</span> <span class="n">method</span> <span class="n">holdOnNow</span><span class="ss">'s </span><span class="k">type</span> <span class="kt">parameter</span> <span class="kt">bounds</span> <span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">AnyRef</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">goshWhatIsThis</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">holdOnNow</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
                                   <span class="o">^</span>
</code></pre></div></div>

<p>This is forgivable on Scala’s part, because it’d be annoying to add
<code class="highlighter-rouge">&lt;: AnyRef</code> to your generic methods just because you called some Java
code and it’s probably going to work out fine.  I blame <code class="highlighter-rouge">null</code>, and
while I’m at it, I blame <code class="highlighter-rouge">Object</code> having any methods at all, too.
We’d be better off without these bad features.</p>

<p>In
<a href="/blog/2015/07/19/forget-refinement-aux.html">the next part, “What happens when I forget a refinement?”</a>,
we’ll talk about what happens when you forget refinements for things
like <code class="highlighter-rouge">MList</code>, and how you can avoid that while simplifying your
type-member-binding code.</p>

<p><em>This article was tested with Scala 2.11.7 and Java 1.8.0_45.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 16 Jul 2015 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2015/07/16/method-equiv.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2015/07/16/method-equiv.html</guid>
      </item>
    
      <item>
        <title>Type members are [almost] type parameters</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><em>This is the first of a series of articles on “Type Parameters and Type
Members”.</em></p>

<p>Type members like <code class="highlighter-rouge">Member</code></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Blah</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Member</span>
<span class="o">}</span>
</code></pre></div></div>

<p>and parameters like <code class="highlighter-rouge">Param</code></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Blah2</span><span class="o">[</span><span class="kt">Param</span><span class="o">]</span>
</code></pre></div></div>

<p>have more similarities than differences.  The choice of which to use
for a given situation is usually a matter of convenience.  In brief, a
rule of thumb: <strong>a type parameter is usually more convenient and
harder to screw up, but if you intend to use it existentially in most
cases, changing it to a member is probably better</strong>.</p>

<p>Here, and in later posts, we will discuss what on earth that means,
among other things.  In this series of articles on <em>Type Parameters
and Type Members</em>, I want to tackle a variety of Scala types that look
very different, but are really talking about the same thing, or
almost.</p>

<h2 id="two-lists-all-alike">Two lists, all alike</h2>

<p>To illustrate, let’s see two versions of
<a href="http://www.artima.com/pins1ed/working-with-lists.html">the functional list</a>.
Typically, it isn’t used existentially, so the usual choice of
parameter over member fits our rule of thumb above.  It’s instructive
anyway, so let’s see it.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">PList</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">PNil</span><span class="o">[</span><span class="kt">T</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">PList</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">PCons</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">PList</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>

<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">MList</span> <span class="o">{</span><span class="n">self</span> <span class="k">=&gt;</span>
  <span class="k">type</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="n">uncons</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">MCons</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="kt">=</span> <span class="kt">self.T</span><span class="o">}]</span>
<span class="o">}</span>
<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">MNil</span> <span class="k">extends</span> <span class="nc">MList</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">uncons</span> <span class="k">=</span> <span class="nc">None</span>
<span class="o">}</span>
<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">MCons</span> <span class="k">extends</span> <span class="nc">MList</span> <span class="o">{</span><span class="n">self</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">head</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">val</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">MList</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">self.T</span><span class="o">}</span>
  <span class="k">def</span> <span class="n">uncons</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">self</span><span class="k">:</span> <span class="kt">MCons</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">self.T</span><span class="o">})</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We’re not quite done; we’re missing a way to <em>make</em> <code class="highlighter-rouge">MNil</code>s and
<code class="highlighter-rouge">MCons</code>es, which <code class="highlighter-rouge">PNil</code> and <code class="highlighter-rouge">PCons</code> have already provided
for themselves, by virtue of being <code class="highlighter-rouge">case class</code>es.  But it’s already
pretty clear that <em>a type parameter is a more straightforward way to
define this particular data type</em>.</p>

<p>The instance creation takes just a bit more scaffolding for our
examples:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">MNil</span><span class="o">[</span><span class="kt">T0</span><span class="o">]()</span><span class="k">:</span> <span class="kt">MNil</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">T0</span><span class="o">}</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">MNil</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">T0</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="nc">MCons</span><span class="o">[</span><span class="kt">T0</span><span class="o">](</span><span class="n">hd</span><span class="k">:</span> <span class="kt">T0</span><span class="o">,</span> <span class="n">tl</span><span class="k">:</span> <span class="kt">MList</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">T0</span><span class="o">})</span>
  <span class="k">:</span> <span class="kt">MCons</span> <span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">T0</span><span class="o">}</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">MCons</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">T0</span>
    <span class="k">val</span> <span class="n">head</span> <span class="k">=</span> <span class="n">hd</span>
    <span class="k">val</span> <span class="n">tail</span> <span class="k">=</span> <span class="n">tl</span>
  <span class="o">}</span>
</code></pre></div></div>

<h2 id="why-all-the-type-t--">Why all the <code class="highlighter-rouge">{type T = ...}</code>?</h2>

<p>After all, isn’t the virtue of type members that we don’t have to pass
the type around everywhere?</p>

<p>Let’s see what happens when we attempt to apply that theory.  Suppose
we remove only one of the
<a href="http://www.scala-lang.org/files/archive/spec/2.11/03-types.html#compound-types"><em>refinement</em>s</a>
above, as these <code class="highlighter-rouge">{...}</code> rainclouds at the type level are called.
Let’s remove the one in <code class="highlighter-rouge">val tail</code>, so <code class="highlighter-rouge">class MCons</code> looks like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">MCons</span> <span class="k">extends</span> <span class="nc">MList</span> <span class="o">{</span><span class="n">self</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">head</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">val</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">MList</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now let us put a couple members into the list, and add them together.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">nums</span> <span class="k">=</span> <span class="nc">MCons</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">MCons</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="nc">MNil</span><span class="o">()))</span><span class="k">:</span> <span class="kt">MCons</span><span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">Int</span><span class="o">}</span>
<span class="n">nums</span><span class="k">:</span> <span class="kt">tmtp.MCons</span><span class="o">{</span><span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="kt">Int</span><span class="o">}</span> <span class="k">=</span> <span class="n">tmtp</span><span class="o">.</span><span class="nc">MList$$anon$2</span><span class="k">@</span><span class="mi">3</span><span class="n">c649f69</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">nums</span><span class="o">.</span><span class="n">head</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">nums.T</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res1</span> <span class="o">+</span> <span class="n">res1</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">4</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">nums</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">uncons</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">head</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">nums.tail.T</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res3</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">-</span> <span class="n">res2</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">21</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">value</span> <span class="kt">-</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">a</span> <span class="kt">member</span> <span class="kt">of</span> <span class="kt">nums.tail.T</span>
       <span class="n">res3</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">-</span> <span class="n">res2</span><span class="o">)</span>
                  <span class="o">^</span>
</code></pre></div></div>

<p>When we took the refinement off of <code class="highlighter-rouge">tail</code>, we eliminated any evidence
about what its <code class="highlighter-rouge">type T</code> might be.  We only know that <em>it must be some
type</em>.  That’s what <em>existential</em> means.</p>

<p><strong>In terms of type parameters, <code class="highlighter-rouge">MList</code> is like <code class="highlighter-rouge">PList[_]</code>, and <code class="highlighter-rouge">MList
{type T = Int}</code> is like <code class="highlighter-rouge">PList[Int]</code>.</strong>  For the former, we say that
the member, or parameter, is existential.</p>

<h2 id="when-is-existential-ok">When is existential OK?</h2>

<p>Despite the limitation implied by the error above, there <em>are</em> useful
functions that can be written on the existential version.  Here’s one
of the simplest:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">mlength</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">MList</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="n">xs</span><span class="o">.</span><span class="n">uncons</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="mi">0</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">mlength</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="n">tail</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>For the type parameter equivalent, the parameter on the argument is
usually carried out or <em>lifted</em> to the function, like so:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">plengthT</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
    <span class="k">case</span> <span class="nc">PCons</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">plengthT</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>By the conversion rules above, though, we should be able to write an
existential equivalent of <code class="highlighter-rouge">mlength</code> for <code class="highlighter-rouge">PList</code>, and indeed we can:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">plengthE</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
    <span class="k">case</span> <span class="nc">PCons</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">plengthE</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>There’s another simple rule we can follow when determining whether we
can rewrite in an existential manner.</p>

<ol>
  <li>When a type parameter appears only in one argument, and</li>
  <li>appears nowhere in the result type,</li>
</ol>

<p>we should always, ideally, be able to write the function in an
existential manner.  (We will discuss why it’s only “ideally” in
<a href="/blog/2015/07/16/method-equiv.html">the next article</a>.)</p>

<p>You can demonstrate this to yourself by having the parameterized
variant (e.g. <code class="highlighter-rouge">plengthT</code>) call the existential variant
(e.g. <code class="highlighter-rouge">plengthE</code>), and, voilà, it compiles, so it must be right.</p>

<p>This hints at what is usually, though not always, <strong>an advantage for
type parameters: you have to ask for an existential, rather than
silently getting one just because you forgot a refinement</strong>.  We will
discuss
<a href="/blog/2015/07/19/forget-refinement-aux.html">what happens when you forget one in a later post</a>.</p>

<h2 id="equivalence-as-a-learning-tool">Equivalence as a learning tool</h2>

<p>Scala is large enough that very few understand all of it.  Moreover,
there are many aspects of it that are poorly understood in general.</p>

<p>So why focus on how different features are similar?  When we
understand one area of Scala well, but another one poorly, we can form
sensible ideas about the latter by drawing analogies with the former.
This is how we solve problems with computers in general: we create an
informal model in our heads, which we translate to a
mathematical statement that a program can interpret, and it gives back
a result that we can translate back to our informal model.</p>

<p>My guess is that type parameters are much better understood than type
members, but that existentials via type members are better understood
than existentials introduced by <code class="highlighter-rouge">_</code> or <code class="highlighter-rouge">forSome</code>, though I’d wager
that neither form of existential is particularly well understood.</p>

<p>By knowing about equivalences and being able to discover more, you
have a powerful tool for understanding unfamiliar aspects of Scala:
just translate the problem back to what you know and think about what
it means there, because the conclusion will still hold when you
translate it forward.  (Category theorists, eat your hearts out.)</p>

<p>In this vein, we will next generalize the above rule about existential
methods, discovering a simple tool for determining whether two
method types <em>in general</em> are equivalent, whereby things you know
about one easily carry over to the other.  We will also explore
methods that <em>cannot</em> be written in the existential style, at least
under Scala’s restrictions.</p>

<p>That all happens in
<a href="/blog/2015/07/16/method-equiv.html">the next part, “When are two methods alike?”</a>.</p>

<p><em>This article was tested with Scala 2.11.7.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Mon, 13 Jul 2015 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2015/07/13/type-members-parameters.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2015/07/13/type-members-parameters.html</guid>
      </item>
    
      <item>
        <title>Existential types are not raw types</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><em>While this blog is typically strictly for Scala developers interested
in strongly-typed programming, this particular article is of interest
to Java developers as well.  You don’t need to know Scala to follow
along.</em></p>

<p>Scala makes a <em>welcome</em> simplification in its type system:
<a href="http://docs.scala-lang.org/tutorials/tour/generic-classes.html">type arguments</a>
are always required.  That is, in Java, you may (unsafely) leave off
the type arguments for compatibility with pre-1.5 code,
e.g. <code class="highlighter-rouge">java.util.List</code>, forming a
<a href="http://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html"><em>raw type</em></a>.
Scala does not permit this, and requires you to pass a type argument.</p>

<p>The most frequent trouble people have with this rule is being unable
to implement some Java method with missing type arguments in its
signature, e.g. one that takes a raw <code class="highlighter-rouge">List</code> as an argument.  Let us
see why they have trouble, and why this is a good thing.</p>

<h2 id="existentials-are-safe-raw-types-are-not">Existentials are safe, raw types are not</h2>

<p>Stripping the type argument list, e.g. going from
<code class="highlighter-rouge">java.util.List&lt;String&gt;</code> to <code class="highlighter-rouge">java.util.List</code> is <em>an unsafe cast</em>.
<a href="http://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html"><em>Wildcarding</em></a>
the same type argument, e.g. going from <code class="highlighter-rouge">java.util.List&lt;String&gt;</code> to
<code class="highlighter-rouge">java.util.List&lt;?&gt;</code>, is <em>safe</em>.  The latter type is written
<code class="highlighter-rouge">java.util.List[_]</code>, or <code class="highlighter-rouge">java.util.List[T] forSome {type T}</code>, in
Scala.  In both Java and Scala, this is an
<a href="http://www.artima.com/pins1ed/combining-scala-and-java.html#29.3">existential type</a>.
As compiled with <code class="highlighter-rouge">-Xlint:rawtypes -Xlint:unchecked</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TestEx</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">words</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"hi"</span><span class="o">,</span> <span class="s">"there"</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="c1">// TestEx.java:17: warning: [rawtypes] found raw type: List</span>
    <span class="c1">//  missing type arguments for generic class List&lt;E&gt;</span>
    <span class="c1">//  where E is a type-variable:</span>
    <span class="c1">//    E extends Object declared in interface List</span>
    <span class="c1">//                  ↓</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">List</span> <span class="n">wordsRaw</span> <span class="o">=</span> <span class="n">words</span><span class="o">();</span>

    <span class="c1">// there is no warning for this</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;?&gt;</span> <span class="n">wordsET</span> <span class="o">=</span> <span class="n">words</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Also note that there is no warning for the equivalent to <code class="highlighter-rouge">wordsET</code> in
Scala.  Because it, like javac, knows that it’s safe.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">TestEx</span><span class="o">.</span><span class="n">words</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">[</span><span class="kt">hi</span>, <span class="kt">there</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">wordsET</span> <span class="k">=</span> <span class="nc">TestEx</span><span class="o">.</span><span class="n">words</span> <span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>
<span class="n">wordsET</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=</span> <span class="o">[</span><span class="kt">hi</span>, <span class="kt">there</span><span class="o">]</span>
</code></pre></div></div>

<h2 id="raw-types-are-bad--stop-using-them">Raw Types are bad.  Stop using them</h2>

<p>The reason that existentials are safe is that the rules in place for
values of existential type are consistent with the rest of the generic
system, whereas raw types contradict those rules, resulting in code
that should not typecheck, and only does for legacy code support.  We
can see this in action with two Java methods.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">addThing</span><span class="o">(</span><span class="kd">final</span> <span class="n">List</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">xs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">42</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">swapAround</span><span class="o">(</span><span class="kd">final</span> <span class="n">List</span><span class="o">&lt;?&gt;</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">xs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">84</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>These methods are the same, except for the use of raw types versus
existentials.  However, the second does not compile:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TestEx.java:26: error: no suitable method found for add(int)
        xs.add(84);
          ^
    method Collection.add(CAP#1) is not applicable
      (argument mismatch; int cannot be converted to CAP#1)
    method List.add(CAP#1) is not applicable
      (argument mismatch; int cannot be converted to CAP#1)
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?
</code></pre></div></div>

<p>Why forbid adding 42 to the list?  The element type of list is
unknown.  The answer lies in that statement: <em>its unknownness isn’t a
freedom for the body of the method, it’s a restriction</em>.  The rawtype
version treats its lack of knowledge as a freedom, and the caller pays
for it by having its data mangled.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">testIt</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">someWords</span> <span class="o">=</span> <span class="n">words</span><span class="o">();</span>
    <span class="n">addThing</span><span class="o">(</span><span class="n">someWords</span><span class="o">);</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Contents of someWords after addThing:"</span><span class="o">);</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">someWords</span><span class="o">);</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Well that seems okay, what's the last element?"</span><span class="o">);</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">someWords</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">someWords</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And it compiles:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TestEx.java:23: warning: [unchecked] unchecked call to add(E) as a
                         member of the raw type List
        xs.add(42);
              ^
  where E is a type-variable:
    E extends Object declared in interface List
</code></pre></div></div>

<p>But when we try to run it:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">TestEx</span><span class="o">.</span><span class="n">testIt</span><span class="o">()</span>
<span class="nc">Contents</span> <span class="n">of</span> <span class="n">someWords</span> <span class="n">after</span> <span class="n">addThing</span><span class="k">:</span>
<span class="err">[</span><span class="kt">hi</span><span class="o">,</span> <span class="n">there</span><span class="o">,</span> <span class="mi">42</span><span class="err">]</span>
<span class="nc">Well</span> <span class="n">that</span> <span class="n">seems</span> <span class="n">okay</span><span class="o">,</span> <span class="n">what</span><span class="ss">'s </span><span class="n">the</span> <span class="n">last</span> <span class="n">element</span><span class="o">?</span>
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ClassCastException</span><span class="k">:</span> <span class="kt">java.lang.Integer</span> <span class="kt">cannot</span> <span class="kt">be</span> <span class="kt">cast</span> <span class="kt">to</span>
                              <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">String</span>
  <span class="n">at</span> <span class="n">rawtypes</span><span class="o">.</span><span class="nc">TestEx</span><span class="o">.</span><span class="n">testIt</span><span class="o">(</span><span class="nc">TestEx</span><span class="o">.</span><span class="n">java</span><span class="k">:</span><span class="err">32</span><span class="o">)</span>
  <span class="o">...</span> <span class="mi">43</span> <span class="n">elided</span>
</code></pre></div></div>

<p>It is a mistake to think that just because some code throws
<code class="highlighter-rouge">ClassCastException</code>, it must be to blame for a type error.  This line
is blameless.  It is the fault of the unchecked cast when we called
<code class="highlighter-rouge">addThing</code>, and more specifically, the unsafe assumption about the
<code class="highlighter-rouge">List</code>’s element type that was made in its body.</p>

<h2 id="existentials-are-much-better">Existentials are much better</h2>

<p>When we used the wildcard, we were forbidden from doing the unsafe
thing.  But what kinds of things can we do with the safe, existential
form?  Here’s one:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">swapAroundAux</span><span class="o">(</span><span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">xs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">swapAround</span><span class="o">(</span><span class="kd">final</span> <span class="n">List</span><span class="o">&lt;?&gt;</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">swapAroundAux</span><span class="o">(</span><span class="n">xs</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In other words: let <code class="highlighter-rouge">E</code> be the <em>unknown</em> element type of <code class="highlighter-rouge">xs</code>.
<code class="highlighter-rouge">xs.get()</code> has type <code class="highlighter-rouge">E</code>, and <code class="highlighter-rouge">xs.add</code> has argument type <code class="highlighter-rouge">E</code>.  They
line up, so this is okay, no matter what the element type of <code class="highlighter-rouge">xs</code>
turns out to be.  Let’s try a test:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">w</span> <span class="k">=</span> <span class="nc">TestEx</span><span class="o">.</span><span class="n">words</span>
<span class="n">w</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">[</span><span class="kt">hi</span>, <span class="kt">there</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">TestEx</span><span class="o">.</span><span class="n">swapAround</span><span class="o">(</span><span class="n">w</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">w</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">hi</span>
</code></pre></div></div>

<p>The body of <code class="highlighter-rouge">swapAround</code> is guaranteed not to mangle its argument by
the type checker, so we, as a caller, can safely call it, and know
that our argument’s type integrity is protected.</p>

<p>Scala has more features to let us get away without <code class="highlighter-rouge">swapAroundAux</code>.
This translation uses a lowercase
<a href="http://www.scala-lang.org/files/archive/spec/2.11/08-pattern-matching.html#type-parameter-inference-for-constructor-patterns."><em>type variable pattern</em></a>
to name the existential.  To the right of the <code class="highlighter-rouge">=&gt;</code>, we can declare
variables of type <code class="highlighter-rouge">e</code> and use <code class="highlighter-rouge">e</code> to construct more types, while still
referring to the <code class="highlighter-rouge">_</code> in the <code class="highlighter-rouge">xs</code> argument’s type.  But in this case,
we just do the same as <code class="highlighter-rouge">swapAroundAux</code> above.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">swapAround</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
  <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">xs2</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="kt">e</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">xs2</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">xs2</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
  <span class="o">}</span>
</code></pre></div></div>

<h2 id="crushing-the-existential">Crushing the existential</h2>

<p>Let’s consider the <code class="highlighter-rouge">xs.get()</code> and <code class="highlighter-rouge">xs.add</code> methods, which have return
type and argument type <code class="highlighter-rouge">E</code>, respectively.  As you can’t write the name
of an existential type in Java, what happens when we “crush” it,
choosing the closest safe type we can write the name of?</p>

<p>First, we can simplify by considering every existential to be bounded.
That is, instead of <code class="highlighter-rouge">E</code>, we think about <code class="highlighter-rouge">E extends Object super
Nothing</code>, or <code class="highlighter-rouge">E &lt;: Any &gt;: Nothing</code> in Scala.  While <code class="highlighter-rouge">Object</code> or <code class="highlighter-rouge">Any</code>
is the “top” of the type hierarchy, which <em>every</em> type is a subtype
of, <code class="highlighter-rouge">Nothing</code> is the “bottom”, sadly left out of Java’s type system,
which <em>every</em> type is a <em>supertype</em> of.</p>

<p>For <code class="highlighter-rouge">get</code>, the <code class="highlighter-rouge">E</code> appears in the result type, a <em>covariant</em> position.
So we crush it to the upper bound, <code class="highlighter-rouge">Any</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">wordsET</span><span class="o">.</span><span class="n">get</span> <span class="k">_</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Any</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>However, for <code class="highlighter-rouge">add</code>, the <code class="highlighter-rouge">E</code> appears in the argument type, a
<em>contravariant</em> position.  So if it is to be crushed, it must be
crushed to the lower bound, <code class="highlighter-rouge">Nothing</code>, instead.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">wordsET</span><span class="k">:</span> <span class="kt">java.util.Collection</span><span class="o">[</span><span class="k">_</span><span class="o">]).</span><span class="n">add</span> <span class="k">_</span> <span class="k">:</span> <span class="o">(</span><span class="kt">Any</span> <span class="o">=&gt;</span> <span class="kt">Boolean</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">12</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="k">_</span><span class="kt">$1</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span> <span class="n">where</span> <span class="k">type</span> <span class="k">_</span><span class="kt">$1</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span>
              <span class="o">(</span><span class="n">wordsET</span><span class="k">:</span> <span class="kt">java.util.Collection</span><span class="o">[</span><span class="k">_</span><span class="o">]).</span><span class="n">add</span> <span class="k">_</span> <span class="k">:</span> <span class="o">(</span><span class="kt">Any</span> <span class="o">=&gt;</span> <span class="kt">Boolean</span><span class="o">)</span>
                                                 <span class="o">^</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">wordsET</span><span class="k">:</span> <span class="kt">java.util.Collection</span><span class="o">[</span><span class="k">_</span><span class="o">]).</span><span class="n">add</span> <span class="k">_</span> <span class="k">:</span> <span class="o">(</span><span class="kt">Nothing</span> <span class="o">=&gt;</span> <span class="kt">Boolean</span><span class="o">)</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Nothing</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>Each occurrence of an existential in a signature may be crushed
independently.  However, a variable that appears once but may be
distributed to either side, such as in a generic type parameter, is
<em>invariant</em>, and may not be crushed at that point.  That is why the
existential is preserved in the inferred type of <code class="highlighter-rouge">wordsET</code> itself.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">wordsET</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=</span> <span class="o">[</span><span class="kt">hi</span>, <span class="kt">there</span><span class="o">]</span>
</code></pre></div></div>

<p>Herein lies something closer to a formalization of the problem with
raw types: they crush existential occurrences in contravariant and
invariant positions to the upper bound, <code class="highlighter-rouge">Object</code>, when the only safe
positions to crush in this way are the covariant positions.</p>

<h2 id="how-do-list-and-list-relate">How do <code class="highlighter-rouge">List</code> and <code class="highlighter-rouge">List&lt;?&gt;</code> relate?</h2>

<p>It is well understood that, in Java, <code class="highlighter-rouge">List&lt;String&gt;</code> is not a subtype
of <code class="highlighter-rouge">List&lt;Object&gt;</code>.  In Scala terms, this is because all type
parameters are <em>invariant</em>, which has exactly the meaning it had in
the previous section.  However, that doesn’t mean it’s impossible to
draw subtyping relationships between different <code class="highlighter-rouge">List</code>s for different
type arguments; they must merely be mediated by existentials, as is
common in the Java standard library.</p>

<p>The basic technique is as follows: we can convert any <code class="highlighter-rouge">T</code> in <code class="highlighter-rouge">List&lt;T&gt;</code>
to <code class="highlighter-rouge">? extends T super T</code>.  Following that, we can raise the argument
to <code class="highlighter-rouge">extends</code> and lower the argument to <code class="highlighter-rouge">super</code> as we like.  A <code class="highlighter-rouge">?</code> by
itself, I have described above, is merely the most extreme course of
this formula you can take.  So <code class="highlighter-rouge">List&lt;T&gt;</code> for any <code class="highlighter-rouge">T</code> is a subtype of
<code class="highlighter-rouge">List&lt;?&gt;</code>.  (This only applies at one level of depth;
e.g. <code class="highlighter-rouge">List&lt;List&lt;T&gt;&gt;</code> is not necessarily a subtype of <code class="highlighter-rouge">List&lt;List&lt;?&gt;&gt;</code>.)</p>

<p>Does this mean that <code class="highlighter-rouge">List</code> is a subtype of <code class="highlighter-rouge">List&lt;?&gt;</code>?  Well, kind of.
Following the rule for specialization of method signatures in
subclasses, we should be able to override a method that returns
<code class="highlighter-rouge">List&lt;?&gt;</code> with one that returns <code class="highlighter-rouge">List</code>, and override a method that
takes <code class="highlighter-rouge">List</code> as an argument with one that takes <code class="highlighter-rouge">List&lt;?&gt;</code> as an
argument.  However, this is like building a house on a foam mattress:
the conversion that got us a raw type wasn’t sound in the first place,
so what soundness value does this relationship have?</p>

<h2 id="the-frequent-java-library-bug">The frequent Java library bug</h2>

<p>Let’s see the specific problem that people usually encounter in Scala.
Suppose <code class="highlighter-rouge">addThing</code>, defined above, is an instance member of <code class="highlighter-rouge">TestEx</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">TestEx2</span> <span class="kd">extends</span> <span class="n">TestEx</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addThing</span><span class="o">(</span><span class="kd">final</span> <span class="n">List</span><span class="o">&lt;?&gt;</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Or the Scala version:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TestEx3</span> <span class="k">extends</span> <span class="nc">TestEx</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">addThing</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">()</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">javac</code> gives us this error:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TestEx.java:48: error: name clash: addThing(List&lt;?&gt;) in TestEx2 and
                addThing(List) in TestEx have the same erasure, yet
                neither overrides the other
    public void addThing(final List&lt;?&gt; xs) {}
                ^
TestEx.java:47: error: method does not override or implement a method
                from a supertype
    @Override
    ^
</code></pre></div></div>

<p>scalac is forgiving, though.  I’m not sure how forgiving it is.
However, the forgiveness is unsound: it lets us return less specific
types when overriding methods than we got out.</p>

<h2 id="how-to-fix-it">How to fix it</h2>

<ol>
  <li>
    <p>Stop using raw types.</p>
  </li>
  <li>
    <p><strong>If you maintain a Java library with raw types in its API, you are
doing a disservice to your users.  Eliminate them.</strong></p>
  </li>
  <li>
    <p>If you are using such a library, report a bug, or submit a patch,
to eliminate the raw types.  If you add <code class="highlighter-rouge">-Xlint:rawtypes</code> to the
<code class="highlighter-rouge">javac</code> options, the compiler will tell you where you’re using
them.  Fix all the warnings, and you’re definitely not using raw
types anymore.</p>
  </li>
  <li>
    <p>Help Java projects, including your own, avoid introducing raw types
by adding <code class="highlighter-rouge">-Xlint:rawtypes</code> permanently to their <code class="highlighter-rouge">javac</code> options.
<strong><code class="highlighter-rouge">rawtypes</code> is more serious than <code class="highlighter-rouge">unchecked</code></strong>; even if you do not
care about <code class="highlighter-rouge">unchecked</code> warnings, you should still turn on and fix
<code class="highlighter-rouge">rawtypes</code> warnings.</p>
  </li>
</ol>

<p>You may also turn on <code class="highlighter-rouge">-Xlint:cast</code> to point out casts that are no
longer necessary now that your types are cleaner.  If possible, add
<code class="highlighter-rouge">-Werror</code> to your build as well, to convert <code class="highlighter-rouge">rawtypes</code> warnings to
errors.</p>

<h2 id="why-not-just-add-wildcards-automatically">Why not just add wildcards automatically?</h2>

<p>Adding wildcards isn’t a panacea.  For certain raw types, you need to
add a proper type parameter, even adding type parameters to your own
API.  The Internet has no copy and paste solutions to offer you; it
all depends on how to model your specific scenario.  Here are a few
possibilities.</p>

<ol>
  <li>
    <p>Pass a type argument representing what’s actually in the structure.
For example, replace <code class="highlighter-rouge">List</code> with <code class="highlighter-rouge">List&lt;String&gt;</code> if that’s what it
is.</p>
  </li>
  <li>
    <p>Pass a wildcard.</p>
  </li>
  <li>
    <p>Propagate the type argument outward.  For example, if you have a
method <code class="highlighter-rouge">List doThis(final List xs)</code>, maybe it should be <code class="highlighter-rouge">&lt;E&gt;
List&lt;E&gt; doThis(final List&lt;E&gt; xs)</code>.  Or if you have a <code class="highlighter-rouge">class
Blah&lt;X&gt;</code> containing a <code class="highlighter-rouge">List</code>, maybe it should be a <code class="highlighter-rouge">class Blah&lt;A,
X&gt;</code> containing a <code class="highlighter-rouge">List&lt;A&gt;</code>.  This is often the most flexible
option, but it can take time to implement.</p>
  </li>
  <li>
    <p>Combine any of these.  For example, in some circumstances, a more
flexible version of #3 would be to define <code class="highlighter-rouge">Blah&lt;A, X&gt;</code> containing a
<code class="highlighter-rouge">List&lt;? extends A&gt;</code>.</p>
  </li>
</ol>

<p>Wildcards and existentials are historically misunderstood in the Java
community; Scala developers have the advantage of more powerful
language tools for talking about them.  So <strong>if you are unsure of how
to eliminate some raw types, consider asking a Scala developer what to
do!</strong> Perhaps they will tell you “use Scala instead”, and maybe that’s
worth considering, but you’re likely to get helpful advice regardless
of how you feel about language advocacy.</p>

<h2 id="the-scala-philosophy">The Scala philosophy</h2>

<p>As you can see, the Java compatibility story in Scala is not as simple
as is advertised.  However, I favor the strong stance against this
unsound legacy feature.  If Scala can bring an end to the scourge of
raw types, it will have been worth the compatibility trouble.</p>

<p><em>This article was tested with Scala 2.11.5 and javac 1.8.0_31.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 26 Feb 2015 00:00:00 +0100</pubDate>
        <link>https://typelevel.org/blog/2015/02/26/rawtypes.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2015/02/26/rawtypes.html</guid>
      </item>
    
      <item>
        <title>Why is ADT pattern matching allowed?</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>One of the rules of
<a href="https://dl.dropboxusercontent.com/u/7810909/talks/parametricity/4985cb8e6d8d9a24e32d98204526c8e3b9319e33/parametricity.pdf">the Scalazzi Safe Scala Subset</a>
is “no type casing”; in other words, testing the type via
<code class="highlighter-rouge">isInstanceOf</code> or type patterns isn’t allowed.  It’s one of the most
important rules therein for preservation of free theorems.  Common
functional programming practice in Scala <em>seems</em> to violate this rule
in a subtle way.  However, as we will see, that practice carves out a
very specific exception to this rule that, morally, isn’t an exception
at all, carrying convenient advantages and none of the drawbacks.</p>

<h2 id="why-forbid-type-tests">Why forbid type tests?</h2>

<p>With the “no type tests” rule, we forbid writing functions like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">revmaybe</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">allInts</span> <span class="k">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">forall</span><span class="o">{</span><span class="k">case</span> <span class="k">_:</span><span class="kt">Int</span> <span class="o">=&gt;</span> <span class="kc">true</span>
                          <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span><span class="o">}</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">allInts</span><span class="o">)</span> <span class="n">xs</span><span class="o">.</span><span class="n">reverse</span> <span class="k">else</span> <span class="n">xs</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Which violates the
<a href="http://failex.blogspot.com/2013/06/fake-theorems-for-free.html">free theorem</a>
of <code class="highlighter-rouge">revmaybe</code>’s type <code class="highlighter-rouge">revmaybe(xs map f) = revmaybe(xs) map f</code>, as
follows.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">xs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="k">def</span> <span class="n">f</span><span class="o">(</span><span class="n">i</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">revmaybe</span><span class="o">(</span><span class="n">xs</span> <span class="n">map</span> <span class="n">f</span><span class="o">)</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Some</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">2</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">revmaybe</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span> <span class="n">map</span> <span class="n">f</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Some</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">3</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">2</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
</code></pre></div></div>

<h2 id="adts-are-ok-to-go">ADTs are OK to go</h2>

<p>On the other hand, the Scalazzi rules are totally cool with pattern
matching to separate the parts of
<a href="https://www.haskell.org/haskellwiki/Algebraic_data_type">ADTs</a>.  For
example, this is completely fine.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">headOption</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Even more exotic matches, where we bring type information forward into
runtime, are acceptable, as long as they’re in the context of ADTs.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AddExpr</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

<span class="k">def</span> <span class="n">eval</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">ex</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">ex</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">AddExpr</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="adts-use-type-tests">ADTs use type tests</h2>

<p>Let’s look at the compiled code of the <code class="highlighter-rouge">eval</code> body, specifically, the
<code class="highlighter-rouge">case</code> line.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>         <span class="mi">2</span><span class="o">:</span> <span class="n">aload_2</span>       
         <span class="mi">3</span><span class="o">:</span> <span class="n">instanceof</span>    <span class="err">#</span><span class="mi">60</span>                 <span class="c1">// class adts/AddExpr
</span>         <span class="mi">6</span><span class="o">:</span> <span class="n">ifeq</span>          <span class="mi">39</span>
         <span class="mi">9</span><span class="o">:</span> <span class="n">aload_2</span>       
        <span class="mi">10</span><span class="o">:</span> <span class="n">checkcast</span>     <span class="err">#</span><span class="mi">60</span>                 <span class="c1">// class adts/AddExpr
</span>        <span class="mi">13</span><span class="o">:</span> <span class="n">astore_3</span>      
        <span class="mi">14</span><span class="o">:</span> <span class="n">aload_3</span>       
        <span class="mi">15</span><span class="o">:</span> <span class="n">invokevirtual</span> <span class="err">#</span><span class="mi">63</span>                 <span class="c1">// Method adts/AddExpr.x:()I
</span>        <span class="mi">18</span><span class="o">:</span> <span class="n">istore</span>        <span class="mi">4</span>
        <span class="mi">20</span><span class="o">:</span> <span class="n">aload_3</span>       
        <span class="mi">21</span><span class="o">:</span> <span class="n">invokevirtual</span> <span class="err">#</span><span class="mi">66</span>                 <span class="c1">// Method adts/AddExpr.y:()I
</span>        <span class="mi">24</span><span class="o">:</span> <span class="n">istore</span>        <span class="mi">5</span>
        <span class="mi">26</span><span class="o">:</span> <span class="n">iload</span>         <span class="mi">4</span>
        <span class="mi">28</span><span class="o">:</span> <span class="n">iload</span>         <span class="mi">5</span>
        <span class="mi">30</span><span class="o">:</span> <span class="n">iadd</span>          
</code></pre></div></div>

<p>So, instead of calling <code class="highlighter-rouge">unapply</code> to presumably check whether <code class="highlighter-rouge">AddExpr</code>
matches, scalac checks and casts its argument to <code class="highlighter-rouge">AddExpr</code>.  Why does
it do that?  Let’s see if we could use <code class="highlighter-rouge">AddExpr.unapply</code> instead.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">AddExpr</span><span class="o">.</span><span class="n">unapply</span> <span class="k">_</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">adts.AddExpr</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>In other words, the <code class="highlighter-rouge">unapply</code> call can’t tell you whether an <code class="highlighter-rouge">Expr</code> is
an <code class="highlighter-rouge">AddExpr</code>; it can’t be called with arbitrary <code class="highlighter-rouge">Expr</code>.</p>

<p>The only actual check here is inserted by scalac as part of compiling
the pattern match expression, and it is a type test, supposedly
verboten under Scalazzi rules.  <code class="highlighter-rouge">headOption</code>, too, is implemented with
type tests and casts, not <code class="highlighter-rouge">unapply</code> calls.</p>

<p>We’ve exhorted Scala users to avoid type tests, but then turn around
and say that type tests are OK!  What’s going on?</p>

<h2 id="an-equivalent-form">An equivalent form</h2>

<p>In every case where we use pattern matching on an ADT, there’s an
equivalent way we could write the expression without pattern matching,
by adding an encoding of the whole ADT as a method on the class or
trait we use as the base type.  Let’s redefine the <code class="highlighter-rouge">Option</code> type with
such a method to see how this is done.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Maybe</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">nothing</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">just</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span>
<span class="o">}</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">MNothing</span><span class="o">[</span><span class="kt">T</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">Maybe</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">nothing</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">just</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span>
    <span class="n">nothing</span>
<span class="o">}</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Just</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">get</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Maybe</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">nothing</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">just</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span>
    <span class="n">just</span><span class="o">(</span><span class="n">get</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>It’s key to our reasoning that we completely avoid <code class="highlighter-rouge">match</code> in our
implementations; in other words, the <code class="highlighter-rouge">fold</code> is <em>matchless</em>.</p>

<p>With the <code class="highlighter-rouge">fold</code> method, the following two expressions are equivalent,
notwithstanding scalac’s difficulty optimizing the latter, even in the
presence of inlining.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="n">selector</span><span class="k">:</span> <span class="kt">Maybe</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">MNothing</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="s">"default case"</span>
  <span class="k">case</span> <span class="nc">Just</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">justcase</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">}</span>

<span class="n">selector</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="s">"default case"</span><span class="o">,</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">justcase</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
</code></pre></div></div>

<p>It’s a simple formula: the fold takes as many arguments as there are
cases, always returns the given, sole type parameter, and each
argument is a function that results in that same parameter.  There’s a
free theorem that a <code class="highlighter-rouge">fold</code> implementation on data structures without
recursion, like <code class="highlighter-rouge">Maybe</code>, can only invoke one of these arguments and
return the result directly, just as the pattern match does.</p>

<p>If you prefer the clarity of named cases, just use Scala’s named
arguments.  Here’s that last fold:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">selector</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="n">nothing</span> <span class="k">=</span> <span class="s">"default case"</span><span class="o">,</span>
              <span class="n">just</span> <span class="k">=</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">justcase</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
</code></pre></div></div>

<h2 id="gadt-folds">GADT folds</h2>

<p>Encoding <code class="highlighter-rouge">Expr</code> is a little bit more complicated.  For the full power
of the type, we have to turn to <code class="highlighter-rouge">Leibniz</code> to encode the matchless
<code class="highlighter-rouge">fold</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz.Leibniz</span><span class="o">,</span> <span class="nc">Leibniz</span><span class="o">.{===,</span> <span class="n">refl</span><span class="o">}</span>

<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Expr2</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">add</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">,</span> <span class="nc">Int</span> <span class="o">===</span> <span class="n">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">,</span>
              <span class="n">concat</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">String</span><span class="o">,</span> <span class="nc">String</span> <span class="o">===</span> <span class="n">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span>
<span class="o">}</span>
</code></pre></div></div>

<p>What does this mean?  The type <code class="highlighter-rouge">Int === T</code>, seen in the <code class="highlighter-rouge">add</code> argument
signature, is inhabited if and only if the type <code class="highlighter-rouge">T</code> <strong>is</strong> the type
<code class="highlighter-rouge">Int</code>.  So an implementation of <code class="highlighter-rouge">fold</code> can only call the <code class="highlighter-rouge">add</code>
function if it can prove that type equality.  There is, of course, one
that can:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AddExpr2</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr2</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span>
  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">add</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">,</span> <span class="nc">Int</span> <span class="o">===</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">,</span>
              <span class="n">concat</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">String</span><span class="o">,</span> <span class="nc">String</span> <span class="o">===</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span>
    <span class="n">add</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">refl</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Not only does <code class="highlighter-rouge">AddExpr2</code> know that <code class="highlighter-rouge">Expr2</code>’s type parameter is <code class="highlighter-rouge">Int</code>,
we must make the type substitution when implementing methods from
<code class="highlighter-rouge">Expr2</code>!  At that point it is enough to mention <code class="highlighter-rouge">refl</code>, the evidence
that every type is equal to itself, to satisfy <code class="highlighter-rouge">add</code>’s signature.</p>

<p>This may seem a little magical, but it is no less prosaic than
implementing <code class="highlighter-rouge">java.lang.Comparable</code> by making this substitution.  So
you can do this sort of thing every day even in Java.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="n">T</span> <span class="n">o</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">MyData</span> <span class="kd">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">MyData</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="n">MyData</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>   <span class="c1">// note T is replaced by MyData</span>
    <span class="c1">// ...</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>If only Java had higher kinds, you could go the rest of the way and
actually implement
<a href="https://www.haskell.org/haskellwiki/Generalised_algebraic_datatype#Motivating_example">GADTs</a>.</p>

<p>Moving on, let’s see another case for <code class="highlighter-rouge">Expr2</code>, and finally to tie it
all together, <code class="highlighter-rouge">eval2</code> with some extra constant data in for good
measure.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">ConcatExpr2</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr2</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span>
  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">add</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">,</span> <span class="nc">Int</span> <span class="o">===</span> <span class="nc">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">,</span>
              <span class="n">concat</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">String</span><span class="o">,</span> <span class="nc">String</span> <span class="o">===</span> <span class="nc">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span>
    <span class="n">concat</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">refl</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">eval2</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">ex</span><span class="k">:</span> <span class="kt">Expr2</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
  <span class="n">ex</span><span class="o">.</span><span class="n">fold</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">intIsT</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">intIsT</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">),</span>
          <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">strIsT</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">strIsT</span><span class="o">(</span><span class="s">"one"</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div></div>

<p>Using the <code class="highlighter-rouge">Leibniz</code> proof is, unfortunately, more involved than
producing it in the fold implementations.  See my previous posts,
<a href="/blog/2014/07/02/type_equality_to_leibniz.html">“A function from type equality to Leibniz”</a>
and
<a href="/blog/2014/09/20/higher_leibniz.html">“Higher Leibniz”</a>,
for many
details on applying <code class="highlighter-rouge">Leibniz</code> proof to make type transformations.</p>

<p>While the pattern matching <code class="highlighter-rouge">eval</code> didn’t have to explicitly apply type
equality evidence – it <em>just knew</em> that <code class="highlighter-rouge">Int</code> was <code class="highlighter-rouge">T</code> when the
<code class="highlighter-rouge">IntExpr</code> pattern matched – Scala has holes in its implementation,
discussed in the aforementioned posts on <code class="highlighter-rouge">Leibniz</code>, that sometimes
make the above implementation strategy an attractive choice even
though pattern matching is available.</p>

<h2 id="we-could-but-thats-good-enough-so-we-wont">We could, but that’s good enough, so we won’t</h2>

<p>You might have noticed that adding another case to <code class="highlighter-rouge">Expr</code> caused us
not only to implement an extra <code class="highlighter-rouge">fold</code>, but to add another argument to
the base <code class="highlighter-rouge">fold</code> to represent the new case, and then go through every
implementation to add that argument.  This isn’t so bad for just two
cases, but indeed has quadratic growth, to the point that adding a new
case to a large datatype is a majorly annoying project all by itself.</p>

<p>There is an interesting property of <code class="highlighter-rouge">fold</code>, though: the strategy isn’t
available for our first function, <code class="highlighter-rouge">revmaybe</code>, to discriminate
arguments of arbitrary type!  To do that, we would have to add a
signature like this to <code class="highlighter-rouge">Any</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">int</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">any</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">any</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
<span class="c1">// and, in the body of class Int
</span><span class="k">override</span> <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">int</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">any</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">int</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
</code></pre></div></div>

<p>Obviously, you cannot do this.</p>

<p>You can only add <code class="highlighter-rouge">fold</code> methods to types you know; I can only call
<code class="highlighter-rouge">fold</code> in <code class="highlighter-rouge">expr2</code> by virtue of the fact that I know that the argument
has type <code class="highlighter-rouge">Expr2[T]</code> for some <code class="highlighter-rouge">T</code>.  If the argument was just <code class="highlighter-rouge">T</code>, I
wouldn’t have enough static type information to call <code class="highlighter-rouge">fold</code>.  So the
use of <code class="highlighter-rouge">fold</code>s doesn’t break parametricity.  Equivalently, <strong>a pattern
match that could be implemented using a matchless fold also does not
break parametricity</strong>.</p>

<p>As we have seen, it is unfortunately inconvenient to actually go
through the bother of writing <code class="highlighter-rouge">fold</code> methods, when pattern matching is
there.  But it is enough to reason that <em>we could</em> write a matchless
<code class="highlighter-rouge">fold</code> and replace the pattern matching with it, to prove that the
pattern matching is safe, no matter how many underlying type tests
scalac might use to implement it.</p>

<p>A simple test follows: <strong>if you could write a matchless fold, and use
that instead, the pattern match is type-safe</strong>.</p>

<h2 id="a-selector-subtlety">A selector subtlety</h2>

<p>Here’s a pattern match that violates parametricity.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">selector</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">MNothing</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="s">"default case"</span>
  <span class="k">case</span> <span class="nc">Just</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">justcase</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Wait, but didn’t we rewrite that using a <code class="highlighter-rouge">fold</code> earlier?  Not quite.
Oh, I didn’t mention?  The type of <code class="highlighter-rouge">selector</code> is <code class="highlighter-rouge">T</code>, because we’re in
a function like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">notIdentity</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">selector</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span>
  <span class="c1">// match expression above goes here
</span></code></pre></div></div>

<p>Scala will permit this pattern match to go forward.  It doesn’t
require us to prove that the selector is of the ADT root type we
happened to define; that’s an arbitrary point as far as Scala’s
subtyping system is concerned.  All that is required is that the
static type of <code class="highlighter-rouge">selector</code> be a supertype of each of <code class="highlighter-rouge">MNothing[_]</code> and
<code class="highlighter-rouge">Just[_]</code>, which <code class="highlighter-rouge">T</code> is, not being known to be more refined than
<code class="highlighter-rouge">Any</code>.</p>

<p>The test works here, though!  What is ambiguous to scalac is a bright
line in our reasoning. We can’t define a matchless <code class="highlighter-rouge">fold</code> that can be
invoked on this <code class="highlighter-rouge">selector</code>, so we reach the correct conclusion, that
the match violates parametricity.</p>

<h2 id="the-rule-revisited">The rule revisited</h2>

<p>So we’ve carved out a clear “exception” to the “no type tests”
Scalazzi rule, and seen that it isn’t an exception at all.  There’s a
straightforward test you can apply to your pattern matches,</p>

<p><strong>If and only if I could, hypothetically, write a matchless fold, or
use an existing one, and rewrite this in its terms, this pattern
match is safe.</strong></p>

<p>but beware the subtle case where the match’s selector has a wider type
than you anticipated.</p>

<p>Finally, this is a rule specifically about expressions that don’t
violate our ability to reason about code.  This doesn’t hold for
arbitrary type-unsafe rewrites: that you could write a program safely
means you <em>should</em> write it safely.  Unlike arbitrary rewrites into
nonfunctional code, the pattern match uses no
non-referentially-transparent and no genuinely non-parametric
expressions.</p>

<p><em>This article was tested with Scala 2.11.4 and Scalaz 7.1.0.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Mon, 10 Nov 2014 00:00:00 +0100</pubDate>
        <link>https://typelevel.org/blog/2014/11/10/why_is_adt_pattern_matching_allowed.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2014/11/10/why_is_adt_pattern_matching_allowed.html</guid>
      </item>
    
      <item>
        <title>Higher Leibniz</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>We’ve previously seen
<a href="/blog/2014/07/02/type_equality_to_leibniz.html">the basic implementation and motivation for <code class="highlighter-rouge">scalaz.Leibniz</code></a>.
But there’s still quite a bit more to this traditionally esoteric
member of the Scalaz collection of well-typed stuff.</p>

<h2 id="strictly-necessarily-strict">Strictly necessarily strict</h2>

<p>The word “witness” implies that <code class="highlighter-rouge">Leibniz</code> is a passive bystander in
your function; sitting back and telling you that some type is equal to
another type, otherwise content to let the <em>real</em> code do the real
work.  The fact that <code class="highlighter-rouge">Leibniz</code> lifts into functions (which are a
member of the <em>everything</em> set, you’ll agree) might reinforce the
notion that <code class="highlighter-rouge">Leibniz</code> is spooky action at a distance.</p>

<p>But one of the nice things about <code class="highlighter-rouge">Leibniz</code> is that there’s really no
cheating: the value with its shiny new type is dependent on the
<code class="highlighter-rouge">Leibniz</code> actually existing, and its <code class="highlighter-rouge">subst</code>, however much a glorified
identity function it might be, completing successfully.</p>

<p>To see this in action, let’s check in with the bastion of not
evaluating stuff, Haskell.</p>

<h2 id="the-haskell-implementation">The Haskell implementation</h2>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">{-# LANGUAGE RankNTypes, PolyKinds #-}</span>
<span class="kr">module</span> <span class="nn">Leib</span>
  <span class="p">(</span> <span class="kt">Leib</span><span class="p">()</span>
  <span class="p">,</span> <span class="nf">subst</span>
  <span class="p">,</span> <span class="nf">lift</span>
  <span class="p">,</span> <span class="nf">symm</span>
  <span class="p">,</span> <span class="nf">compose</span>
  <span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Data.Functor</span>

<span class="kr">data</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">Leib</span> <span class="p">{</span>
  <span class="n">subst</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">f</span><span class="o">.</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="p">}</span>

<span class="n">refl</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="n">a</span>
<span class="n">refl</span> <span class="o">=</span> <span class="kt">Leib</span> <span class="n">id</span>

<span class="n">lift</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Leib</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="n">b</span><span class="p">)</span>
<span class="n">lift</span> <span class="n">ab</span> <span class="o">=</span> <span class="n">runOn</span> <span class="o">.</span> <span class="n">subst</span> <span class="n">ab</span> <span class="o">.</span> <span class="kt">On</span> <span class="o">$</span> <span class="n">refl</span>

<span class="kr">newtype</span> <span class="kt">On</span> <span class="n">c</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">On</span> <span class="p">{</span>
  <span class="n">runOn</span> <span class="o">::</span> <span class="n">c</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="n">b</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">symm</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Leib</span> <span class="n">b</span> <span class="n">a</span>
<span class="n">symm</span> <span class="n">ab</span> <span class="o">=</span> <span class="n">runDual</span> <span class="o">.</span> <span class="n">subst</span> <span class="n">ab</span> <span class="o">.</span> <span class="kt">Dual</span> <span class="o">$</span> <span class="n">refl</span>

<span class="kr">newtype</span> <span class="kt">Dual</span> <span class="n">c</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">Dual</span> <span class="p">{</span>
  <span class="n">runDual</span> <span class="o">::</span> <span class="n">c</span> <span class="n">b</span> <span class="n">a</span>
<span class="p">}</span>

<span class="n">compose</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="n">b</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="n">c</span>
<span class="n">compose</span> <span class="o">=</span> <span class="n">subst</span>
</code></pre></div></div>

<p>We use <a href="http://www.haskell.org/haskellwiki/Newtype">newtypes</a> in place
of type lambdas, and a value instead of a method, but the
implementation is otherwise identical.</p>

<h2 id="its-really-there">It’s really there</h2>

<p>OK.  Let’s try to make a fake <code class="highlighter-rouge">Leib</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">badForce</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="n">b</span>
<span class="n">badForce</span> <span class="o">=</span> <span class="kt">Leib</span> <span class="o">$</span> <span class="nf">\</span><span class="kr">_</span> <span class="o">-&gt;</span> <span class="ne">error</span> <span class="s">"sorry for fibbing"</span>
</code></pre></div></div>

<p>The following code will signal an error only if forcing the <em>head
cons</em> of the <code class="highlighter-rouge">subst</code>ed list signals such an error.  We never give
Haskell the chance to force anything else.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">λ</span><span class="o">&gt;</span> <span class="n">subst</span> <span class="p">(</span><span class="n">badForce</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">Int</span> <span class="kt">String</span><span class="p">)</span> <span class="p">[</span><span class="mi">42</span><span class="p">]</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="mi">33</span>
<span class="o">***</span> <span class="kt">Exception</span><span class="o">:</span> <span class="n">sorry</span> <span class="n">for</span> <span class="n">fibbing</span>
</code></pre></div></div>

<p>Oh well, let’s try to bury it behind combinators.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">λ</span><span class="o">&gt;</span> <span class="n">subst</span> <span class="p">(</span><span class="n">symm</span> <span class="o">.</span> <span class="n">symm</span> <span class="o">$</span> <span class="n">badForce</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">Int</span> <span class="kt">String</span><span class="p">)</span> <span class="p">[</span><span class="mi">42</span><span class="p">]</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="mi">33</span>
<span class="o">***</span> <span class="kt">Exception</span><span class="o">:</span> <span class="n">sorry</span> <span class="n">for</span> <span class="n">fibbing</span>
<span class="err">λ</span><span class="o">&gt;</span> <span class="n">subst</span> <span class="p">(</span><span class="n">compose</span> <span class="n">refl</span> <span class="o">$</span> <span class="n">badForce</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">Int</span> <span class="kt">String</span><span class="p">)</span> <span class="p">[</span><span class="mi">42</span><span class="p">]</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="mi">33</span>
<span class="o">***</span> <span class="kt">Exception</span><span class="o">:</span> <span class="n">sorry</span> <span class="n">for</span> <span class="n">fibbing</span>
</code></pre></div></div>

<p>Hmm.  We have two properties:</p>

<ol>
  <li>The <code class="highlighter-rouge">id</code> from <code class="highlighter-rouge">refl</code>?  The type-substituted data actually goes
through that function.  The same goes for the <code class="highlighter-rouge">subst</code> method in
Scala.</li>
  <li>When using <code class="highlighter-rouge">Leibniz</code> combinators, the strictness forms a chain to
all underlying <code class="highlighter-rouge">Leibniz</code> evidence.  If there are any missing
values, the transform will also fail.</li>
</ol>

<h2 id="higher-kinded-leibniz">Higher kinded <code class="highlighter-rouge">Leibniz</code></h2>

<p>Let’s try a variant on <code class="highlighter-rouge">Leib</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">LeibF</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">H</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">subst</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">H</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This reads “<code class="highlighter-rouge">LeibF[G, H]</code> can replace <code class="highlighter-rouge">G</code> with <code class="highlighter-rouge">H</code> in <strong>any</strong> type
function”.  But, whereas the
<a href="https://blogs.atlassian.com/2013/09/scala-types-of-a-higher-kind/">kind</a>
of the types that Leib discusses is <code class="highlighter-rouge">*</code>, for <code class="highlighter-rouge">LeibF</code> it’s <code class="highlighter-rouge">*-&gt;*</code>.  So,
<code class="highlighter-rouge">LeibF[List, List]</code> exhibits that the <em>type constructors</em> <code class="highlighter-rouge">List</code> and
<code class="highlighter-rouge">List</code> are equal.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">refl</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">G</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">LeibF</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">G</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">subst</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span> <span class="k">=</span> <span class="n">fa</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Interestingly, except for the kinds of type parameters, these
definitions are exactly the same as for <code class="highlighter-rouge">Leib</code>.  Does that hold for
lift?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">lift</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> , <span class="kt">B</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">F</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">ab</span><span class="o">.</span><span class="n">subst</span><span class="o">[</span><span class="kt">Lambda</span><span class="o">[</span><span class="kt">x</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">F</span><span class="o">[</span><span class="kt">x</span>, <span class="kt">?</span><span class="o">]]]](</span><span class="nc">LeibF</span><span class="o">.</span><span class="n">refl</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">?</span><span class="o">]])</span>
</code></pre></div></div>

<p>Despite that we are positively buried in type lambdas (yet moderated
by <a href="https://github.com/non/kind-projector">Kind Projector</a>) now,
absolutely!</p>

<p>As an exercise, adapt your <code class="highlighter-rouge">symm</code> and <code class="highlighter-rouge">compose</code> methods from the last
part for <code class="highlighter-rouge">LeibF</code>, by only changing type parameters and switching any
<code class="highlighter-rouge">refl</code> references.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">symm</span><span class="o">[</span><span class="kt">A</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">B</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">A</span><span class="o">]</span>
<span class="k">def</span> <span class="n">compose</span><span class="o">[</span><span class="kt">A</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">B</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">C</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">bc</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">C</span><span class="o">]</span>
</code></pre></div></div>

<p>You can write a <code class="highlighter-rouge">Leibniz</code> and associated combinators for types of
<em>any</em> kind; the principles and implementation techniques outlined
above for types of kind <code class="highlighter-rouge">*-&gt;*</code> apply to all kinds.</p>

<h2 id="whence-polykinds">Whence <code class="highlighter-rouge">PolyKinds</code>?</h2>

<p>You have to define a new <code class="highlighter-rouge">Leib</code> variant and set of combinators for
each kind you wish to support.  There is no need to do this in
Haskell, though.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">λ</span><span class="o">&gt;</span> <span class="o">:</span><span class="n">k</span> <span class="kt">Leib</span> <span class="kt">[]</span>
<span class="kt">Leib</span> <span class="kt">[]</span> <span class="o">::</span> <span class="p">(</span><span class="o">*</span> <span class="o">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">*</span>
<span class="err">λ</span><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">refl</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">[]</span> <span class="kt">[]</span>
<span class="n">refl</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">[]</span> <span class="kt">[]</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">[]</span> <span class="kt">[]</span>
<span class="err">λ</span><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">lift</span> <span class="p">(</span><span class="n">refl</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">[]</span> <span class="kt">[]</span><span class="p">)</span>
<span class="n">lift</span> <span class="p">(</span><span class="n">refl</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">[]</span> <span class="kt">[]</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="p">(</span><span class="n">f</span> <span class="kt">[]</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="kt">[]</span><span class="p">)</span>
<span class="err">λ</span><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">compose</span> <span class="p">(</span><span class="n">refl</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">[]</span> <span class="kt">[]</span><span class="p">)</span>
<span class="n">compose</span> <span class="p">(</span><span class="n">refl</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">[]</span> <span class="kt">[]</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="kt">[]</span> <span class="o">-&gt;</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="kt">[]</span>
</code></pre></div></div>

<p>In Haskell, we can take advantage of the fact that the actual
implementations are kind-agnostic, by having those definitions be
applicable to all kinds via
<a href="http://www.haskell.org/ghc/docs/7.8.3/html/users_guide/kind-polymorphism.html">the <code class="highlighter-rouge">PolyKinds</code> language extension</a>,
mentioned at the top of the Haskell code above.  No such luck in
Scala.</p>

<h2 id="better-gadts">Better GADTs</h2>

<p><a href="http://d.hatena.ne.jp/xuwei/20140706/1404612620">In a post from a couple months ago</a>,
Kenji Yoshida outlines an interesting way to simulate the missing
type-evidence features of Scala’s GADT support with <code class="highlighter-rouge">Leibniz</code>.  This
works in Haskell, too, in case you are comfortable with turning on
<a href="http://www.haskell.org/ghc/docs/7.8.3/html/users_guide/other-type-extensions.html#universal-quantification"><code class="highlighter-rouge">RankNTypes</code></a>
but not
<a href="http://www.haskell.org/ghc/docs/7.8.3/html/users_guide/data-type-extensions.html#gadt"><code class="highlighter-rouge">GADTs</code></a>
somehow.</p>

<p>Let’s examine Kenji’s GADT.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>
<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">X</span><span class="o">[</span><span class="kt">A</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">]</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Y</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>
</code></pre></div></div>

<p>For completeness, let’s also see the Haskell version, including the
function that demands so much hoop-jumping in Scala, but just works in
Haskell.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">{-# LANGUAGE GADTs #-}</span>
<span class="kr">module</span> <span class="nn">FooXY</span> <span class="kr">where</span>

<span class="kr">data</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="kt">X</span> <span class="o">::</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="n">a</span>
  <span class="kt">Y</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="n">b</span>

<span class="n">hoge</span> <span class="o">::</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="n">c</span>
<span class="n">hoge</span> <span class="kt">X</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">bar</span>
</code></pre></div></div>

<p>Note that the Haskell type system understands that when <code class="highlighter-rouge">hoge</code>’s first
argument’s data constructor is <code class="highlighter-rouge">X</code>, the type variables <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code>
must be the same type, and therefore by implication the argument of
type <code class="highlighter-rouge">f a c</code> must also be of type <code class="highlighter-rouge">f b c</code>.  This is what we’re trying
to get Scala to understand.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">hoge1</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">foo</span><span class="k">:</span> <span class="kt">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">bar</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">foo</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">X</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">bar</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>This transliteration of the above Haskell <code class="highlighter-rouge">hoge</code> function fails to
compile, as Kenji notes, with the following:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">…</span><span class="o">/</span><span class="nc">LeibnizArticle</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">39</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">bar.</span><span class="k">type</span> <span class="o">(</span><span class="kt">with</span> <span class="kt">underlying</span> <span class="k">type</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">C</span><span class="o">])</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span>,<span class="kt">C</span><span class="o">]</span>
      <span class="k">case</span> <span class="n">X</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">bar</span>
                  <span class="o">^</span>
</code></pre></div></div>

<h2 id="the-overridden-cata-method">The overridden <code class="highlighter-rouge">cata</code> method</h2>

<p>Kenji introduces a <code class="highlighter-rouge">cata</code> method on <code class="highlighter-rouge">Foo</code> to constrain use of the
<code class="highlighter-rouge">Leibniz.force</code> hack, while still providing external code with usable
<code class="highlighter-rouge">Leibniz</code> evidence that can be lifted to implement <code class="highlighter-rouge">hoge</code>.  However,
by implementing the method in a slightly different way, we can use
<code class="highlighter-rouge">refl</code> instead.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">cata</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">B</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span>
<span class="o">}</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">X</span><span class="o">[</span><span class="kt">A</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">cata</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">A</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">x</span><span class="o">(</span><span class="nc">Leib</span><span class="o">.</span><span class="n">refl</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Y</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">cata</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">B</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">y</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now we can replace the pattern match (and all other such pattern
matches) with an equivalent <code class="highlighter-rouge">cata</code> invocation.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">hoge2</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">foo</span><span class="k">:</span> <span class="kt">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">bar</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">foo</span><span class="o">.</span><span class="n">cata</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">subst</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">?</span>, <span class="kt">C</span><span class="o">]](</span><span class="n">bar</span><span class="o">),</span>
           <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">sys</span> <span class="n">error</span> <span class="s">"nonexhaustive"</span><span class="o">)</span>
</code></pre></div></div>

<p>So why can we get away with <code class="highlighter-rouge">Leib.refl</code>, whereas the function version
Kenji presents cannot?  Compare the <code class="highlighter-rouge">cata</code> signature in <code class="highlighter-rouge">Foo</code> versus
<code class="highlighter-rouge">X</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="n">cata</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">B</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span>
  <span class="k">def</span> <span class="n">cata</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">A</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span>
</code></pre></div></div>

<p>We supplied <code class="highlighter-rouge">A</code> for both the <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code> type parameters in our
<code class="highlighter-rouge">extends</code> clause, so that substitution also applies in all methods
from <code class="highlighter-rouge">Foo</code> that we’re implementing, including <code class="highlighter-rouge">cata</code>.  At that point
it’s obvious to the compiler that <code class="highlighter-rouge">refl</code> implements the requested
<code class="highlighter-rouge">Leib</code>.</p>

<p>Incidentally, a similar style of substitution underlies the definition
of <code class="highlighter-rouge">refl</code>.</p>

<h2 id="the-leib-member">The <code class="highlighter-rouge">Leib</code> member</h2>

<p>What if we don’t want to write or maintain an overriding-style <code class="highlighter-rouge">cata</code>?
After all, that’s an n² commitment.  Instead, we can incorporate a
<code class="highlighter-rouge">Leib</code> value in the GADT.  First, let’s see what the equivalent
Haskell is, without the <code class="highlighter-rouge">GADTs</code> extension:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">X</span> <span class="p">(</span><span class="kt">Leib</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="o">|</span> <span class="kt">Y</span> <span class="n">a</span> <span class="n">b</span>

<span class="n">hoge</span> <span class="o">::</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="n">c</span>
<span class="n">hoge</span> <span class="p">(</span><span class="kt">X</span> <span class="n">leib</span><span class="p">)</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">runDual</span> <span class="o">.</span> <span class="n">subst</span> <span class="n">leib</span> <span class="o">.</span> <span class="kt">Dual</span> <span class="o">$</span> <span class="n">bar</span>
</code></pre></div></div>

<p>We needed <code class="highlighter-rouge">RankNTypes</code> to implement <code class="highlighter-rouge">Leib</code>, of course, but perhaps
that’s acceptable.  It’s useful in
<a href="https://ermine-language.github.io/">Ermine</a>, which supports rank-N
types but not GADTs as of this writing.</p>

<p>The above is simple enough to port to Scala, though.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>
<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">X</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">leib</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Y</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>

<span class="k">def</span> <span class="n">hoge3</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">foo</span><span class="k">:</span> <span class="kt">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">bar</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">foo</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">X</span><span class="o">(</span><span class="n">leib</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">leib</span><span class="o">.</span><span class="n">subst</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">?</span>, <span class="kt">C</span><span class="o">]](</span><span class="n">bar</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>It feels a little weird that <code class="highlighter-rouge">X</code> now must retain <code class="highlighter-rouge">Foo</code>’s
type-system-level separation of the two type parameters.  But this
style may more naturally integrate in your ADTs, and it is much closer
to the original non-working <code class="highlighter-rouge">hoge1</code> implementation.</p>

<p>It also feels a little weird that you have to waste a slot carting
around this evidence of type equality.  As demonstrated in section
“It’s really there” above, though, <em>it matters that the instance
exists</em>.</p>

<p>You can play games with this definition to make it easier to supply
the wholly mechanical <code class="highlighter-rouge">leib</code> argument to <code class="highlighter-rouge">X</code>, e.g. adding it as an
<code class="highlighter-rouge">implicit val</code> in the second parameter list so it can be imported and
implicitly supplied on <code class="highlighter-rouge">X</code> construction.  The basic technique is
exactly the same as above, though.</p>

<h2 id="leibniz-mastery"><code class="highlighter-rouge">Leibniz</code> mastery</h2>

<p>This time we talked about</p>

<ul>
  <li>Why it matters that <code class="highlighter-rouge">subst</code> always executes to use a type equality,</li>
  <li>the Haskell implementation,</li>
  <li>higher-kinded type equalities and their <code class="highlighter-rouge">Leibniz</code>es,</li>
  <li>simulating GADTs with <code class="highlighter-rouge">Leibniz</code> members of data constructors.</li>
</ul>

<p><em>This article was tested with Scala 2.11.2,
<a href="https://github.com/non/kind-projector">Kind Projector</a> 0.5.2, and
<a href="http://www.haskell.org/platform/">GHC</a> 7.8.3.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sat, 20 Sep 2014 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2014/09/20/higher_leibniz.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2014/09/20/higher_leibniz.html</guid>
      </item>
    
      <item>
        <title>Typelevel Scala and the future of the Scala ecosystem</title>
        
          <dc:creator>milessabin</dc:creator>
                
        <description><![CDATA[<p><strong>tl;dr</strong> Typelevel is forking Scala; we call on all stakeholders in the Scala ecosystem to collaborate on the creation of an independent, non-profit, open source foundation to safeguard the interests of the entire Scala community.</p>

<p>Last week I tweeted the following question:</p>

<div>
  <blockquote><p>How much interest would there be in a community sponsored fork of the <a href="https://twitter.com/hashtag/Scala?src=hash">#Scala</a> toolchain? RTs and fav's please.</p>&mdash; Miles Sabin (@milessabin) <a href="https://twitter.com/milessabin/status/503929023635161088">August 25, 2014</a></blockquote>
</div>

<p>It generated a lively response, both on Twitter and privately. The responses were sometimes perplexed, but typically excited and invariably positive. What I want to do here is provide some background to the question and sketch out the directions that positive answers lead.</p>

<p>As the Scala community has matured, a number of different strands of development of the language have emerged,</p>

<ul>
  <li>The Typesafe Scala compiler is focused on stability and compatibility with Java.</li>
  <li>The LAMP/EPFL Dotty compiler is focused on providing a practical implementation of the DOT calculus.</li>
  <li>The Scala.js compiler is focused on targeting JavaScript as a backend platform.</li>
  <li>The Scala Virtualized compiler is focused on language virtualization and staging.</li>
  <li>The Scala.Meta system aims to provide portable metaprogramming facilities across a variety of Scala compilers.</li>
  <li>There are several research and private variants of the Scala compiler in development and use by a variety of academic and commercial organizations.</li>
  <li>The IDEs provide their own Scala variants which more or less accurately approximate Typesafe Scala.</li>
</ul>

<p>Of these, the only compiler targeting the JVM which is generally suitable for use by the Scala community at large in the near term is the Typesafe Scala compiler. The current roadmap for the 2.12 release of this compiler, due in early 2016, has very modest goals, consistent with Typesafe’s focus. Beyond that, the Next Steps roadmap mentions many things of interest, however it is clear that these are all a long way out – it will be 2017 at the earliest before any of this sees the light of day.</p>

<p>Typesafe’s motivation for focusing on stability and Java 8 compatibility is very easy to understand. Typesafe is a commercial entity with products to sell in the JVM-based enterprise middleware space. Its primary software offerings, Akka and Play, are probably the most Java-friendly Scala projects of any significance, and simple arithmetic should tell you that a very large proportion (probably a large majority) of the potential customers for these (and the associated consultancy, training and support) are mainly Java enterprises with wholly or largely Java codebases and development teams. In this context it should be easy to see that for them an emphasis on Scala as a complement to Java, rather as its successor, is paramount.</p>

<p>Whilst this is entirely reasonable, and meets the needs of many, there is nevertheless a significant constituency at the core of the Scala community whose needs are not being fully met. This constituency is the segment of the Scala community which puts greater emphasis on typeful functional programming styles and which has a strong interest in current developments in functional programming in the wider world beyond Scala. The projects gathered here under the Typelevel umbrella are prime examples of that constituency.</p>

<p>As the producers and consumers of these and other projects we continually find ourselves running up against limitations of current Scala. Sometimes these limitations are minor and amenable to simple workarounds, many of which have passed into Scala folklore. Other limitations are more serious and can only be worked around with cumbersome encodings or otherwise elaborate and confusing hacks. These have the unfortunate consequence that elegant solutions to important problems are obscured by layers of cruft which exist only to sidestep quirks of the current compiler.</p>

<p>What makes this all the more frustrating is that many of these limitations are comparatively easy to remove. Fixes for some of them are purely syntactic – for instance type constructor partial application, of huge importance to Scalaz and its users, has a clunky encoding (“type lambdas”) which could be given first class syntactic support without any impact on Scala’s semantics and in a completely binary compatible way. Similarly, syntactic support for singleton types for literal values (see SIP-23) would be of enormous value to shapeless and Spire and their users. And the addition of literals for Bytes and Shorts would be welcomed by Spire, Scodec and many others. Other fixes, whilst affecting semantics, would do so only in a conservative way – programs which are valid when compiled with the Typesafe Scala compiler would have the same meaning and binary representation when compiled with the fixes in place.</p>

<p>With this in mind, we intend to create a new Scala distribution, as a conservative fork of the Typesafe Scala compiler, with a focus on meeting the needs of the part of the Scala community which has coalesced around the Typelevel stack. As a conservative fork, our aim is to be merge compatible from the Typesafe Scala compiler, and a key objective is to feed pull requests (many of which will resolve long standing Scala bugs or feature requests) back to the Typesafe Scala compiler. Our goal is to have a language which continues to evolve at the pace we saw until a couple of years ago, but with the difference that this will now be an opt-in process and the priorities will be set by the community.</p>

<p>Of course the devil is in the details. Forking a compiler is only a small part of the story – in many ways more important is the surrounding ecosystem of libraries. As part of this initiative we intend to publish compatible builds of at least the Typelevel libraries – taking our lead from the Typesafe community build (which attempts to track ecosystem coherence over time by building a selection of community libraries against the development Scala compiler as it evolves) and Scala.js (which has ported a selection of important community libraries to its compiler).</p>

<p>We welcome the participation of all other parties, individuals or organizations, who share our general goals – both those who want to contribute to the development of the compiler and those who would like their libraries and frameworks to be part of a Typelevel community build. It’s early days, but we hope that with enough enthusiastic participation we will be able to produce useful binaries well before the end of the year.</p>

<p>We anticipate a number of objections to this initiative,</p>

<ul>
  <li>
    <p>That it will split the community and fragment the language.</p>

    <p>As I observed earlier, there are already several variants of the language in existence and it has been clear for a long time that different sections of the community have different interests. We shouldn’t be afraid of acknowledging this fact – attempting to ignore it will be (arguably is already) counterproductive. Instead we should embrace diversity as a sign of a healthy and vigorous platform and community.</p>
  </li>
  <li>
    <p>That we don’t have the resources or the expertise to pull this off.</p>

    <p>We disagree – the community around the Typelevel projects contains many of the most able Scala programmers on the planet. Between us we have a deep understanding of Scala’s type system and other semantics (both as specified and as implemented), of compiler construction in general and of Typesafe Scala compiler internals in particular. We are intimately familiar with the Scala toolchain, which many of us have been using at scale for years in our day jobs. We are also intimately familiar with the issues that we seek to address – they are ones we face daily.</p>

    <p>We also have the existence proof of the other Scala compiler variants. The number of full-time-equivalent people working on these projects is really very small – we believe that in practice this can be matched or exceeded by an open, inclusive and enthusiastic open source project.</p>
  </li>
  <li>
    <p>That we underestimate the difficulty of maintaining binary and/or merge compatibility.</p>

    <p>No, we really don’t. We fully expect this to be the most challenging part of the whole exercise. That said, we have the benefit of years of experience of Scala binary compatibility issues, and we know now that a combination of a community-build style model along with effective use of the Migration Manager (already a component of the Typelevel SBT plugin) is enormously helpful in keeping on top of the issue.</p>

    <p>There is a real risk here, and care will be needed. One thing is for sure though – if we don’t try, we’ll never know if it’s possible.</p>
  </li>
  <li>
    <p>That the fork is too conservative.</p>

    <p>It’s certainly true that restricting ourselves to only changes which are merge compatible with the Typesafe Scala compiler puts fairly strict limits on what we can do. Many highly desirable changes fall well beyond, and some people want to explore those possibilities.</p>

    <p>We think that this is completely reasonable, and we don’t think the two are mutually exclusive – a merge compatible Typelevel compiler meets many of our immediate needs, but we want to enable people to push further just as is being done by Scala.Meta, Scala Virtualized and Dotty.</p>

    <p>We believe that the same infrastructure (community builds, MiMa) that will help the merge-compatible Typelevel compiler stay close to the Typesafe compiler will also be of great assistance to people who want to experiment with more radical changes. At a minimum, community build infrastructure will enable people to work with not just a bare compiler with but a core set of compatible libraries as well. We believe that such infrastructure would also benefit Scala Virtualized, Scala.Meta and Dotty.</p>
  </li>
</ul>

<p>This brings me to the final part of this message. It has become clear to us that there are many distinct stakeholders in the Scala ecosystem with a mixture of shared and divergent interests. This is a good thing and is something we should jointly strive to support. To that end, we believe that it is time for the formation of an independent, non-profit, open source foundation to safeguard the interests of the entire Scala community – we call on all organizations and individuals who want to see a flourishing Scala ecosystem to join with us in that project.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Tue, 02 Sep 2014 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2014/09/02/typelevel-scala.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2014/09/02/typelevel-scala.html</guid>
      </item>
    
      <item>
        <title>The singleton instance trick is unsafe</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p><em>Also, the “fake covariance” trick.</em></p>

<p>Sometimes, Scala programmers notice a nice optimization they can use
in the case of a class that has an invariant type parameter, but in
which that type parameter
<a href="/blog/2014/03/09/liskov_lifting.html">appears in variant or phantom position in the actual data involved</a>.
<a href="http://www.scala-lang.org/api/2.11.1/scala/Predef$$$eq$colon$eq.html"><code class="highlighter-rouge">=:=</code></a>
is an
<a href="https://github.com/scala/scala/blob/v2.11.1/src/library/scala/Predef.scala#L398">example of the phantom case</a>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">=:=</span><span class="o">[</span><span class="kt">From</span>, <span class="kt">To</span><span class="o">]</span> <span class="nc">extends</span> <span class="o">(</span><span class="nc">From</span> <span class="k">=&gt;</span> <span class="nc">To</span><span class="o">)</span> <span class="k">with</span> <span class="nc">Serializable</span>
</code></pre></div></div>

<p><a href="http://www.scala-lang.org/api/2.11.1/scala/collection/immutable/Set.html"><code class="highlighter-rouge">scala.collection.immutable.Set</code></a>
is an example of the covariant case.</p>

<p>Here is the optimization, which is very similar to
<a href="/blog/2014/03/09/liskov_lifting.html">the <code class="highlighter-rouge">Liskov</code>-lifting previously discussed</a>:
a “safe” cast of the invariant type
parameter can be made, because all operations on the casted result
remain sound.
<a href="https://github.com/scala/scala/blob/9fc098dd0dcf1825ec55501716b4f2a0a6d197ae/src/library/scala/collection/immutable/HashSet.scala#L170">Here it is for Set</a>,
an example of the “fake covariance” trick:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">override</span> <span class="k">def</span> <span class="n">toSet</span><span class="o">[</span><span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span>
</code></pre></div></div>

<p>And
<a href="https://github.com/scala/scala/blob/v2.11.1/src/library/scala/Predef.scala#L399-L402">here it is for <code class="highlighter-rouge">=:=</code></a>,
an example of the “singleton instance” trick.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">final</span> <span class="k">val</span> <span class="n">singleton_=:=</span> <span class="k">=</span> <span class="k">new</span> <span class="o">=:=[</span><span class="kt">Any</span>,<span class="kt">Any</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="n">x</span>
<span class="o">}</span>
<span class="k">object</span> <span class="nc">=:=</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">tpEquals</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=:=</span> <span class="n">A</span> <span class="k">=</span> <span class="n">singleton_=:=</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">A</span> <span class="kt">=:=</span> <span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Unless you are using
<a href="https://dl.dropboxusercontent.com/u/7810909/talks/parametricity/4985cb8e6d8d9a24e32d98204526c8e3b9319e33/parametricity.pdf">the Scalazzi safe Scala subset</a>,
which forbids referentially nontransparent and nonparametric
operations, <em>these tricks are unsafe</em>.</p>

<h2 id="types-are-erased">Types are erased</h2>

<p>Many people are confused that they cannot write functions like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">addone</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"one"</span>
  <span class="k">case</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Being given an error as follows.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">8</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">String</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">A</span>
         <span class="k">case</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"one"</span>
                             <span class="o">^</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">9</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">Int</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">A</span>
         <span class="k">case</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                          <span class="o">^</span>
</code></pre></div></div>

<p>Let’s consider only one case, the first. In the right-hand side (RHS)
of this case, you have not proved that <code class="highlighter-rouge">A</code> is <code class="highlighter-rouge">String</code> at all! You
have only proved that, in addition to definitely having type <code class="highlighter-rouge">A</code>, <code class="highlighter-rouge">x</code>
also definitely has type <code class="highlighter-rouge">String</code>. In type relationship language,</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span><span class="o">.</span><span class="k">type</span> <span class="k">&lt;:</span> <span class="kt">A</span>
<span class="n">x</span><span class="o">.</span><span class="k">type</span> <span class="k">&lt;:</span> <span class="kt">String</span>
</code></pre></div></div>

<p>All elephants are grey and are also animals, but it does not follow
that all grey things are animals or vice versa. If you use a cast to
“fix” this, you have produced type-incorrect code, period.</p>

<h2 id="type-recovery">Type recovery</h2>

<p>Under special circumstances, however, information about a type
parameter can be recovered, safe and sound. Take this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Box</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">SBox</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Box</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">IBox</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Box</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

<span class="k">def</span> <span class="n">addone2</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">b</span><span class="k">:</span> <span class="kt">Box</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">b</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">SBox</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"one"</span>
  <span class="k">case</span> <span class="nc">IBox</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This compiles, and I don’t even have to have data in the box to get at
the type information that <code class="highlighter-rouge">A ~ String</code> or <code class="highlighter-rouge">A ~ Int</code>.  Consider the
first case.  On the RHS, I have</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span><span class="o">.</span><span class="k">type</span> <span class="k">&lt;:</span> <span class="kt">SBox</span> <span class="k">&lt;:</span> <span class="kt">Box</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="n">b</span><span class="o">.</span><span class="k">type</span> <span class="k">&lt;:</span> <span class="kt">Box</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>In addition, <strong><code>A</code> is invariant</strong>, so after going up to
<code class="highlighter-rouge">Box[String]</code>, <code class="highlighter-rouge">b</code> couldn’t have widened that type parameter, or
changed it in any way, without an unsafe cast.  Additionally, our
supertype tree cannot contain <code class="highlighter-rouge">Box</code> twice with different parameters.
So we have proved that <code class="highlighter-rouge">A</code> is <code class="highlighter-rouge">String</code>, because we proved that
<code class="highlighter-rouge">Box[A]</code> is <code class="highlighter-rouge">Box[String]</code>.</p>

<p>This is very useful when defining
<a href="http://www.haskell.org/haskellwiki/GADTs_for_dummies">GADTs</a>.</p>

<h2 id="partial-type-recovery">Partial type recovery</h2>

<p>Let’s consider a similar ADT with the type parameter marked variant.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">abstract</span> <span class="k">class</span> <span class="nc">CovBox</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">CovSBox</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">CovBox</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>

<span class="k">def</span> <span class="n">addone3</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">b</span><span class="k">:</span> <span class="kt">CovBox</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">b</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">CovSBox</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"one"</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This works too, because in the RHS of the case, we proved that:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span><span class="o">.</span><span class="k">type</span> <span class="k">&lt;:</span> <span class="kt">CovSBox</span> <span class="k">&lt;:</span> <span class="kt">CovBox</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">&lt;:</span> <span class="nc">CovBox</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">String</span> <span class="k">&lt;:</span> <span class="n">A</span>
</code></pre></div></div>

<p>The only transform in type <code class="highlighter-rouge">A</code> could have possibly undergone is a
widening, which <em>must</em> have begun at <code class="highlighter-rouge">String</code>. A similar example can
be derived for contravariance.</p>

<h2 id="singleton-surety">Singleton surety</h2>

<p>In our first example, there is one type that we know must be a subtype
of <code class="highlighter-rouge">A</code>, no matter what!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">addone</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">AnyRef</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span><span class="k">:</span> <span class="kt">x.type</span>
</code></pre></div></div>

<p>(Scala doesn’t like it when we talk about singleton types without an
<code class="highlighter-rouge">AnyRef</code> upper bound at least.  But the underlying principle holds for
all value types.)</p>

<p>Where <code class="highlighter-rouge">x</code> is an <code class="highlighter-rouge">A</code> of stable type, <code class="highlighter-rouge">x.type &lt;: A</code> for all possible <code class="highlighter-rouge">A</code>
types.  You might say, “that’s uninteresting; obviously <code class="highlighter-rouge">x</code> is an <code class="highlighter-rouge">A</code>
in this code.”  But that isn’t what we’re talking about; our premise
is that <strong>any</strong> value of type <code class="highlighter-rouge">x.type</code> is also an <code class="highlighter-rouge">A</code>!</p>

<p>So if we could prove that something else had the singleton type
<code class="highlighter-rouge">x.type</code>, we would also prove that it shared all of <code class="highlighter-rouge">x</code>’s types!  We
can do that with a singleton type pattern, which is implemented
(soundly in 2.11) with a reference comparison.  Scala lets us use
<em>some</em> of the resulting implications.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">InvBox</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">b</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span>
<span class="k">def</span> <span class="n">maybeeq</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">InvBox</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">y</span><span class="k">:</span> <span class="kt">InvBox</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">y</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">x.</span><span class="k">type</span> <span class="o">=&gt;</span> <span class="n">y</span><span class="o">.</span><span class="n">b</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="unsafety">Unsafety</h2>

<p>To which you might protest, “there’s only one value of any singleton
type!”  Well, yes.  And here’s where our seemingly innocent
optimization turns nasty.  If you’ll recall, it depends upon treating
a value with multiple types via an unsafe cast.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">unsafeCoerce</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">A</span> <span class="kt">=:=</span> <span class="kt">A</span><span class="o">]</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">B</span> <span class="kt">=:=</span> <span class="kt">B</span><span class="o">]</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">_:</span> <span class="kt">a.</span><span class="k">type</span> <span class="o">=&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">A</span> <span class="kt">=:=</span> <span class="kt">B</span><span class="o">]</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">unsafeCoerce2</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">n</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]()</span>
  <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="n">n</span><span class="o">.</span><span class="n">toSet</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="n">n</span><span class="o">.</span><span class="n">toSet</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">_:</span> <span class="kt">b.</span><span class="k">type</span> <span class="o">=&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">A</span> <span class="kt">=:=</span> <span class="kt">B</span><span class="o">]</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Both of these compile to what is in essence an identity function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">unsafeCoerce</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">](</span><span class="s">"hi"</span><span class="o">))</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Some</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">hi</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">unsafeCoerce2</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">](</span><span class="s">"hi"</span><span class="o">))</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Some</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">hi</span><span class="o">)</span>
</code></pre></div></div>

<p>In our invariant <code class="highlighter-rouge">Box</code> example we decided that, as it was impossible
to change the type parameter without an unsafe cast, we could use that
knowledge in the consequent types. In <code class="highlighter-rouge">unsafeCoerce</code>, where <code class="highlighter-rouge">?</code>
represents the value before the match keyword:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?.</span><span class="k">type</span> <span class="k">&lt;:</span> <span class="kt">a.</span><span class="k">type</span> <span class="k">&lt;:</span> <span class="o">(</span><span class="kt">A</span> <span class="o">=</span><span class="kt">:=</span> <span class="kt">A</span><span class="o">)</span>
<span class="o">?.</span><span class="k">type</span> <span class="k">&lt;:</span> <span class="o">(</span><span class="kt">B</span> <span class="o">=</span><span class="kt">:=</span> <span class="kt">B</span><span class="o">)</span>
<span class="n">A</span> <span class="o">~</span> <span class="n">B</span>
</code></pre></div></div>

<p>In <code class="highlighter-rouge">unsafeCoerce2</code>,</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?.</span><span class="k">type</span> <span class="k">&lt;:</span> <span class="kt">b.</span><span class="k">type</span> <span class="k">&lt;:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">?.</span><span class="k">type</span> <span class="k">&lt;:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="n">A</span> <span class="o">~</span> <span class="n">B</span>
</code></pre></div></div>

<p><strong>There is nothing wrong with Scala making this logical inference. The
“optimization” of that cast is not safe.</strong></p>

<p>Let me reiterate: <strong>Scala’s type inference surrounding pattern
matching should not be “fixed” to make unsafe casts “safer” and steal
our GADTs. Unsafe code is unsafe.</strong></p>

<h2 id="scalazzi-safe-scala-subset-saves-us">Scalazzi safe Scala subset saves us</h2>

<p>For types like these, it is not possible to exploit this unsafety
without a reference check, which is what a singleton type pattern
compiles to.  As the Scalazzi safe subset forbids referentially
nontransparent operations, if you follow its rules, these
optimizations become safe again.</p>

<p>This is just yet another of countless ways in which following the
Scalazzi rules makes your code safer and easier to reason about.</p>

<p>That isn’t to say it’s impossible to derive a situation where the
optimization exposes an <code class="highlighter-rouge">unsafeCoerce</code> in Scalazzi code.  However, you
must specially craft a type in order to do so.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Oops</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">widen</span><span class="o">[</span><span class="kt">B</span><span class="k">&gt;:</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">Oops</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Oops</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span>
<span class="o">}</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Bot</span><span class="o">()</span> <span class="k">extends</span> <span class="nc">Oops</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>

<span class="k">def</span> <span class="n">unsafeCoerce3</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">Bot</span><span class="o">()</span>
  <span class="n">x</span><span class="o">.</span><span class="n">widen</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Bot</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">B</span><span class="o">]</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The implication being</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?.</span><span class="k">type</span> <span class="k">&lt;:</span> <span class="kt">Bot</span> <span class="k">&lt;:</span> <span class="kt">Oops</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
<span class="o">?.</span><span class="k">type</span> <span class="k">&lt;:</span> <span class="kt">Oops</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">Nothing</span> <span class="o">~</span> <span class="n">A</span>
</code></pre></div></div>

<p>Scalaz
<a href="https://github.com/scalaz/scalaz/blob/v7.0.6/core/src/main/scala/scalaz/IList.scala#L436-L437">uses the optimization under consideration in <code class="highlighter-rouge">scalaz.IList</code></a>.
So would generalized <code class="highlighter-rouge">Functor</code>-based <code class="highlighter-rouge">Liskov</code>-lifting, as discussed at
the end of <a href="/blog/2014/03/09/liskov_lifting.html">“When can Liskov be lifted?”</a>,
were it to be implemented.  However, these cases do not fit the bill
for exploitation from Scalazzi-safe code.</p>

<p>On the other hand, the singleton type pattern approach may be used in
<em>all</em> cases where the optimization may be invoked by a caller,
including standard library code where some well-meaning contributor
might add such a harmless-seeming avoidance of memory allocation
without your knowledge.  Purity pays, and often in very nonobvious
ways.</p>

<p><em>This article was tested with Scala 2.11.1.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 06 Jul 2014 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2014/07/06/singleton_instance_trick_unsafe.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2014/07/06/singleton_instance_trick_unsafe.html</guid>
      </item>
    
      <item>
        <title>A function from type equality to Leibniz</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>The Scala standard library provides evidence of two types being equal
at the data level: a value of type
<a href="http://www.scala-lang.org/api/2.11.1/scala/Predef$$$eq$colon$eq.html"><code class="highlighter-rouge">(A =:= B)</code></a>
witnesses that <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code> are the same type. Accordingly, it provides
an implicit conversion from <code class="highlighter-rouge">A</code> to <code class="highlighter-rouge">B</code>. So you can write <code class="highlighter-rouge">Int</code>-summing
functions on your generic foldable types.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">sum</span><span class="o">(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=:=</span> <span class="nc">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="n">xs</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>That works because <code class="highlighter-rouge">ev</code> is inserted as an implicit conversion over
that lambda’s second parameter.</p>

<h2 id="fragility">Fragility</h2>

<p>That’s not really what we want, though. In particular, flipping <code class="highlighter-rouge">A</code>
and <code class="highlighter-rouge">Int</code> in the <code class="highlighter-rouge">ev</code> type declaration will break it:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>….scala:5: overloaded method value + with alternatives:
  (x: Int)Int &lt;and&gt;
  (x: Char)Int &lt;and&gt;
  (x: Short)Int &lt;and&gt;
  (x: Byte)Int
 cannot be applied to (A)
    xs.foldLeft(0)(_ + _)
                     ^
</code></pre></div></div>

<p>That doesn’t make sense, though. Type equality is symmetric: Scala
knows it goes both ways, so why is this finicky?</p>

<p>Additionally, we apply the conversion for each <code class="highlighter-rouge">Int</code>. It is a logical
implication that, if <code class="highlighter-rouge">A</code> is <code class="highlighter-rouge">B</code>, then <code class="highlighter-rouge">List[A]</code> must be <code class="highlighter-rouge">List[B]</code> as
well. But we can’t get that cheap, single conversion without a cast.</p>

<h2 id="substitution">Substitution</h2>

<p>Scalaz instead provides
<a href="http://docs.typelevel.org/api/scalaz/stable/7.0.4/doc/scalaz/Leibniz.html"><code class="highlighter-rouge">Leibniz</code></a>,
a more perfect type equality. A simplified version follows, which we
will use for the remainder.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">subst</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This reads “<code class="highlighter-rouge">Leib[A, B]</code> can replace <code class="highlighter-rouge">A</code> with <code class="highlighter-rouge">B</code> in <strong>any</strong> type
function”. That “any” is pretty important: it gives us both the
theorem that we want, and a tremendous consequent power that gives us
most of what we can get in Scala from value-level type equality, by
choosing the right <code class="highlighter-rouge">F</code> type parameter to <code class="highlighter-rouge">subst</code>.</p>

<h2 id="what-could-it-be">What could it be?</h2>

<p>Following the Scalazzi rules, where no <code class="highlighter-rouge">null</code>, type testing or
casting, or <code class="highlighter-rouge">AnyRef</code>-defined functions are permitted, what might go in
the body of that function? Even if you know what <code class="highlighter-rouge">A</code> is, as a <code class="highlighter-rouge">Leib</code>
implementer, it’s hidden behind the unknown <code class="highlighter-rouge">F</code>. Even if you know that
<code class="highlighter-rouge">B</code> is a supertype of <code class="highlighter-rouge">A</code>, you don’t know that <code class="highlighter-rouge">F</code> is covariant,
<a href="/blog/2014/03/09/liskov_lifting.html">by scalac or otherwise</a>.
Even if you know that <code class="highlighter-rouge">A</code> is <code class="highlighter-rouge">Int</code> and <code class="highlighter-rouge">B</code> is <code class="highlighter-rouge">Double</code>, what are you
going to do with that information?</p>

<p>So there’s only one thing this <code class="highlighter-rouge">Leib</code> could be, because you <strong>do</strong>
have an <code class="highlighter-rouge">F</code> of <em>something</em>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">refl</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">subst</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">fa</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Every type is equal to itself. Every well-formed <code class="highlighter-rouge">Leib</code> instance
starts out this way, in this function.</p>

<h2 id="recovery">Recovery</h2>

<p>So, it’s great that <em>we</em> know the implication of the <code class="highlighter-rouge">subst</code> method’s
generality. But that’s not good enough; we had that with <code class="highlighter-rouge">=:=</code>
already. We want to write well-typed operations that represent all the
implications of the <code class="highlighter-rouge">Leib</code> type equality as <em>new</em> <code class="highlighter-rouge">Leib</code>s representing
<em>those</em> type equalities.</p>

<p>First, let’s solve the original problem, using infix type application
to show the similarity to <code class="highlighter-rouge">=:=</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">sum2</span><span class="o">(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="n">ev</span><span class="o">.</span><span class="n">subst</span><span class="o">[</span><span class="kt">List</span><span class="o">](</span><span class="n">xs</span><span class="o">).</span><span class="n">foldLeft</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
</code></pre></div></div>

<p>There is no more implicit conversion, the result of <code class="highlighter-rouge">subst</code> is the same
object as the argument, and <code class="highlighter-rouge">[List]</code> would be inferred, but I have
merely specified it for clarity in this example.</p>

<p>This doesn’t compose, though. What if, having <code class="highlighter-rouge">subst</code>ed <code class="highlighter-rouge">Int</code> into
that <code class="highlighter-rouge">List</code> type, I now want to <code class="highlighter-rouge">subst</code> <code class="highlighter-rouge">List[A]</code> for <code class="highlighter-rouge">List[Int]</code> in
some type function? Specifically, what about a <code class="highlighter-rouge">Leib</code> that represents
that type equality? To handle that, we can <code class="highlighter-rouge">subst</code> into <code class="highlighter-rouge">Leib</code> itself!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">lift</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">ab</span><span class="o">.</span><span class="n">subst</span><span class="o">[</span><span class="kt">Lambda</span><span class="o">[</span><span class="kt">X</span> <span class="k">=&gt;</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">F</span><span class="o">[</span><span class="kt">X</span><span class="o">]]]](</span><span class="nc">Leib</span><span class="o">.</span><span class="n">refl</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span>
</code></pre></div></div>

<p>Again, the final <code class="highlighter-rouge">[F[A]]</code> could be inferred.</p>

<p>As an exercise, define the <code class="highlighter-rouge">symm</code> and <code class="highlighter-rouge">compose</code> operations, which
represent that <code class="highlighter-rouge">Leib</code> is symmetric and transitive as well. Hints: the
<code class="highlighter-rouge">symm</code> body is the same except for the type parameters given, and
<code class="highlighter-rouge">compose</code> doesn’t use <code class="highlighter-rouge">refl</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">symm</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">A</span><span class="o">]</span>
<span class="k">def</span> <span class="n">compose</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">bc</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">C</span><span class="o">]</span>
</code></pre></div></div>

<h2 id="leib-power">Leib power</h2>

<p>In Scalaz, <code class="highlighter-rouge">Leibniz</code> is already defined, and
<a href="https://github.com/scalaz/scalaz/blob/v7.0.6/core/src/main/scala/scalaz/syntax/TraverseSyntax.scala#L22-L26">used in a few places</a>.
Though their <code class="highlighter-rouge">subst</code> definitions are completely incompatible at the
scalac level, they have a weird equivalence due to the awesome power
of <code class="highlighter-rouge">subst</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz.Leibniz</span><span class="o">,</span> <span class="nc">Leibniz</span><span class="o">.===</span>

<span class="k">def</span> <span class="n">toScalaz</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">===</span> <span class="n">B</span> <span class="k">=</span>
  <span class="n">ab</span><span class="o">.</span><span class="n">subst</span><span class="o">[</span><span class="kt">A</span> <span class="kt">===</span> <span class="kt">?</span><span class="o">](</span><span class="nc">Leibniz</span><span class="o">.</span><span class="n">refl</span><span class="o">)</span>

<span class="k">def</span> <span class="n">toLeib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">A</span> <span class="o">===</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">B</span> <span class="o">=</span>
  <span class="n">ab</span><span class="o">.</span><span class="n">subst</span><span class="o">[</span><span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">?</span><span class="o">](</span><span class="nc">Leib</span><span class="o">.</span><span class="n">refl</span><span class="o">)</span>
</code></pre></div></div>

<p>…where <code class="highlighter-rouge">?</code> is to type-lambdas as <code class="highlighter-rouge">_</code> is to Scala lambdas, thanks to
<a href="https://github.com/non/kind-projector#kind-projector">the Kind Projector plugin</a>.</p>

<p>And so it would be with any pair of <code class="highlighter-rouge">Leibniz</code> representations with such
<code class="highlighter-rouge">subst</code> methods that you might define. Unfortunately, <code class="highlighter-rouge">=:=</code> cannot
participate in this universe of isomorphisms; it lacks the <code class="highlighter-rouge">subst</code>
method that serves as the <code class="highlighter-rouge">Leibniz</code> certificate of authenticity. You can
get a <code class="highlighter-rouge">=:=</code> from a <code class="highlighter-rouge">Leibniz</code>, but not vice versa.</p>

<p>Why would you want that weak sauce anyway?</p>

<h2 id="looking-up">Looking up</h2>

<p>These are just the basics.  Above:</p>

<ul>
  <li>The weakness of Scala’s own <code class="highlighter-rouge">=:=</code>,</li>
  <li>the sole primitive <code class="highlighter-rouge">Leibniz</code> operator <code class="highlighter-rouge">subst</code>,</li>
  <li>how to logically derive other type equalities,</li>
  <li>the isomorphism between each <code class="highlighter-rouge">Leibniz</code> representation and all
others.</li>
</ul>

<p><a href="/blog/2014/09/20/higher_leibniz.html">In the next part</a>, we’ll
look at:</p>

<ul>
  <li>Why it matters that <code class="highlighter-rouge">subst</code> always executes to use a type equality,</li>
  <li>the Haskell implementation,</li>
  <li>higher-kinded type equalities and their <code class="highlighter-rouge">Leibniz</code>es,</li>
  <li>why
<a href="https://github.com/scala/scala/blob/v2.11.1/src/library/scala/Predef.scala#L399-L402">the <code class="highlighter-rouge">=:=</code> singleton trick</a>
is unsafe,</li>
  <li>simulating GADTs with <code class="highlighter-rouge">Leibniz</code> members of data constructors.</li>
</ul>

<p><em>This article was tested with Scala 2.11.1, Scalaz 7.0.6, and Kind
Projector 0.5.2.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 02 Jul 2014 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2014/07/02/type_equality_to_leibniz.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2014/07/02/type_equality_to_leibniz.html</guid>
      </item>
    
      <item>
        <title>How can we map a Set?</title>
        
          <dc:creator>puffnfresh</dc:creator>
                
        <description><![CDATA[<p>Scalaz used to have a <code class="highlighter-rouge">scalaz.Functor</code> for <code class="highlighter-rouge">scala.collection.Set</code> but
it was <a href="https://github.com/scalaz/scalaz/pull/276">eventually removed</a>
because it relied on
<a href="http://www.scala-lang.org/api/2.10.3/index.html#scala.Any">Any’s == method</a>. You
can read more about why <code class="highlighter-rouge">Functor[Set]</code> is a bad idea at
<a href="http://failex.blogspot.jp/2013/06/fake-theorems-for-free.html">Fake Theorems for Free</a>.</p>

<p>If <code class="highlighter-rouge">Set</code> had been truly parametric, we wouldn’t have been able to
define a <code class="highlighter-rouge">Functor</code> in the first place. Luckily, a truly parametric Set
has recently been added to Scalaz as <code class="highlighter-rouge">scalaz.ISet</code>, with preliminary
benchmarks also showing some nice performance improvements. I highly
recommend using <code class="highlighter-rouge">ISet</code> whenever you can!</p>

<p>Now we can see the problem more clearly; the type of <code class="highlighter-rouge">map</code> on <code class="highlighter-rouge">ISet</code>
is too restrictive to be used inside of a <code class="highlighter-rouge">Functor</code> because of the
<code class="highlighter-rouge">scalaz.Order</code> constraint:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B:</span> <span class="kt">Order</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">ISet</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</code></pre></div></div>

<p>And it might seem like we’ve lost something useful by not having a
<code class="highlighter-rouge">Functor</code> available. For example, we can’t write the following:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">nes</span> <span class="k">=</span> <span class="nc">OneAnd</span><span class="o">(</span><span class="s">"2014-05-01"</span><span class="o">,</span> <span class="nc">ISet</span><span class="o">.</span><span class="n">fromList</span><span class="o">(</span><span class="s">"2014-06-01"</span> <span class="o">::</span> <span class="s">"2014-06-22"</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">))</span> <span class="c1">// a non-empty Set
</span><span class="k">val</span> <span class="nc">OneAnd</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=</span> <span class="n">nes</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">parseDate</span><span class="o">)</span>
</code></pre></div></div>

<p>Which is because the <code class="highlighter-rouge">map</code> function on <code class="highlighter-rouge">scalaz.OneAnd</code> requires a
<code class="highlighter-rouge">scalaz.Functor</code> for the <code class="highlighter-rouge">F[_]</code> type parameter, which is <code class="highlighter-rouge">ISet</code> in the
above example.</p>

<p>But we have a solution! It’s called
<a href="http://docs.typelevel.org/api/scalaz/nightly/#scalaz.Coyoneda">Coyoneda</a>
(also known as the Free Functor) and it’ll hopefully be able to
demonstrate why not having <code class="highlighter-rouge">Functor[ISet]</code> available has no
fundamental, practical consequences.</p>

<p>Coyoneda
<a href="http://blog.higher-order.com/blog/2013/11/01/free-and-yoneda/">can be defined in Scala</a>
like so:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Coyoneda</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">I</span>
  <span class="k">def</span> <span class="n">k</span><span class="k">:</span> <span class="kt">I</span> <span class="o">=&gt;</span> <span class="n">A</span>
  <span class="k">def</span> <span class="n">fi</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">I</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>There are just three parts to it:</p>

<ol>
  <li><code class="highlighter-rouge">I</code> - an existential type</li>
  <li><code class="highlighter-rouge">k</code> - a mapping from <code class="highlighter-rouge">I</code> to <code class="highlighter-rouge">A</code></li>
  <li><code class="highlighter-rouge">fi</code> - a value of <code class="highlighter-rouge">F[I]</code></li>
</ol>

<p>We can create a couple of functions to help with constructing a
Coyoneda value:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="nc">_k</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Coyoneda</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">I</span> <span class="o">=</span> <span class="n">A</span> <span class="o">}</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Coyoneda</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">I</span> <span class="o">=</span> <span class="n">A</span>
    <span class="k">val</span> <span class="n">k</span> <span class="k">=</span> <span class="nc">_k</span>
    <span class="k">val</span> <span class="n">fi</span> <span class="k">=</span> <span class="n">fa</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="n">lift</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Coyoneda</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Coyoneda</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">identity</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
</code></pre></div></div>

<p>The constructors allow any type constructor to become a Coyoneda value:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">s</span><span class="k">:</span> <span class="kt">Coyoneda</span><span class="o">[</span><span class="kt">ISet</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Coyoneda</span><span class="o">.</span><span class="n">lift</span><span class="o">(</span><span class="nc">ISet</span><span class="o">.</span><span class="n">fromList</span><span class="o">(</span><span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">))</span>
</code></pre></div></div>

<p>Now here’s the special part; we can define a <code class="highlighter-rouge">Functor</code> for all
Coyoneda values:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">coyonedaFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[({</span><span class="k">type</span> <span class="kt">λ</span><span class="o">[</span><span class="kt">α</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">Coyoneda</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">α</span><span class="o">]})</span><span class="k">#</span><span class="kt">λ</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Functor</span><span class="o">[({</span><span class="k">type</span> <span class="kt">λ</span><span class="o">[</span><span class="kt">α</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">Coyoneda</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">α</span><span class="o">]})</span><span class="k">#</span><span class="kt">λ</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">ya</span><span class="k">:</span> <span class="kt">Coyoneda</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Coyoneda</span><span class="o">(</span><span class="n">ya</span><span class="o">.</span><span class="n">fi</span><span class="o">)(</span><span class="n">f</span> <span class="n">compose</span> <span class="n">ya</span><span class="o">.</span><span class="n">k</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>What’s interesting is that the <code class="highlighter-rouge">F[_]</code> type does <em>not</em> have to have a
<code class="highlighter-rouge">Functor</code> defined for the Coyoneda to be mapped!</p>

<p>Let’s use this to try out our original example. We’ll define a type
alias to make things a bit cleaner:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">ISetF</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Coyoneda</span><span class="o">[</span><span class="kt">ISet</span>, <span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>And we can use this new type instead of a plain <code class="highlighter-rouge">ISet</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Scala has a really hard time with inference here, so we have to help it out.
</span><span class="k">val</span> <span class="n">functor</span> <span class="k">=</span> <span class="nc">OneAnd</span><span class="o">.</span><span class="n">oneAndFunctor</span><span class="o">[</span><span class="kt">ISetF</span><span class="o">](</span><span class="nc">Coyoneda</span><span class="o">.</span><span class="n">coyonedaFunctor</span><span class="o">[</span><span class="kt">ISet</span><span class="o">])</span>
<span class="k">import</span> <span class="nn">functor.functorSyntax._</span>

<span class="k">val</span> <span class="n">nes</span> <span class="k">=</span> <span class="nc">OneAnd</span><span class="o">[</span><span class="kt">ISetF</span>, <span class="kt">String</span><span class="o">](</span><span class="s">"2014-05-01"</span><span class="o">,</span> <span class="nc">Coyoneda</span><span class="o">.</span><span class="n">lift</span><span class="o">(</span><span class="nc">ISet</span><span class="o">.</span><span class="n">fromList</span><span class="o">(</span><span class="s">"2014-06-01"</span> <span class="o">::</span> <span class="s">"2014-06-22"</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)))</span>
<span class="k">val</span> <span class="nc">OneAnd</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=</span> <span class="n">nes</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">parseDate</span><span class="o">)</span>
</code></pre></div></div>

<p>So we’ve been able to map the Coyoneda! But how do we do something
useful with it?</p>

<p>We couldn’t define a <code class="highlighter-rouge">Functor</code> because it needs <code class="highlighter-rouge">scalaz.Order</code> on the
output type, but we can use the <code class="highlighter-rouge">map</code> method directly on <code class="highlighter-rouge">ISet</code>. We
can use that function by running the Coyoneda like so:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Converts ISetF back to an ISet, using ISet#map with the Order constraint
</span><span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="n">t</span><span class="o">.</span><span class="n">fi</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="n">k</span><span class="o">).</span><span class="n">insert</span><span class="o">(</span><span class="n">h</span><span class="o">)</span>
</code></pre></div></div>

<p>And we’re done!</p>

<p>We’ve been able to use Coyoneda to treat an <code class="highlighter-rouge">ISet</code> as a <code class="highlighter-rouge">Functor</code>,
even though its map function is too constrained to have one defined
directly. This same technique applies to <code class="highlighter-rouge">scala.collection.Set</code> and
any other type-constructor which would otherwise require a
<a href="http://okmij.org/ftp/Haskell/types.html#restricted-datatypes">restricted <code class="highlighter-rouge">Functor</code></a>. I
hope this has demonstrated that <code class="highlighter-rouge">Functor[Set]</code> not existing has no
practical consequences, other than scalac not being as good at
type-inference.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 22 Jun 2014 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2014/06/22/mapping-sets.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2014/06/22/mapping-sets.html</guid>
      </item>
    
      <item>
        <title>Primitive recursion with fix and Mu</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>Consider the simple cons-list datatype.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz.Equal</span><span class="o">,</span> <span class="n">scalaz</span><span class="o">.</span><span class="n">std</span><span class="o">.</span><span class="n">option</span><span class="o">.</span><span class="k">_</span><span class="o">,</span> <span class="n">scalaz</span><span class="o">.</span><span class="n">syntax</span><span class="o">.</span><span class="n">std</span><span class="o">.</span><span class="n">option</span><span class="o">.</span><span class="k">_</span><span class="o">,</span>
       <span class="n">scalaz</span><span class="o">.</span><span class="n">std</span><span class="o">.</span><span class="n">anyVal</span><span class="o">.</span><span class="k">_</span><span class="o">,</span> <span class="n">scalaz</span><span class="o">.</span><span class="n">std</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="k">_</span><span class="o">,</span>
       <span class="n">scala</span><span class="o">.</span><span class="n">reflect</span><span class="o">.</span><span class="n">runtime</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">reify</span>

<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">XNil</span><span class="o">[</span><span class="kt">A</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">XCons</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>And a simple function over this structure.  Say, a simple summing
function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">sum</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">XNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
  <span class="k">case</span> <span class="nc">XCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sum</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And that seems to work out alright.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">nums</span> <span class="k">=</span> <span class="nc">XCons</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">XCons</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="nc">XCons</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="nc">XCons</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="nc">XNil</span><span class="o">()))))</span>
<span class="n">nums</span><span class="k">:</span> <span class="kt">XCons</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">XCons</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="nc">XCons</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="nc">XCons</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="nc">XCons</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span><span class="nc">XNil</span><span class="o">()))))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">sum</span><span class="o">(</span><span class="n">nums</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">51</span>
</code></pre></div></div>

<p>Has it ever struck you as curious that, though its own value was
required to construct a value like <code class="highlighter-rouge">sum</code>, the system has no problem
with that?</p>

<p>Oh, well, that’s just a recursive function, you say.  Well, what’s so
special about recursive functions?  Why do they get special treatment
so that they can define themselves with themselves?</p>

<h2 id="induction-and-termination">Induction and termination</h2>

<p>First, let’s be clear: there’s a limit to how much of <code class="highlighter-rouge">sum</code> can be
used in its own definition.</p>

<p>Let us consider the moral equivalent of the statement “this function
gives the sum of a list of integers because it is the function that
gives the sum of a list of integers.”</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">sum2</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">sum2</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
</code></pre></div></div>

<p>scalac will compile this definition; it is well-typed.  However, it
will be nonsensical at runtime, because it is nonsense; it will either
throw some exception or loop forever.</p>

<p>Let us consider a similar case: the infinite list of 42s.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fortyTwos</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="mi">42</span> <span class="o">#::</span> <span class="n">fortyTwos</span>
<span class="n">fortyTwos</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stream</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="o">?)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fortyTwos</span> <span class="n">take</span> <span class="mi">5</span> <span class="n">toList</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span>
</code></pre></div></div>

<p>The definition of <code class="highlighter-rouge">fortyTwos</code> is like that of <code class="highlighter-rouge">sum</code>; it uses its own
value while constructing said value.  A similar definition to <code class="highlighter-rouge">sum2</code>
is, likewise, nonsense, though scalac can catch this particular case:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fortyTwos2</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">fortyTwos2</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">7</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">value</span> <span class="kt">fortyTwos2</span> <span class="kt">does</span> <span class="kt">nothing</span> <span class="kt">other</span> <span class="kt">than</span> <span class="kt">call</span> <span class="kt">itself</span> <span class="kt">recursively</span>
       <span class="k">val</span> <span class="n">fortyTwos2</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">fortyTwos2</span>
                                     <span class="o">^</span>
</code></pre></div></div>

<p>Obviously, functions <em>aren’t</em> special; non-function values, like
functions, can be defined using their own values.  But how can we
characterize the difference between the good, terminating definitions,
and the bad, nonterminating definitions?</p>

<p>Proof systems like Coq and Agda perform a strong check on recursive
definitions; for definitions like <code class="highlighter-rouge">sum</code>, they require the recursion
match the structure of the data type, just as ours does, so that each
recursive call is known to operate over smaller data.  For definitions
like <code class="highlighter-rouge">fortyTwos</code>, they apply other strategies.  In Scala, we have to
make do with informality.</p>

<p>I like to think of it this way: <strong>a recursive definition must always
perform at least one inductive step</strong>.  <code class="highlighter-rouge">sum</code> does so because, in the
recursive case, it gives “supposing I have the sum of <code class="highlighter-rouge">tail</code>, the sum
is the <code class="highlighter-rouge">head</code> plus that.”  <code class="highlighter-rouge">fortyTwos</code> does because it says “the value
<code class="highlighter-rouge">fortyTwos</code> is <code class="highlighter-rouge">42</code> consed onto the value <code class="highlighter-rouge">fortyTwos</code>.”  It is, at
least, the start of a systematic way of thinking about terminating
recursive definitions.</p>

<h2 id="abstracting-the-recursion">Abstracting the recursion</h2>

<p>Now that we have a framework for thinking about what is required in a
recursive definition, we can start abstracting over it.</p>

<p>The above recursive definitions were accomplished with special
language support: the right-hand side of any term definition, <code class="highlighter-rouge">val</code> or
<code class="highlighter-rouge">def</code>, can refer to the thing being so defined.  Scalaz provides
<a href="http://docs.typelevel.org/api/scalaz/stable/7.0.4/doc/scalaz/std/function$.html">the <code class="highlighter-rouge">fix</code> function</a>,
which, if it were provided intrinsically, would eliminate the need for
this language support.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">fix</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="o">(=&gt;</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">lazy</span> <span class="k">val</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
  <span class="n">a</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In this definition, the value returned by <code class="highlighter-rouge">f</code> <em>is</em> the value given to
it as an argument.  It’s a by-name argument because that’s how we
enforce the requirement: <code class="highlighter-rouge">f</code> must perform at least one inductive step
in the definition of its result, though it can refer to that result by
its argument, which we enforce by requiring it to return a value
<em>before</em> evaluating that argument.</p>

<p>Let’s redefine <code class="highlighter-rouge">sum</code> with <code class="highlighter-rouge">fix</code>, after importing it from
<code class="highlighter-rouge">scalaz.std.function</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">sum3</span><span class="k">:</span> <span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="n">fix</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="kt">Int</span><span class="o">](</span><span class="n">rec</span> <span class="k">=&gt;</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">XNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
  <span class="k">case</span> <span class="nc">XCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">rec</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
<span class="o">})</span>
</code></pre></div></div>

<p>And Scala thinks that’s alright.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">sum3</span><span class="o">(</span><span class="n">nums</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">51</span>
</code></pre></div></div>

<p>The interesting thing here is that <code class="highlighter-rouge">sum3</code>’s definition doesn’t refer
to the name <code class="highlighter-rouge">sum3</code>; the recursion is entirely inside the <code class="highlighter-rouge">fix</code>
argument.  So one advantage of <code class="highlighter-rouge">fix</code> is that it’s easy to write
recursive values as expressions without giving them a name.</p>

<p>For example, there’s the definition of <code class="highlighter-rouge">fortyTwos</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">fix</span><span class="o">[</span><span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]](</span><span class="mi">42</span> <span class="o">#::</span> <span class="k">_</span><span class="o">)</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stream</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="o">?)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res2</span> <span class="n">take</span> <span class="mi">5</span> <span class="n">toList</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="for-special-data-structures">For special data structures</h2>

<p>It can be inconvenient to avoid evaluating the argument when providing
an induction step.  Fortunately, the requirement that <code class="highlighter-rouge">f</code> be nonstrict
in its argument is too strong to characterize the space of values that
can be defined with <code class="highlighter-rouge">fix</code>-style recursion.</p>

<p>For a given data type, there’s often a way to abstract out the
nonstrictness.  For example, here’s an <code class="highlighter-rouge">Equal</code> instance combinator
that is fully evaluated, but doesn’t force the argument until after
the (equivalent) result has been produced.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">lazyEqual</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">A</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Equal</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Equal</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">equal</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">r</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">A</span> <span class="n">equal</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equalIsNatural</span> <span class="k">=</span> <span class="n">A</span><span class="o">.</span><span class="n">equalIsNatural</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Given that, we can produce a <code class="highlighter-rouge">fix</code> variant for <code class="highlighter-rouge">Equal</code> that passes the
<code class="highlighter-rouge">Equal</code> argument strictly.  You’re simply not allowed to invoke any of
the typeclass’s methods.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">fixEq</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Equal</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">fix</span><span class="o">[</span><span class="kt">Equal</span><span class="o">[</span><span class="kt">A</span><span class="o">]](</span><span class="n">A</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">lazyEqual</span><span class="o">(</span><span class="n">A</span><span class="o">)))</span>
</code></pre></div></div>

<p>And now, we have the machinery to build a fully derived <code class="highlighter-rouge">Equal</code>
instance for <code class="highlighter-rouge">XList</code>, without function recursion, by defining the base
case and inductive step!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">`list equal`</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Equal</span><span class="o">]</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">fixEq</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">rec</span> <span class="k">=&gt;</span>
    <span class="nc">Equal</span><span class="o">.</span><span class="n">equalBy</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">Option</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">])]]{</span>
      <span class="k">case</span> <span class="nc">XNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">None</span>
      <span class="k">case</span> <span class="nc">XCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">))</span>
    <span class="o">})</span>
</code></pre></div></div>

<p>That works out to interesting compiled output.  Note especially the
last line, and its (strict) use of <code class="highlighter-rouge">rec</code> towards the end.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">reify</span><span class="o">(</span><span class="n">fixEq</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">rec</span> <span class="k">=&gt;</span>
     <span class="o">|</span>     <span class="nc">Equal</span><span class="o">.</span><span class="n">equalBy</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Option</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">])]]{</span>
     <span class="o">|</span>       <span class="k">case</span> <span class="nc">XNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">None</span>
     <span class="o">|</span>       <span class="k">case</span> <span class="nc">XCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">))</span>
     <span class="o">|</span>     <span class="o">}))</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">reflect.runtime.universe.Expr</span><span class="o">[</span><span class="kt">scalaz.Equal</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]]</span> <span class="k">=</span> 
<span class="nc">Expr</span><span class="o">[</span><span class="kt">scalaz.Equal</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]](</span><span class="nc">$read</span><span class="o">.</span><span class="n">fixEq</span><span class="o">[</span><span class="kt">$read.XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]](((</span><span class="k">implicit</span> <span class="n">rec</span><span class="o">)</span> <span class="k">=&gt;</span>
 <span class="nc">Equal</span><span class="o">.</span><span class="n">equalBy</span><span class="o">[</span><span class="kt">$read.XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">Tuple2</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">$read.XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]]]</span>
 <span class="o">(((</span><span class="n">x0$1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x0$1</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">$read</span><span class="o">.</span><span class="nc">XNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">None</span>
  <span class="k">case</span> <span class="nc">$read</span><span class="o">.</span><span class="nc">XCons</span><span class="o">((</span><span class="n">x</span> <span class="k">@</span> <span class="k">_</span><span class="o">),</span> <span class="o">(</span><span class="n">xs</span> <span class="k">@</span> <span class="k">_</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="nc">Tuple2</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">))</span>
<span class="o">}))(</span><span class="n">option</span><span class="o">.</span><span class="n">optionEqual</span><span class="o">(</span><span class="n">tuple</span><span class="o">.</span><span class="n">tuple2Equal</span><span class="o">(</span><span class="n">anyVal</span><span class="o">.</span><span class="n">intInstance</span><span class="o">,</span> <span class="n">rec</span><span class="o">))))))</span>
</code></pre></div></div>

<p>f0, a binary serialization library,
<a href="https://github.com/joshcough/f0/blob/v1.1.1/src/main/scala/f0/Readers.scala#L216-L222">uses a similar technique</a>
to help define codecs on recursive data structures.</p>

<h2 id="what-about-xlist">What about <code class="highlighter-rouge">XList</code>?</h2>

<p>If we can abstract out the idea of recursive value definitions, what
about recursive type definitions?  Well, thanks to higher kinds, sure!
Scalaz doesn’t provide it, but it is commonly called <code class="highlighter-rouge">Mu</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Mu</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">value</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Mu</span><span class="o">[</span><span class="kt">F</span><span class="o">]])</span>
</code></pre></div></div>

<p>We have to put a class in the middle of it so that we don’t have an
infinite type; Haskell has a similar restriction.  But the principle
is the same as with <code class="highlighter-rouge">fix</code>: feed one datatype induction step <code class="highlighter-rouge">F</code> to the
higher-order type <code class="highlighter-rouge">Mu</code> and it will feed <code class="highlighter-rouge">F</code>’s result back to itself.</p>

<p>For example, here is the equivalent definition of <code class="highlighter-rouge">XList</code> with <code class="highlighter-rouge">Mu</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">XList2Step</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span><span class="k">type</span> <span class="kt">λ</span><span class="o">[</span><span class="kt">α</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Option</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">α</span><span class="o">)]}</span>
<span class="k">type</span> <span class="kt">XList2</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Mu</span><span class="o">[</span><span class="kt">XList2Step</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">#</span><span class="kt">λ</span><span class="o">]</span>
</code></pre></div></div>

<p>Note the typelambda’s similarity to the second type argument to
<code class="highlighter-rouge">#equalBy</code> above.  And for demonstration, the isomorphism with
<code class="highlighter-rouge">XList</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">onetotwo</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">XList2</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">XNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">Mu</span><span class="o">[</span><span class="kt">XList2Step</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">#</span><span class="kt">λ</span><span class="o">](</span><span class="nc">None</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">XCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Mu</span><span class="o">[</span><span class="kt">XList2Step</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">#</span><span class="kt">λ</span><span class="o">](</span><span class="nc">Some</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">onetotwo</span><span class="o">(</span><span class="n">xs</span><span class="o">))))</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">twotoone</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">XList2</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">xs</span><span class="o">.</span><span class="n">value</span> <span class="n">cata</span> <span class="o">({</span><span class="k">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">XCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">twotoone</span><span class="o">(</span><span class="n">xs</span><span class="o">))},</span> <span class="nc">XNil</span><span class="o">())</span>
</code></pre></div></div>

<p>Of course, <code class="highlighter-rouge">fix</code> lends itself to both of these definitions; I have
left its use off here.  But let’s check those functions:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">onetotwo</span><span class="o">(</span><span class="n">nums</span><span class="o">)</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">XList2</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Mu</span><span class="o">(</span><span class="nc">Some</span><span class="o">((</span><span class="mi">2</span><span class="o">,</span><span class="nc">Mu</span><span class="o">(</span><span class="nc">Some</span><span class="o">((</span><span class="mi">3</span><span class="o">,</span><span class="nc">Mu</span><span class="o">(</span><span class="nc">Some</span><span class="o">((</span><span class="mi">4</span><span class="o">,</span><span class="nc">Mu</span><span class="o">(</span><span class="nc">Some</span><span class="o">((</span><span class="mi">42</span><span class="o">,</span><span class="nc">Mu</span><span class="o">(</span><span class="nc">None</span><span class="o">)))))))))))))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">twotoone</span><span class="o">(</span><span class="n">res11</span><span class="o">)</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">XCons</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="nc">XCons</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="nc">XCons</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="nc">XCons</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span><span class="nc">XNil</span><span class="o">()))))</span>
</code></pre></div></div>

<h2 id="fix-over-mu"><code class="highlighter-rouge">fix</code> over <code class="highlighter-rouge">Mu</code></h2>

<p>And, finally, the associated general <code class="highlighter-rouge">Equal</code> definition for <code class="highlighter-rouge">Mu</code>.  The
<code class="highlighter-rouge">contramap</code> step is just noise to deal with the fact that the <code class="highlighter-rouge">Mu</code>
structure has to actually exist; you can ignore it for the most part.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">equalMu</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">Mu</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span> <span class="k">=&gt;</span> <span class="nc">Equal</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">Mu</span><span class="o">[</span><span class="kt">F</span><span class="o">]]])</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">Mu</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">fixEq</span><span class="o">[</span><span class="kt">Mu</span><span class="o">[</span><span class="kt">F</span><span class="o">]](</span><span class="n">emf</span> <span class="k">=&gt;</span> <span class="n">fa</span><span class="o">(</span><span class="n">emf</span><span class="o">)</span> <span class="n">contramap</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">value</span><span class="o">))</span>
</code></pre></div></div>

<p>The evidence we really want is <code class="highlighter-rouge">forall a. Equal[a] =&gt; Equal[F[a]]</code>,
but that’s too hard to express in Scala, so this does it in a pinch.
All we’re interested in is that we can derive <code class="highlighter-rouge">F</code>’s equality given the
equality of any type argument given to it.  Let’s prove that we have
such an <code class="highlighter-rouge">Equal</code>-lifter:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// redefined because Tuple2Equal scalaz is strict on equalIsNatural
</span><span class="k">class</span> <span class="nc">Tuple2Equal</span><span class="o">[</span><span class="kt">A1</span>, <span class="kt">A2</span><span class="o">](</span><span class="n">_1</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">A1</span><span class="o">],</span> <span class="n">_2</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">A2</span><span class="o">])</span>
    <span class="k">extends</span> <span class="nc">Equal</span><span class="o">[(</span><span class="kt">A1</span>, <span class="kt">A2</span><span class="o">)]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">equal</span><span class="o">(</span><span class="n">f1</span><span class="k">:</span> <span class="o">(</span><span class="kt">A1</span><span class="o">,</span> <span class="kt">A2</span><span class="o">),</span> <span class="n">f2</span><span class="k">:</span> <span class="o">(</span><span class="kt">A1</span><span class="o">,</span> <span class="kt">A2</span><span class="o">))</span> <span class="k">=</span>
    <span class="n">_1</span><span class="o">.</span><span class="n">equal</span><span class="o">(</span><span class="n">f1</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">f2</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">_2</span><span class="o">.</span><span class="n">equal</span><span class="o">(</span><span class="n">f1</span><span class="o">.</span><span class="n">_2</span><span class="o">,</span> <span class="n">f2</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equalIsNatural</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">_1</span><span class="o">.</span><span class="n">equalIsNatural</span> <span class="o">&amp;&amp;</span> <span class="n">_2</span><span class="o">.</span><span class="n">equalIsNatural</span>
<span class="o">}</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="n">tup2eq</span><span class="o">[</span><span class="kt">A1:</span> <span class="kt">Equal</span>, <span class="kt">A2:</span> <span class="kt">Equal</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Tuple2Equal</span><span class="o">[</span><span class="kt">A1</span>, <span class="kt">A2</span><span class="o">](</span><span class="n">implicitly</span><span class="o">,</span> <span class="n">implicitly</span><span class="o">)</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Blah</span> <span class="c1">// just a placeholder
</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="o">{</span><span class="k">implicit</span> <span class="n">X</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">Blah</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">Equal</span><span class="o">[</span><span class="kt">XList2Step</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span><span class="k">#</span><span class="kt">λ</span><span class="o">[</span><span class="kt">Blah</span><span class="o">]]]}</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">scalaz.Equal</span><span class="o">[</span><span class="kt">Blah</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">scalaz</span><span class="o">.</span><span class="nc">Equal</span><span class="o">[</span><span class="kt">Option</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Blah</span><span class="o">)]]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>And now that we have <code class="highlighter-rouge">F</code> equality, we’re done, because <code class="highlighter-rouge">Mu</code> is <code class="highlighter-rouge">F</code>s
all the way down.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">equalMu</span><span class="o">[</span><span class="kt">XList2Step</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span><span class="k">#</span><span class="kt">λ</span><span class="o">](</span><span class="k">implicit</span> <span class="n">fa</span> <span class="k">=&gt;</span> <span class="n">implicitly</span><span class="o">)</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">scalaz.Equal</span><span class="o">[</span><span class="kt">Mu</span><span class="o">[[</span><span class="kt">α</span><span class="o">]</span><span class="kt">Option</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">α</span><span class="o">)]]]</span> <span class="k">=</span> <span class="n">scalaz</span><span class="o">.</span><span class="nc">Equal$$anon$2</span><span class="nd">@de52bcf</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res5</span> <span class="n">equal</span> <span class="o">(</span><span class="n">onetotwo</span><span class="o">(</span><span class="n">nums</span><span class="o">),</span> <span class="n">onetotwo</span><span class="o">(</span><span class="n">nums</span><span class="o">))</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res5</span> <span class="n">equal</span> <span class="o">(</span><span class="n">onetotwo</span><span class="o">(</span><span class="n">nums</span><span class="o">),</span> <span class="n">onetotwo</span><span class="o">(</span><span class="nc">XCons</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="n">nums</span><span class="o">)))</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</code></pre></div></div>

<p><em>This article was tested with Scala 2.10.4 &amp; Scalaz 7.0.6.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Mon, 14 Apr 2014 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2014/04/14/fix.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2014/04/14/fix.html</guid>
      </item>
    
      <item>
        <title>When can Liskov be lifted?</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>Scalaz avoids
<a href="http://docs.scala-lang.org/tutorials/tour/variances.html">variance in the sense of the Scala type parameter annotation</a>,
with its associated higher-kind implications, except where it has
historically featured variance; even here, variance is vanishing as
<a href="https://github.com/scalaz/scalaz/pull/630">unsoundness in its released implementations is discovered</a>.</p>

<p>There is a deeply related concept in Scalaz’s typeclasses, though:
<em>covariant and contravariant
functors</em>. <a href="http://docs.typelevel.org/api/scalaz/stable/7.0.4/doc/#scalaz.Functor"><code class="highlighter-rouge">Functor</code></a>
is traditional shorthand for covariant functor, whereas
<a href="http://docs.typelevel.org/api/scalaz/stable/7.0.4/doc/#scalaz.Contravariant"><code class="highlighter-rouge">Contravariant</code></a>
represents contravariant functors.</p>

<p>These concepts are related, but neither subsumes the other. A
<code class="highlighter-rouge">Functor</code> instance does not require its parameter to be
Scala-covariant. A type can be Scala-covariant over a parameter
without having a legal <code class="highlighter-rouge">Functor</code> instance.</p>

<h2 id="liskov"><code class="highlighter-rouge">Liskov</code></h2>

<p><a href="http://docs.typelevel.org/api/scalaz/stable/7.0.4/doc/#scalaz.Liskov"><code class="highlighter-rouge">Liskov</code></a>,
also known as <code class="highlighter-rouge">&lt;~&lt;</code> and very close to Scala’s own
<a href="http://www.scala-lang.org/api/current/#scala.Predef$$$less$colon$less"><code class="highlighter-rouge">&lt;:&lt;</code></a>,
represents a subtyping relationship, and is defined by the ability to
lift it into Scala-covariant and Scala-contravariant parameter
positions, like so:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">liftCo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">+</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">&lt;~&lt;</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">&lt;~&lt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="k">def</span> <span class="n">liftCt</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">-</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">&lt;~&lt;</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">&lt;~&lt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>As <code class="highlighter-rouge">Liskov</code> is, soundly, Scala-variant, this can be implemented
without a cast. However, it can only be called with Scala-covariant
<code class="highlighter-rouge">F</code>.</p>

<p>By definition, applying an <code class="highlighter-rouge">A &lt;~&lt; B</code> to a value of type <code class="highlighter-rouge">A</code> should
yield a value of type <code class="highlighter-rouge">B</code>, but must also do nothing but return the
value; in other words, it is an <em>operational identity</em>. Despite the
limitation of <code class="highlighter-rouge">liftCo</code>, for functorial values that are <em>parametrically
sound</em>, even for Scala-invariant <code class="highlighter-rouge">F</code>, it is operationally sound to
lift <code class="highlighter-rouge">Liskov</code>, though impossible to implement without exploiting Scala
soundness holes:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">liftCvf</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Functor</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">&lt;~&lt;</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">&lt;~&lt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</code></pre></div></div>

<p>For example,
<a href="https://github.com/scalaz/scalaz/blob/v7.1.0-M5/core/src/main/scala/scalaz/IList.scala#L434-L437">this is sound for <code class="highlighter-rouge">scalaz.IList</code></a>.</p>

<h2 id="but-ilistint-isnt-a-subtype-of-ilistany">But <code class="highlighter-rouge">IList[Int]</code> isn’t a subtype of <code class="highlighter-rouge">IList[Any]</code>!</h2>

<p>Sure, as far as Scala is concerned.  But <code class="highlighter-rouge">Liskov</code> is all about making
claims that can’t directly be proven due to the language’s
limitations.  Haskell allows you to constrain functions with type
equalities, which is very important when working with type families;
Scala doesn’t, so we get
<a href="http://docs.typelevel.org/api/scalaz/stable/7.0.4/doc/#scalaz.Leibniz"><code class="highlighter-rouge">Leibniz</code></a>
instead.</p>

<p>A type is a set of values.  Where <em>Y</em> is a supertype of <em>X</em>, every
value in <em>X</em> is in <em>Y</em>.  Since <code class="highlighter-rouge">IList[String]("hi", "there")</code> has the
same representation as <code class="highlighter-rouge">IList[Any]("hi", "there")</code>, they are the same
value.  This is true for <em>all</em> <code class="highlighter-rouge">IList[String]</code>s, but the opposite is
not true; therefore, <code class="highlighter-rouge">IList[Any]</code> is an <code class="highlighter-rouge">IList[String]</code> supertype,
regardless of what Scala knows.</p>

<p>So doing a casting <code class="highlighter-rouge">Liskov</code> lift, like that into <code class="highlighter-rouge">IList</code>, is
essentially “admitted” in a proof system sense.  You are saying, “I
can’t prove that this subtype relationship holds, but it does, so
assume it.”</p>

<p><strong>To decide whether an admitted <code class="highlighter-rouge">A &lt;~&lt; B</code> is sound</strong>: suppose that the
compiler admits that subtyping relationship.  Can it then draw
incorrect conclusions, about the sets of values, derived from that
assumption?  This is the cardinal rule.</p>

<p>By extension, <strong>to decide whether an <code class="highlighter-rouge">F</code> permits Liskov lifting</strong>:
does the above rule pass given <code class="highlighter-rouge">F[A] &lt;~&lt; F[B]</code> <em>for all</em> <code class="highlighter-rouge">A</code>, <code class="highlighter-rouge">B</code>
where <code class="highlighter-rouge">B</code> is a supertype of <code class="highlighter-rouge">A</code>?</p>

<h2 id="parametrically-sound-covariance">Parametrically sound covariance</h2>

<p>Because a <code class="highlighter-rouge">Liskov</code> must be an operational identity, it is essential
that, given any value of <code class="highlighter-rouge">F[A]</code>, for all supertypes <code class="highlighter-rouge">B</code> of <code class="highlighter-rouge">A</code>, the
representation of <code class="highlighter-rouge">F[B]</code> must be identical.  You can determine this by
analyzing the subclasses of <code class="highlighter-rouge">F</code> as an algebraic data type, where the
key test is to ensure that <code class="highlighter-rouge">A</code> <em>never</em> appears in the primitive
contravariant position: as the parameter to a function.  This test is
not quite enough to prove that <code class="highlighter-rouge">Liskov</code> lifting is sound, but it gets
us most of the way.</p>

<p>For example, an <code class="highlighter-rouge">IList</code> of <code class="highlighter-rouge">"hi"</code> and <code class="highlighter-rouge">"there"</code> has exactly the same
representation whether you instantiated the <code class="highlighter-rouge">IList</code> with <code class="highlighter-rouge">String</code> or
with <code class="highlighter-rouge">Any</code>. So that is a good first test. If a class changes its
construction behavior based on manifest type information, or its basic
data construction functions violate
<a href="http://failex.blogspot.com/2013/06/fake-theorems-for-free.html">the rules of parametricity</a>,
that is a good sign that the data type cannot follow these rules.</p>

<p>This data type analysis is recursive: a data type being variant in a
parametrically sound way over a parameter requires that all
appearances of that parameter in elements of your data type are also
parametrically sound in that way. For example, if your <code class="highlighter-rouge">F[A]</code> contains
an <code class="highlighter-rouge">IList[A]</code> in its representation, you may rely on <code class="highlighter-rouge">IList</code>’s
parametrically sound covariance when considering <code class="highlighter-rouge">F</code>’s.</p>

<p>Any <code class="highlighter-rouge">var</code>, or <code class="highlighter-rouge">var</code>-like thing such as an <code class="highlighter-rouge">Array</code>, places its
parameter in an invariant position, because it features a getter
(return type) and setter (parameter type). So its presence in the data
model invalidates <code class="highlighter-rouge">Liskov</code> lifting if the type parameter appears
within it.</p>

<p>Obviously, runtime evidence of a type parameter’s value eliminates the
possibility of lifting <code class="highlighter-rouge">Liskov</code> over that parameter.</p>

<p>You cannot perform this representation analysis without considering
all subclasses of a class under consideration. For example,
considering only
<a href="http://www.scala-lang.org/api/current/#scala.collection.immutable.HashSet"><code class="highlighter-rouge">HashSet</code></a>,
<a href="http://www.scala-lang.org/api/current/#scala.collection.immutable.Set"><code class="highlighter-rouge">collection.immutable.Set</code></a>
appears to allow <code class="highlighter-rouge">Liskov</code> lifting. However,
<a href="http://www.scala-lang.org/api/current/#scala.collection.immutable.TreeSet"><code class="highlighter-rouge">TreeSet</code></a>,
a subclass of <code class="highlighter-rouge">Set</code>, contains a function <code class="highlighter-rouge">(A, A) =&gt; Ordering</code>. If
<em>any</em> representation contains a contradiction like this, <code class="highlighter-rouge">Liskov</code>
lifting is unsafe. You cannot constrain <code class="highlighter-rouge">Liskov</code> application by a
runtime test.</p>

<p>If you permit open subclassing, you must either declare the
requirement to preserve parametric covariance, or accept that it will
be violated, and so forbid <code class="highlighter-rouge">Liskov</code> lifting.</p>

<p>Data that doesn’t use a type parameter doesn’t affect its parametric
soundness.  For example, here <code class="highlighter-rouge">A</code> is invariant, but <code class="highlighter-rouge">B</code> is covariant:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">VA</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span>
</code></pre></div></div>

<h2 id="gadts">GADTs</h2>

<p>Some features of Scala resist simple ADT analysis, so must be
considered separately from the above.  Despite their sound covariance
considering only the representational rules in the previous section,
they still break the cardinal rule by allowing the compiler to make
invalid assumptions about the sets of values.  A “recoverable phantom”
implies a type relationship that forbids <code class="highlighter-rouge">Liskov</code>-lifting, for
example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Gimme</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">object</span> <span class="nc">GimmeI</span> <span class="k">extends</span> <span class="nc">Gimme</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</code></pre></div></div>

<p>In pattern matching, given a <code class="highlighter-rouge">Gimme[A]</code> over unknown <code class="highlighter-rouge">A</code>, matching
<code class="highlighter-rouge">GimmeI</code> successfully recovers the type equality <code class="highlighter-rouge">A ~ Int</code>; therefore,
<code class="highlighter-rouge">Liskov</code>-lifting is unsound for <code class="highlighter-rouge">Gimme</code>.  For example, lifting
<code class="highlighter-rouge">Int &lt;~&lt; Any</code>, applying to <code class="highlighter-rouge">GimmeI</code>, and matching, gives us
<code class="highlighter-rouge">Any ~ Int</code>, which is nonsense.</p>

<p>We can reason about this type equality as a value member of <code class="highlighter-rouge">GimmeI</code>
of type <code class="highlighter-rouge">Leibniz[⊥, ⊤, A, Int]</code>, which places <code class="highlighter-rouge">A</code> in a
representationally invariant position.</p>

<p>Some other GADTs invalidate covariance. For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">P</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">PP</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">P</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">P</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">extends</span> <span class="n">P</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>
</code></pre></div></div>

<p>The pattern match of a <code class="highlighter-rouge">P[A]</code> to <code class="highlighter-rouge">PP[_,_]</code> can theoretically determine
<code class="highlighter-rouge">A ~ (x, y) forSome {type x; type y}</code>, so <code class="highlighter-rouge">Liskov</code> cannot be lifted
into <code class="highlighter-rouge">P</code>.</p>

<p>However, not all GADTs invalidate <code class="highlighter-rouge">Liskov</code>-lifting:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">AM</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">FAM</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">AM</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AM</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</code></pre></div></div>

<p>Matching <code class="highlighter-rouge">AM[A]</code> to <code class="highlighter-rouge">FAM[_,_]</code> reveals nothing about <code class="highlighter-rouge">A</code>; its use of
GADTs only introduces a new existential unrelated to <code class="highlighter-rouge">A</code>.  Considering
only <code class="highlighter-rouge">B</code>, as the <code class="highlighter-rouge">A</code> parameter is called in <code class="highlighter-rouge">FAM</code>, its covariance is
sound in <code class="highlighter-rouge">FAM</code>, so <code class="highlighter-rouge">Liskov</code>s can be lifted into <code class="highlighter-rouge">AM</code>.</p>

<h2 id="contravariance">Contravariance</h2>

<p><code class="highlighter-rouge">Liskov</code>s can also be lifted into parametrically sound contravariant
positions.  This looks a bit like:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">liftCtf</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Contravariant</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">&lt;~&lt;</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">&lt;~&lt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>Analysis of parametrically sound contravariance is essentially the
same as that for covariance.  The only difference is that, for <code class="highlighter-rouge">F[A]</code>,
<code class="highlighter-rouge">A</code> can <em>only</em> appear in the primitive contravariant position: the
function parameter type.</p>

<p>With regard to recursion, the “flipping” behavior of
Scala-contravariance applies.  For example, this data type is soundly
contravariant over <code class="highlighter-rouge">A</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">IOf</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">IList</code> is soundly covariant over <code class="highlighter-rouge">A</code>, and <code class="highlighter-rouge">IList[A]</code> appears in
soundly contravariant position, making <code class="highlighter-rouge">A</code> contravariant.  Meanwhile,
<code class="highlighter-rouge">A</code> is soundly <em>co</em>variant in this data type built upon <code class="highlighter-rouge">IOf</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">IOf2</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">IOf</span><span class="o">[</span><span class="kt">IOf</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span>
</code></pre></div></div>

<h2 id="some-surprises">Some surprises</h2>

<p>Despite the unsoundness of <code class="highlighter-rouge">Liskov</code>-lifting into <code class="highlighter-rouge">Gimme</code> earlier, it
may seem surprising that Scala allows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">GimmeC</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">object</span> <span class="nc">GimmeCI</span> <span class="k">extends</span> <span class="nc">Gimme</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</code></pre></div></div>

<p>Moreover, this isn’t a bug; it’s perfectly sound.  That is because,
while matching <code class="highlighter-rouge">GimmeI</code> causes Scala to infer <code class="highlighter-rouge">A ~ Int</code>, it won’t do
that for <code class="highlighter-rouge">GimmeCI</code>!  Scala can soundly determine that <code class="highlighter-rouge">A ⊇ Int</code> when
it matches <code class="highlighter-rouge">GimmeCI</code>, but I do not think it even goes so far as to do
that as of this writing.  We can’t blame Scala for this difference;
Scala has declared up front that its type system encodes what it
believes, and is <em>our</em> responsibility to follow the cardinal rule of
not violating its assumptions if we lift <code class="highlighter-rouge">Liskov</code> into <code class="highlighter-rouge">Gimme</code>.</p>

<p>As stated earlier, <code class="highlighter-rouge">Liskov</code> cannot be lifted into
<code class="highlighter-rouge">collection.immutable.Set</code>; <code class="highlighter-rouge">TreeSet</code> exists to trivially demonstrate
the problem, but even if <code class="highlighter-rouge">TreeSet</code> was not there, we would not be able
to honestly do it because <code class="highlighter-rouge">c.i.Set</code> is open to new subclasses that
could perform similar violations.  However, despite lacking a
<code class="highlighter-rouge">Functor</code>, <code class="highlighter-rouge">scalaz.ISet</code> <em>does</em> allow <code class="highlighter-rouge">Liskov</code>-lifting.
<a href="https://github.com/scalaz/scalaz/blob/ac8c4684ef89f1b950e71237819d78f573e552ea/core/src/main/scala/scalaz/ISet.scala#L552-L561">Do the ADT analysis yourself, if you like.</a>
Well, so, once you convert your <code class="highlighter-rouge">ISet[Int]</code> to <code class="highlighter-rouge">ISet[Any]</code>, you can’t
do many operations on it, but that’s neither here nor there.</p>

<h2 id="should-this-function-exist">Should this function exist?</h2>

<p>The Scalaz community has settled on a definition of
covariant-functoriality that conforms with the principle of parametric
soundness. The rejection of <code class="highlighter-rouge">Functor</code> instances
<a href="https://github.com/scalaz/scalaz/pull/307">for the <code class="highlighter-rouge">scala.collection.*</code> classes</a>,
which have subclasses with mutable values over their parameters, and
<a href="https://github.com/scalaz/scalaz/pull/276">for <code class="highlighter-rouge">collection.immutable.Set</code></a>,
which has the <code class="highlighter-rouge">TreeSet</code> case stated above and violates parametricity
in the construction of <code class="highlighter-rouge">HashSet</code>s, speak to this. As far as I know,
Scalaz contains no <code class="highlighter-rouge">Functor</code>s that are both Scala-invariant and
violate the rules delineated above.</p>

<p>So how do you feel about the provision of a combinator of the type of
<code class="highlighter-rouge">liftCvf</code> for Scalaz’s <code class="highlighter-rouge">Functor</code>?</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 09 Mar 2014 00:00:00 +0100</pubDate>
        <link>https://typelevel.org/blog/2014/03/09/liskov_lifting.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2014/03/09/liskov_lifting.html</guid>
      </item>
    
      <item>
        <title>How do I error handle thee?</title>
        
          <dc:creator>adelbertc</dc:creator>
                
        <description><![CDATA[<p>Scala has several ways to deal with error handling, and often times people
get confused as to when to use what. This post hopes to address that.</p>

<p><em>Let me count the ways.</em></p>

<h2 id="option"><code class="highlighter-rouge">Option</code></h2>

<p>People coming to Scala from Java-like languages are often told <code class="highlighter-rouge">Option</code> is
a replacement for <code class="highlighter-rouge">null</code> or exception throwing. Say we have a function that
creates some sort of interval, but only allows intervals where the lower bound
comes first.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Interval</span><span class="o">(</span><span class="k">val</span> <span class="n">low</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">high</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">low</span> <span class="o">&gt;</span> <span class="n">high</span><span class="o">)</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"Lower bound must be smaller than upper bound!"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Here we want to create an <code class="highlighter-rouge">Interval</code>, but we want to ensure that the lower bound
is smaller than the upper bound. If it isn’t, we throw an exception. The idea here
is to have some sort of “guarantee” that if at any point I’m given an <code class="highlighter-rouge">Interval</code>,
the lower bound is smaller than the upper bound (otherwise an exception would have
been thrown).</p>

<p>However, throwing exceptions breaks our ability to reason about a function/program.
Control is handed off to the call site, and we hope the call site catches it – if not,
it propagates further up until at some point something catches it, or our program
crashes. We’d like something a bit cleaner than that.</p>

<p>Enter <code class="highlighter-rouge">Option</code> – given our <code class="highlighter-rouge">Interval</code> constructor, construction may or may not succeed.
Put another way, after we enter the constructor, we may or may not have a valid
<code class="highlighter-rouge">Interval</code>. <code class="highlighter-rouge">Option</code> is a type that represents a value that may or may not be there;
it can either be <code class="highlighter-rouge">Some</code> or <code class="highlighter-rouge">None</code>. Let’s use what’s called a <em>smart constructor</em>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">class</span> <span class="nc">Interval</span> <span class="k">private</span><span class="o">(</span><span class="k">val</span> <span class="n">low</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">high</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Interval</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">low</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">high</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Interval</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="o">)</span> <span class="nc">Some</span><span class="o">(</span><span class="k">new</span> <span class="nc">Interval</span><span class="o">(</span><span class="n">low</span><span class="o">,</span> <span class="n">high</span><span class="o">))</span>
    <span class="k">else</span> <span class="nc">None</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We make our class <code class="highlighter-rouge">final</code> so nothing can inherit from it, and we make our constructor
private so nobody can create an instance of <code class="highlighter-rouge">Interval</code> without going through our own
smart constructor function, <code class="highlighter-rouge">Interval.apply</code>. Our <code class="highlighter-rouge">apply</code> function takes some relevant
parameters, and returns an <code class="highlighter-rouge">Option[Interval]</code> that may or may not contain our constructed
<code class="highlighter-rouge">Interval</code>. Our function does not arbitrarily kick control back to the call site due
to an exception and we can reason about it much more easily.</p>

<h2 id="either-and-scalaz"><code class="highlighter-rouge">Either</code> and <code class="highlighter-rouge">scalaz.\/</code></h2>

<p>So, <code class="highlighter-rouge">Option</code> gives us <code class="highlighter-rouge">Some</code> or <code class="highlighter-rouge">None</code>, which is all we need if there is only one thing
that could go wrong. For instance, the standard library’s <code class="highlighter-rouge">Map[K, V]</code> has a function <code class="highlighter-rouge">get</code>
that given a key of type <code class="highlighter-rouge">K</code>, returns <code class="highlighter-rouge">Option[V]</code> – clearly if the key exists, the associated
value is returned (wrapped in a <code class="highlighter-rouge">Some</code>). If the key does not exist, it returns a <code class="highlighter-rouge">None</code>.</p>

<p>But sometimes one of several things can go wrong. Let’s say we have some wonky type that
wants a string that is exactly of length 5 and another string that is a palindrome.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">class</span> <span class="nc">Wonky</span> <span class="k">private</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Wonky</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">validate</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Wonky</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">five</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">5</span><span class="o">)</span> <span class="nc">None</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">palindrome</span> <span class="o">!=</span> <span class="n">palindrome</span><span class="o">.</span><span class="n">reverse</span><span class="o">)</span> <span class="nc">None</span>
    <span class="k">else</span> <span class="nc">Some</span><span class="o">(</span><span class="k">new</span> <span class="nc">Wonky</span><span class="o">(</span><span class="n">five</span><span class="o">,</span> <span class="n">palindrome</span><span class="o">))</span>
<span class="o">}</span>

<span class="cm">/* Somewhere else.. */</span>
<span class="k">val</span> <span class="n">w</span> <span class="k">=</span> <span class="nc">Wonky</span><span class="o">.</span><span class="n">validate</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="c1">// say this returns None
</span></code></pre></div></div>

<p>Clearly something went wrong here, but we don’t know what. If the strings were sent over
from some front end via JSON or something, when we send an error back hopefully we have
something more descriptive than “Something went wrong.” What we want is instead of <code class="highlighter-rouge">None</code>,
we want something more descriptive. We can look into <code class="highlighter-rouge">Either</code> for this, where we use
<code class="highlighter-rouge">Left</code> to hold some sort of error value (similar to <code class="highlighter-rouge">None</code>), and <code class="highlighter-rouge">Right</code> to hold a successful
one (similar to <code class="highlighter-rouge">Some</code>).</p>

<p>To manipulate such values that may or may not exist (presumably obtained from functions that may or may not
fail), we use monadic functions such as <code class="highlighter-rouge">flatMap</code>, often in the form of monad comprehensions, or
for comprehensions as Scala calls them.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">for</span> <span class="o">{</span>
  <span class="n">a</span> <span class="k">&lt;-</span> <span class="n">foo</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="n">b</span> <span class="k">&lt;-</span> <span class="n">bar</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
  <span class="n">c</span> <span class="k">&lt;-</span> <span class="n">baz</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
  <span class="n">d</span> <span class="k">&lt;-</span> <span class="n">quux</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">d</span>
</code></pre></div></div>

<p>In the case of <code class="highlighter-rouge">Option</code>, if any of <code class="highlighter-rouge">foo/bar/baz/quux</code> returns a <code class="highlighter-rouge">None</code>, that <code class="highlighter-rouge">None</code> simply
gets threaded through the rest of the computation – no <code class="highlighter-rouge">try/catch</code> statements marching off
the right side of the screen!</p>

<p>For comprehensions in Scala require the type we’re working with to have <code class="highlighter-rouge">flatMap</code> and
<code class="highlighter-rouge">map</code>. <code class="highlighter-rouge">flatMap</code>, along with <code class="highlighter-rouge">pure</code> and some laws, are the requisite functions needed
to form a monad – <code class="highlighter-rouge">map</code> can be defined in terms of <code class="highlighter-rouge">flatMap</code> and <code class="highlighter-rouge">pure</code>.
With <code class="highlighter-rouge">scala.util.Either</code> however, we don’t have those – we have
to use an explicit conversion via <code class="highlighter-rouge">Either#right</code> or <code class="highlighter-rouge">Either#left</code> to get a
<code class="highlighter-rouge">RightProjection</code> or <code class="highlighter-rouge">LeftProjection</code> (respectively), which specifies in what direction we bias
the <code class="highlighter-rouge">map</code> and <code class="highlighter-rouge">flatMap</code> calls. The convention however, is that the right side is the “correct”
(or “right”, if you will) side and the left represents the failure case, but it is tedious to
continously call <code class="highlighter-rouge">Either#right</code> on values of type <code class="highlighter-rouge">Either</code> to achieve this.</p>

<p>Thankfully, we have an alternative in the Scalaz library via
<code class="highlighter-rouge">scalaz.\/</code> (I just pronounce this “either” – some say disjoint union or just “or”), a right-biased
version of <code class="highlighter-rouge">scala.util.Either</code> – that is, calling <code class="highlighter-rouge">\/#map</code> maps over the value if it’s in
a “right” (<code class="highlighter-rouge">scalaz.\/-</code>), otherwise if it’s “left” (<code class="highlighter-rouge">scalaz.-\/</code>) it just threads it through
without touching it, much like how <code class="highlighter-rouge">Option</code> behaves. We can therefore alter the earlier function:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">WonkyError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">MustHaveLengthFive</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">WonkyError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">MustBePalindromic</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">WonkyError</span>

<span class="k">final</span> <span class="k">class</span> <span class="nc">Wonky</span> <span class="k">private</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Wonky</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">validate</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">WonkyError</span> <span class="kt">\/</span> <span class="kt">Wonky</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">five</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">5</span><span class="o">)</span> <span class="o">-\/(</span><span class="nc">MustHaveLengthFive</span><span class="o">(</span><span class="n">five</span><span class="o">))</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">palindrome</span> <span class="o">!=</span> <span class="n">palindrome</span><span class="o">.</span><span class="n">reverse</span><span class="o">)</span> <span class="o">-\/(</span><span class="nc">MustBePalindromic</span><span class="o">(</span><span class="n">palindrome</span><span class="o">))</span>
    <span class="k">else</span> <span class="o">\/-(</span><span class="k">new</span> <span class="nc">Wonky</span><span class="o">(</span><span class="n">five</span><span class="o">,</span> <span class="n">palindrome</span><span class="o">))</span>
<span class="o">}</span>

<span class="cm">/* Somewhere else.. */</span>
<span class="k">val</span> <span class="n">w</span> <span class="k">=</span> <span class="nc">Wonky</span><span class="o">.</span><span class="n">validate</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">scalaz.\/</code> also has several useful methods not found on <code class="highlighter-rouge">Either</code>.</p>

<h2 id="try"><code class="highlighter-rouge">Try</code></h2>

<p>As of Scala 2.10, we have <code class="highlighter-rouge">scala.util.Try</code> which is essentially an either, with the left type
fixed as <code class="highlighter-rouge">Throwable</code>. There are two problems (that I can think of at this moment) with this:</p>

<ol>
  <li>We want to avoid exceptions where we can.</li>
  <li>It violates the monad laws.</li>
</ol>

<p>A big factor in our ability to deal with all these error handling types nicely
is using their monadic properties in for comprehensions.</p>

<p>For an explanation of the monad laws, there is a nice post
<a href="http://eed3si9n.com/learning-scalaz/Monad+laws.html">here</a> describing them (using Scala). <code class="highlighter-rouge">Try</code>
violates the left identity.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"oops"</span><span class="o">)</span>

<span class="n">foo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// exception is thrown
</span>
<span class="nc">Try</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">flatMap</span><span class="o">(</span><span class="n">foo</span><span class="o">)</span> <span class="c1">// scala.util.Failure
</span></code></pre></div></div>

<p>This can cause unexpected behavior when used, perhaps in a monad/for comprehension. Furthermore,
<code class="highlighter-rouge">Try</code> encourages the use of <code class="highlighter-rouge">Throwable</code>s which breaks control flow and parametricity.
While it certainly may be convenient to be able to wrap an arbitrarily code block with the <code class="highlighter-rouge">Try</code> constructor
and let it catch any exception that may be thrown, we still recommend using an algebraic data type
describing the errors and using <code class="highlighter-rouge">YourErrorType \/ YourReturnType</code>.</p>

<h2 id="scalazvalidation"><code class="highlighter-rouge">scalaz.Validation</code></h2>

<p>Going back to our previous example with validating wonky strings, we see an improvement that
could be made.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">WonkyError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">MustHaveLengthFive</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">WonkyError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">MustBePalindromic</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">WonkyError</span>

<span class="k">final</span> <span class="k">class</span> <span class="nc">Wonky</span> <span class="k">private</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Wonky</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">validate</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">WonkyError</span> <span class="kt">\/</span> <span class="kt">Wonky</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">five</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">5</span><span class="o">)</span> <span class="o">-\/(</span><span class="nc">MustHaveLengthFive</span><span class="o">(</span><span class="n">five</span><span class="o">))</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">palindrome</span> <span class="o">!=</span> <span class="n">palindrome</span><span class="o">.</span><span class="n">reverse</span><span class="o">)</span> <span class="o">-\/(</span><span class="nc">MustBePalindromic</span><span class="o">(</span><span class="n">palindrome</span><span class="o">))</span>
    <span class="k">else</span> <span class="o">\/-(</span><span class="k">new</span> <span class="nc">Wonky</span><span class="o">(</span><span class="n">five</span><span class="o">,</span> <span class="n">palindrome</span><span class="o">))</span>
<span class="o">}</span>

<span class="cm">/* Somewhere else.. */</span>
<span class="k">val</span> <span class="n">w</span> <span class="k">=</span> <span class="nc">Wonky</span><span class="o">.</span><span class="n">validate</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">)</span> <span class="c1">// -\/(MustHaveLengthFive("foo"))
</span></code></pre></div></div>

<p>The fact that one string must have a length of 5 can be checked and reported separately from the other 
being palindromic. Note that in the above example <code class="highlighter-rouge">"foo"</code> does not satisfy the length requirement,
and <code class="highlighter-rouge">"bar"</code> does not satisfy the palindromic requirement, yet only <code class="highlighter-rouge">"foo"</code>’s error is reported
due to how <code class="highlighter-rouge">\/</code> works. What if we want to report any and all errors that could be reported
(“foo” does not have a length of 5 and “bar” is not palindromic)?</p>

<p>If we want to validate several properties at once, and return any and all validation errors,
we can turn to <code class="highlighter-rouge">scalaz.Validation</code>. The modified function would look something like:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">WonkyError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">MustHaveLengthFive</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">WonkyError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">MustBePalindromic</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">WonkyError</span>

<span class="k">final</span> <span class="k">class</span> <span class="nc">Wonky</span> <span class="k">private</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Wonky</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">checkFive</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">ValidationNel</span><span class="o">[</span><span class="kt">WonkyError</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">five</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">5</span><span class="o">)</span> <span class="nc">MustHaveLengthFive</span><span class="o">(</span><span class="n">five</span><span class="o">).</span><span class="n">failNel</span>
    <span class="k">else</span> <span class="n">five</span><span class="o">.</span><span class="n">success</span>

  <span class="k">def</span> <span class="n">checkPalindrome</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">ValidationNel</span><span class="o">[</span><span class="kt">WonkyError</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">p</span><span class="o">.</span><span class="n">reverse</span><span class="o">)</span> <span class="nc">MustBePalindromic</span><span class="o">(</span><span class="n">p</span><span class="o">).</span><span class="n">failNel</span>
    <span class="k">else</span> <span class="n">p</span><span class="o">.</span><span class="n">success</span>

  <span class="k">def</span> <span class="n">validate</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">ValidationNel</span><span class="o">[</span><span class="kt">WonkyError</span>, <span class="kt">Wonky</span><span class="o">]</span> <span class="k">=</span>
    <span class="o">(</span><span class="n">checkFive</span><span class="o">(</span><span class="n">five</span><span class="o">)</span> <span class="o">|@|</span> <span class="n">checkPalindrome</span><span class="o">(</span><span class="n">palindrome</span><span class="o">))</span> <span class="o">{</span> <span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">p</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">new</span> <span class="nc">Wonky</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">p</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/* Somewhere else.. */</span>
<span class="c1">// Failure(NonEmptyList(MustHaveLengthFive("foo"), MustBePalindromic("bar")))
</span><span class="nc">Wonky</span><span class="o">.</span><span class="n">validate</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">)</span>

<span class="c1">// Failure(NonEmptyList(MustBePalindromic("bar")))
</span><span class="nc">Wonky</span><span class="o">.</span><span class="n">validate</span><span class="o">(</span><span class="s">"monad"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">)</span>

<span class="c1">// Success(Wonky("monad", "radar"))
</span><span class="nc">Wonky</span><span class="o">.</span><span class="n">validate</span><span class="o">(</span><span class="s">"monad"</span><span class="o">,</span> <span class="s">"radar"</span><span class="o">)</span>
</code></pre></div></div>

<p>Awesome! However, there is one caveat – we cannot in good conscience use
<code class="highlighter-rouge">scalaz.Validation</code> in a for comprehension. Why? Because there is no valid
monad for it. <code class="highlighter-rouge">Validation</code>’s accumulative nature works via its <code class="highlighter-rouge">Applicative</code>
instance, but due to how the instance works, there is no consistent monad
(every monad is an applicative functor, where monadic bind is consistent with
applicative apply). However, you can use the <code class="highlighter-rouge">Validation#disjunction</code> function to
convert it to a <code class="highlighter-rouge">scalaz.\/</code>, which can then be used in a for comprehension.</p>

<p>One more thing to note: in the above code snippet I used
<code class="highlighter-rouge">ValidationNel</code>, which is just a type alias.
<code class="highlighter-rouge">ValidationNel[E, A]</code> stands for for 
<code class="highlighter-rouge">Validation[NonEmptyList[E], A]</code> – the actual <code class="highlighter-rouge">Validation</code> will take
anything on the left side that is a <code class="highlighter-rouge">Semigroup</code>, and <code class="highlighter-rouge">ValidationNel</code> is
provided as a convenience as often times you may want a non-empty
list of errors describing the various errors that happened in a function.
However, you can do several interesting things with other semigroups.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Fri, 21 Feb 2014 00:00:00 +0100</pubDate>
        <link>https://typelevel.org/blog/2014/02/21/error-handling.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2014/02/21/error-handling.html</guid>
      </item>
    
      <item>
        <title>When implicitly isn't specific enough</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>When working with implicit-encoded dependent function types, such as
<code class="highlighter-rouge">scalaz.Unapply</code> and numerous Shapeless operations, you’d frequently
like to acquire instances of those functions to see what types get
calculated for them.</p>

<p>For example, <code class="highlighter-rouge">++</code> on Shapeless <code class="highlighter-rouge">HList</code>s is driven by <code class="highlighter-rouge">Prepend</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="o">++[</span><span class="kt">S</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span><span class="n">suffix</span> <span class="k">:</span> <span class="kt">S</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">prepend</span> <span class="k">:</span> <span class="kt">Prepend</span><span class="o">[</span><span class="kt">L</span>, <span class="kt">S</span><span class="o">])</span>
  <span class="k">:</span> <span class="kt">prepend.Out</span> <span class="o">=</span> <span class="n">prepend</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">suffix</span><span class="o">)</span>
</code></pre></div></div>

<p>So given some <code class="highlighter-rouge">HList</code>s, we can expect to be able to combine them in a
couple ways.  First, by using the syntax function above, and then by
acquiring a value of <code class="highlighter-rouge">prepend</code>’s type directly and invoking it, just
as in the body of the above function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless._</span><span class="o">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">hlist</span><span class="o">.</span><span class="k">_</span>
<span class="k">import</span> <span class="nn">scalaz._</span><span class="o">,</span> <span class="n">std</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="k">_</span><span class="o">,</span> <span class="n">std</span><span class="o">.</span><span class="n">tuple</span><span class="o">.</span><span class="k">_</span><span class="o">,</span> <span class="n">syntax</span><span class="o">.</span><span class="n">applicative</span><span class="o">.</span><span class="k">_</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">ohi</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="s">"hi"</span> <span class="o">::</span> <span class="nc">HNil</span>
<span class="n">ohi</span><span class="k">:</span> <span class="kt">shapeless.::</span><span class="err">[</span><span class="kt">Int</span><span class="o">,</span><span class="n">shapeless</span><span class="o">.::[</span><span class="kt">String</span>,<span class="kt">shapeless.HNil</span><span class="o">]</span><span class="err">]</span>
        <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="nc">HNil</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">ohi</span> <span class="o">++</span> <span class="n">ohi</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">shapeless.::</span><span class="err">[</span><span class="kt">Int</span><span class="o">,</span><span class="n">shapeless</span><span class="o">.::[</span><span class="kt">String</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.HNil</span><span class="o">]]]</span><span class="err">]</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="nc">HNil</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">ohipohi</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">Prepend</span><span class="o">[</span><span class="kt">String</span> <span class="kt">::</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">HNil</span>, <span class="kt">String</span> <span class="kt">::</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]]</span>
<span class="n">ohipohi</span><span class="k">:</span> <span class="kt">shapeless.ops.hlist.Prepend</span><span class="o">[</span>
           <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.HNil</span><span class="o">]]</span>,
           <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.HNil</span><span class="o">]]]</span>
  <span class="k">=</span> <span class="n">shapeless</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">hlist$Prepend$$anon$58</span><span class="k">@</span><span class="mi">13399</span><span class="n">e98</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">ohipohi</span><span class="o">(</span><span class="n">ohi</span><span class="o">,</span> <span class="n">ohi</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">ohipohi.Out</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="nc">HNil</span>
</code></pre></div></div>

<p>Back over in Scalaz, for purposes of an <code class="highlighter-rouge">Applicative</code> instance,
<code class="highlighter-rouge">(String, Int)</code> selects its second type parameter.  Just as the
<code class="highlighter-rouge">To*OpsUnapply</code> functions acquire <code class="highlighter-rouge">Unapply</code> instances to do their
work:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nc">ToApplicativeOpsUnapply</span><span class="o">[</span><span class="kt">FA</span><span class="o">](</span><span class="n">v</span><span class="k">:</span> <span class="kt">FA</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">F0</span><span class="k">:</span> <span class="kt">Unapply</span><span class="o">[</span><span class="kt">Applicative</span>, <span class="kt">FA</span><span class="o">])</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">ApplicativeOps</span><span class="o">[</span><span class="kt">F0.M</span>,<span class="kt">F0.A</span><span class="o">](</span><span class="n">F0</span><span class="o">(</span><span class="n">v</span><span class="o">))(</span><span class="n">F0</span><span class="o">.</span><span class="nc">TC</span><span class="o">)</span>
</code></pre></div></div>

<p>We can acquire an instance and use it.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">t2ap</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">Unapply</span><span class="o">[</span><span class="kt">Applicative</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]]</span>
<span class="n">t2ap</span><span class="k">:</span> <span class="kt">scalaz.Unapply</span><span class="o">[</span><span class="kt">scalaz.Applicative</span>,<span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span>
<span class="n">scalaz</span><span class="o">.</span><span class="nc">Unapply_0$$anon$13</span><span class="k">@</span><span class="mi">18214797</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">t2ap</span><span class="o">.</span><span class="nc">TC</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">t2ap.M</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="s">""</span><span class="o">,</span><span class="mi">42</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="the-mysterious-result">The mysterious result</h2>

<p>Now let’s get that first element out of that tuple we got by calling
<code class="highlighter-rouge">point</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">res5</span><span class="o">.</span><span class="n">_1</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">31</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">value</span> <span class="k">_</span><span class="err">1</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">a</span> <span class="kt">member</span> <span class="kt">of</span> <span class="kt">t2ap.M</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
              <span class="n">res5</span><span class="o">.</span><span class="n">_1</span>
                   <span class="o">^</span>
</code></pre></div></div>

<p>Uh, huh?  Let’s try adding the <code class="highlighter-rouge">HList</code>s we got from <code class="highlighter-rouge">ohipohi</code> before.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cala</span><span class="o">&gt;</span> <span class="n">res3</span> <span class="o">++</span> <span class="n">res3</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">32</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">could</span> <span class="kt">not</span> <span class="kt">find</span> <span class="kt">implicit</span> <span class="kt">value</span> <span class="kt">for</span> <span class="kt">parameter</span>
              <span class="n">prepend</span><span class="k">:</span> <span class="kt">shapeless.ops.hlist.Prepend</span><span class="o">[</span><span class="kt">ohipohi.Out</span>,<span class="kt">ohipohi.Out</span><span class="o">]</span>
              <span class="n">res3</span> <span class="o">++</span> <span class="n">res3</span>
                   <span class="o">^</span>
</code></pre></div></div>

<p>The clue is in the type report in the above: path-dependent type
members of <code class="highlighter-rouge">t2ap</code> and <code class="highlighter-rouge">ohipohi</code> appear.  That wouldn’t be a problem,
normally, as we know what they are, but <strong>they’re existential</strong> to
Scala.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">t2ap.M</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="kt">=:=</span> <span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">30</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">Cannot</span> <span class="kt">prove</span> <span class="kt">that</span> <span class="kt">t2ap.M</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">=:=</span> <span class="o">(</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Int</span><span class="o">).</span>
              <span class="n">implicitly</span><span class="o">[</span><span class="kt">t2ap.M</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="kt">=:=</span> <span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span>
                        <span class="o">^</span>
</code></pre></div></div>

<h2 id="implicitly-only-gives-what-you-ask-for"><code class="highlighter-rouge">implicitly</code> only gives what you ask for</h2>

<p>The explanation lies with the <code class="highlighter-rouge">implicitly</code> calls we made to acquire
the specific dependent functions we wanted to use.  Let’s look at the
definition of <code class="highlighter-rouge">implicitly</code> and see if it can enlighten:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">implicit</span> <span class="n">e</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
</code></pre></div></div>

<p>In other words, <code class="highlighter-rouge">implicitly</code> returns exactly what you asked for,
type-wise.  Recall the inferred type of <code class="highlighter-rouge">ohipohi</code> when it was defined:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ohipohi</span><span class="k">:</span> <span class="kt">shapeless.ops.hlist.Prepend</span><span class="o">[</span>
           <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.HNil</span><span class="o">]]</span>,
           <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.HNil</span><span class="o">]]]</span>
</code></pre></div></div>

<p>Not coincidentally, <em>this is the exact type we gave as a type
parameter to <code class="highlighter-rouge">implicitly</code></em>.  What’s important is that <code class="highlighter-rouge">Out</code>, the type
member of <code class="highlighter-rouge">Prepend</code> that determines its result type, is existential in
both cases.</p>

<p>In other words, the rule of <code class="highlighter-rouge">implicitly</code> is “you asked for it, you got
it”.</p>

<h2 id="a-more-specific-implicitly">A more specific <code class="highlighter-rouge">implicitly</code></h2>

<p>The answer here is to simulate the weird way in which dependent method
types, like <code class="highlighter-rouge">++</code> and <code class="highlighter-rouge">ToApplicativeOpsUnapply</code>, can pass through extra
type information about their implicit parameters that would otherwise
be lost.  We do this by reinventing <code class="highlighter-rouge">implicitly</code>.</p>

<p>The first try is obvious: follow the comment in the <code class="highlighter-rouge">Predef.scala</code>
source and give <code class="highlighter-rouge">implicitly</code> a singleton type result.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">implicitly2</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">AnyRef</span><span class="o">](</span><span class="k">implicit</span> <span class="n">e</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="kt">with</span> <span class="kt">e.</span><span class="k">type</span> <span class="o">=</span> <span class="n">e</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">ohipohi2</span> <span class="k">=</span> <span class="n">implicitly2</span><span class="o">[</span><span class="kt">Prepend</span><span class="o">[</span><span class="kt">Int</span> <span class="kt">::</span> <span class="kt">String</span> <span class="kt">::</span> <span class="kt">HNil</span>, <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">String</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]]</span>
<span class="n">ohipohi2</span><span class="k">:</span> <span class="kt">shapeless.ops.hlist.Prepend</span><span class="o">[</span>
              <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.HNil</span><span class="o">]]</span>,
              <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.HNil</span><span class="o">]]]</span>
     <span class="k">with</span> <span class="n">e</span><span class="o">.</span><span class="k">type</span> <span class="o">=</span> <span class="n">shapeless</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">hlist$Prepend$$anon$58</span><span class="k">@</span><span class="mi">4</span><span class="n">abe65da</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">ohipohi2</span><span class="o">(</span><span class="n">ohi</span><span class="o">,</span> <span class="n">ohi</span><span class="o">)</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">ohipohi2.Out</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="nc">HNil</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res9</span> <span class="o">++</span> <span class="n">res9</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">33</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">could</span> <span class="kt">not</span> <span class="kt">find</span> <span class="kt">implicit</span> <span class="kt">value</span> <span class="kt">for</span> <span class="kt">parameter</span>
              <span class="n">prepend</span><span class="k">:</span> <span class="kt">shapeless.ops.hlist.Prepend</span><span class="o">[</span><span class="kt">ohipohi2.Out</span>,<span class="kt">ohipohi2.Out</span><span class="o">]</span>
              <span class="n">res9</span> <span class="o">++</span> <span class="n">res9</span>
                   <span class="o">^</span>
</code></pre></div></div>

<p>Not quite good enough.</p>

<h2 id="an-even-more-albeit-less-specific-implicitly">An even more, albeit less, specific <code class="highlighter-rouge">implicitly</code></h2>

<p>I think it’s strange that the above doesn’t work, but we can deal with
it by being a little more specific.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">implicitlyDepFn</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">DepFn2</span><span class="o">[</span><span class="k">_</span>,<span class="k">_</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">e</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span>
    <span class="k">:</span> <span class="kt">T</span> <span class="o">{</span><span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="kt">e.Out</span><span class="o">}</span> <span class="k">=</span> <span class="n">e</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">ohipohi3</span> <span class="k">=</span> <span class="n">implicitlyDepFn</span><span class="o">[</span><span class="kt">Prepend</span><span class="o">[</span><span class="kt">Int</span> <span class="kt">::</span> <span class="kt">String</span> <span class="kt">::</span> <span class="kt">HNil</span>, <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">String</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]]</span>
<span class="n">ohipohi3</span><span class="k">:</span> <span class="kt">shapeless.ops.hlist.Prepend</span><span class="o">[</span>
              <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.HNil</span><span class="o">]]</span>,
              <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.HNil</span><span class="o">]]]{</span>
                <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="n">shapeless</span><span class="o">.::[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,
                            <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.HNil</span><span class="o">]]]]</span>
          <span class="o">}</span> <span class="k">=</span> <span class="n">shapeless</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">hlist$Prepend$$anon$58</span><span class="k">@</span><span class="mf">7306572f</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">ohipohi3</span><span class="o">(</span><span class="n">ohi</span><span class="o">,</span> <span class="n">ohi</span><span class="o">)</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">ohipohi3.Out</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="nc">HNil</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res11</span> <span class="o">++</span> <span class="n">res11</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">shapeless.::</span><span class="err">[</span><span class="kt">Int</span><span class="o">,</span><span class="n">shapeless</span><span class="o">.::[</span><span class="kt">String</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,
       <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,
       <span class="kt">shapeless.HNil</span><span class="o">]]]]]]]</span><span class="err">]</span>
   <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="nc">HNil</span>
</code></pre></div></div>

<p>Now that’s more like it.  The trick is in the return type of
<code class="highlighter-rouge">implicitlyDepFn</code>, which includes the structural refinement <code class="highlighter-rouge">{type Out
= e.Out}</code>.</p>

<p>Again, it’s weird that this structural refinement isn’t subsumed by
the return type <code class="highlighter-rouge">e.type</code> from <code class="highlighter-rouge">implicitly2</code>’s definition, but I’m not
sure it’s wrong, either, given the ephemeral nature of type stability.</p>

<p>Thankfully, most of the evidence for dependent function types in
Shapeless extends from the <code class="highlighter-rouge">DepFn*</code> traits, so you only need one of
these special <code class="highlighter-rouge">implicitly</code> variants for each, rather than one for each
individual dependent function type you wish to acquire instances of in
this way.</p>

<h2 id="and-likewise-with-unapply">And likewise with <code class="highlighter-rouge">Unapply</code></h2>

<p>We can similarly acquire instances of <code class="highlighter-rouge">scalaz.Unapply</code> conveniently.
I believe this function will be supplied with Scalaz 7.0.6, and it is
<a href="https://github.com/scalaz/scalaz/pull/621">already included in the 7.1 development branch</a>,
so you will be able to write <code class="highlighter-rouge">Unapply[TC, type]</code> to get instances as
with plain typeclass lookup in Scalaz, but it’s easy enough to define
yourself.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">unap</span><span class="o">[</span><span class="kt">TC</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">MA</span><span class="o">](</span><span class="k">implicit</span> <span class="n">U</span><span class="k">:</span> <span class="kt">Unapply</span><span class="o">[</span><span class="kt">TC</span>, <span class="kt">MA</span><span class="o">])</span><span class="k">:</span> <span class="kt">U.</span><span class="k">type</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">A</span>
<span class="o">}</span> <span class="k">=</span> <span class="n">U</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">t2ap2</span> <span class="k">=</span> <span class="n">unap</span><span class="o">[</span><span class="kt">Applicative</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span>
<span class="n">t2ap2</span><span class="k">:</span> <span class="kt">U.</span><span class="k">type</span><span class="o">{</span><span class="k">type</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">,</span> <span class="n">A</span><span class="o">);</span> <span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="nc">Int</span><span class="o">}</span> 
  <span class="k">=</span> <span class="n">scalaz</span><span class="o">.</span><span class="nc">Unapply_0$$anon$13</span><span class="k">@</span><span class="mi">3</span><span class="n">adb9933</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">t2ap2</span><span class="o">.</span><span class="nc">TC</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
<span class="n">res13</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="s">""</span><span class="o">,</span><span class="mi">42</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res13</span><span class="o">.</span><span class="n">_1</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
</code></pre></div></div>

<p><em>This article was tested with Scala 2.10.3, Scalaz 7.0.5, and
Shapeless 2.0.0-M1.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sat, 18 Jan 2014 00:00:00 +0100</pubDate>
        <link>https://typelevel.org/blog/2014/01/18/implicitly_existential.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2014/01/18/implicitly_existential.html</guid>
      </item>
    
      <item>
        <title>Towards Scalaz (Part 2)</title>
        
          <dc:creator>adelbertc</dc:creator>
                
        <description><![CDATA[<p>A lot of people see Scalaz as a hard fringe, ivory tower,
not suited for real-world applications library, which is
unfortunate. The goal of this blog post series is to introduce
various components of Scalaz, and hopefully through this
allow folks to gain an understanding towards the power of
Scalaz.</p>

<p>As a prerequisite, I assume knowledge of type classes as they
are implemented and used in Scala, higher kinded types,
and sum types (e.g. <code class="highlighter-rouge">Option/Some/None</code>, <code class="highlighter-rouge">Either/Left/Right</code>).</p>

<p>For a tutorial/review on (higher) kinds, I recommend the following resources:</p>

<ul>
  <li><a href="http://blogs.atlassian.com/2013/09/scala-types-of-a-higher-kind/">Scala: Types of a higher kind</a></li>
  <li><a href="http://adriaanm.github.io/files/higher.pdf">Generics of a Higher Kind</a></li>
  <li><a href="http://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala">SO: What is a higher kinded type in Scala?</a></li>
</ul>

<h2 id="part-2-summations-of-a-higher-kind">Part 2: Summations of a Higher Kind</h2>

<p><a href="/blog/2013/10/13/towards-scalaz-1.html">Last time</a> we left off after
writing our own generic <code class="highlighter-rouge">sum</code> function:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz.Monoid</span>

<span class="k">def</span> <span class="n">sumGeneric</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">l</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="n">zero</span><span class="o">)((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div></div>

<p>This allowed us to sum a list not only of numeric types like
<code class="highlighter-rouge">Int</code>, but also others that could be added and had a “zero” such as
<code class="highlighter-rouge">String</code> via string concatenation and the empty string, as well as
<code class="highlighter-rouge">List[A]</code> via list concatenation and the empty list.</p>

<p>But, we can do better! Why limit ourselves to <code class="highlighter-rouge">List</code>? What if we want
to sum over a <code class="highlighter-rouge">Vector</code>, or even a tree? We <em>could</em> use <code class="highlighter-rouge">Seq</code> and that
would allow us to pass in <code class="highlighter-rouge">List</code> or <code class="highlighter-rouge">Vector</code>, but it still brings up
the problem of trees, and any other data structure that may not fit
the <code class="highlighter-rouge">Seq</code> bill.</p>

<h3 id="what-do-we-want-folds">What do we want? Folds!</h3>
<p>Recall when we “came up with” <code class="highlighter-rouge">Semigroup</code> and <code class="highlighter-rouge">Monoid</code> last time -
what did we do? We simply looked at what operations we needed
(<code class="highlighter-rouge">add/append</code> and <code class="highlighter-rouge">zero</code>) and factored it out into a type class.
Let’s try doing the same this time.</p>

<p>So what are we doing with <code class="highlighter-rouge">List</code> in our implementation? Nothing much
really, we’re just folding over it. If we think about it, we could
“fold” over say, a tree as well. Let’s take this operation out into
a type class, and aptly name it <code class="highlighter-rouge">Foldable</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Foldable</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="c1">// Instead of requiring the contents to be monoidal, let's
</span>  <span class="c1">// make it flexible by allowing a fold as long as we can convert
</span>  <span class="c1">// the contents to a type that has a `Monoid`.
</span>  <span class="k">def</span> <span class="n">foldMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">B</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">B</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And let’s implement instances of this type class for <code class="highlighter-rouge">List</code> and our own
<code class="highlighter-rouge">Tree</code>.</p>

<p>Our tree definition:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">Node</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">left</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Leaf</span><span class="o">[</span><span class="kt">A</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>and our instances:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Foldable</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">listIsFoldable</span><span class="k">:</span> <span class="kt">Foldable</span><span class="o">[</span><span class="kt">List</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Foldable</span><span class="o">[</span><span class="kt">List</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">foldMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">B</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span>
        <span class="n">fa</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="n">B</span><span class="o">.</span><span class="n">zero</span><span class="o">)((</span><span class="n">acc</span><span class="o">,</span> <span class="n">elem</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="n">acc</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">elem</span><span class="o">)))</span>
    <span class="o">}</span>

  <span class="k">implicit</span> <span class="k">val</span> <span class="n">treeIsFoldable</span><span class="k">:</span> <span class="kt">Foldable</span><span class="o">[</span><span class="kt">Tree</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Foldable</span><span class="o">[</span><span class="kt">Tree</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">foldMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">B</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span>
        <span class="n">fa</span> <span class="k">match</span> <span class="o">{</span>
          <span class="k">case</span> <span class="nc">Leaf</span><span class="o">()</span> <span class="k">=&gt;</span>
            <span class="n">B</span><span class="o">.</span><span class="n">zero</span>
          <span class="k">case</span> <span class="nc">Node</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="n">B</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">value</span><span class="o">),</span> <span class="n">B</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="n">foldMap</span><span class="o">(</span><span class="n">left</span><span class="o">)(</span><span class="n">f</span><span class="o">),</span> <span class="n">foldMap</span><span class="o">(</span><span class="n">right</span><span class="o">)(</span><span class="n">f</span><span class="o">)))</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>and finally, our new summing function:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">sumGeneric</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Foldable</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">fa</span><span class="o">.</span><span class="n">foldMap</span><span class="o">(</span><span class="n">identity</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="scalaz-to-the-rescue">Scalaz to the rescue</h3>
<p>As with last time, Scalaz defines the <code class="highlighter-rouge">Foldable</code> type class for us. However,
to really be “foldable”, not only should you define <code class="highlighter-rouge">foldMap</code>, but <code class="highlighter-rouge">foldRight</code>
as well. Some of you may be wondering why <code class="highlighter-rouge">foldRight</code> and not <code class="highlighter-rouge">foldLeft</code>, or both?
The reasons for this decision are that</p>

<ul>
  <li><code class="highlighter-rouge">foldLeft</code> can be defined in terms of <code class="highlighter-rouge">foldRight</code> (a fun exercise is to try this for yourself)</li>
  <li><code class="highlighter-rouge">foldLeft</code> fails on infinite lists (think <code class="highlighter-rouge">Stream</code> in Scala)</li>
</ul>

<p>That being said, Scalaz defines instances of <code class="highlighter-rouge">Foldable</code> for many of the standard
Scala types (<code class="highlighter-rouge">List</code>, <code class="highlighter-rouge">Vector</code>, <code class="highlighter-rouge">Stream</code>, <code class="highlighter-rouge">Option</code>), as well as its own (<code class="highlighter-rouge">Tree</code>, <code class="highlighter-rouge">EphemeralStream</code>).
The methods available on the type class not only include <code class="highlighter-rouge">foldMap</code> and <code class="highlighter-rouge">foldRight</code> which
are required to be implemented, but several derived ones as well including <code class="highlighter-rouge">fold</code> (<code class="highlighter-rouge">foldMap</code> with
<code class="highlighter-rouge">identity</code>), <code class="highlighter-rouge">foldLeft</code>, <code class="highlighter-rouge">toList/IndexedSeq/Stream</code>, among others.</p>

<p>So our code with <code class="highlighter-rouge">scalaz.Foldable</code> now looks like:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz.</span><span class="o">{</span> <span class="nc">Foldable</span><span class="o">,</span> <span class="nc">Monoid</span> <span class="o">}</span>

<span class="c1">// Note that this is equivalent to scalaz.Foldable#fold
</span><span class="k">def</span> <span class="n">sumGeneric</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Foldable</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">fa</span><span class="o">.</span><span class="n">fold</span>
</code></pre></div></div>

<p>Note that the implementation of the function is rather plain, but that’s a good thing!
This shows the level of genericity type classes, folds,  and Scalaz is capable of. If you ever
find yourself needing to fold something down, look at the methods available on
<code class="highlighter-rouge">scalaz.Foldable</code>. By simply adding an instance of <code class="highlighter-rouge">Foldable</code> to your <code class="highlighter-rouge">F[_]</code> by implementing
the two methods above, you get “for free” a bunch of
<a href="http://docs.typelevel.org/api/scalaz/stable/7.0.4/doc/#scalaz.Foldable">derived ones</a>!</p>

<h3 id="an-aside-taming-the-elephant">An Aside: Taming the Elephant</h3>
<p>In recent days, the word “Hadoop” has become synonymous with “big data.” The MapReduce
system made popular by <a href="http://research.google.com/archive/mapreduce.html">Google</a>
has made it’s way into several companies looking to glean information from their data.</p>

<p>Why am I mentioning this in a typelevel.scala blog post? Well, think about the reduce phase –
what is really happening? For a particular key, we’re given a list of values emitted
for that key, and we want to reduce those values into a single value. Sound familiar?
Sounds a bit like <code class="highlighter-rouge">fold</code>, doesn’t it? Note that not all reductions in MapReduce have to follow
monoid laws, but a surprising amount do as demonstrated by Twitter’s
<a href="https://github.com/twitter/algebird">Algebird</a> project.</p>

<p>Going back to <code class="highlighter-rouge">fold</code>, recall that in order to just <code class="highlighter-rouge">fold</code> we need to have something
<code class="highlighter-rouge">Foldable</code> that contains something that already has a <code class="highlighter-rouge">Monoid</code> instance. A more general
approach, as taken by <code class="highlighter-rouge">scalaz.Foldable</code>, is to also provide a <code class="highlighter-rouge">foldMap</code> function which
lets us also pass in a function <em>map</em>ping each element of the <code class="highlighter-rouge">Foldable</code> to something
that is a <code class="highlighter-rouge">Monoid</code>, and reduce over that instead.</p>

<p>So. Given something, say a <code class="highlighter-rouge">List[A]</code>, we want to <em>Map</em> each element of the list to
an element of a type that has a <code class="highlighter-rouge">Monoid</code> instance, and then we want to <em>Reduce</em> the
list down to a single value. What is this? All together now: MapReduce!</p>

<p>Unfortunately, Hadoop MapReduce by itself does not give you anything like a <code class="highlighter-rouge">List</code>.
Fortunately, our good friends at <a href="http://www.nicta.com.au/">NICTA</a> have developed
and open sourced the wonderful <a href="https://github.com/nicta/scoobi">Scoobi</a> project,
which abstracts over Hadoop MapReduce by providing a <code class="highlighter-rouge">List</code>-like interface, called a
<code class="highlighter-rouge">DList</code> (distributed list). Users treat the <code class="highlighter-rouge">DList</code> very similarly to how they would
a regular Scala <code class="highlighter-rouge">List</code>, and perform operations on it that get compiled down into
MapReduce jobs. Such operations include not only the familiar (and expected) <code class="highlighter-rouge">map</code>
and <code class="highlighter-rouge">reduce</code> combinators, but also our friends <code class="highlighter-rouge">foldMap</code> and <code class="highlighter-rouge">fold</code>. While <code class="highlighter-rouge">DList</code>’s
do not have a proper <code class="highlighter-rouge">Foldable</code> instance due to the difficulty of implementing <code class="highlighter-rouge">foldRight</code>
for the MapReduce, I find it to be a great example of the power of abstractions and
genericity abstract algebra and Scalaz provides to us as programmers.</p>

<h2 id="further-reading">Further Reading</h2>

<ul>
  <li><a href="http://tmorris.net/posts/list-folds-bfpg/index.html">List Folds at BFPG</a></li>
  <li><a href="http://www.cs.nott.ac.uk/~gmh/fold.pdf">A tutorial on the universality and expressiveness of folds</a></li>
</ul>

<h2 id="getting-help">Getting Help</h2>

<p>If you have any questions/comments/concerns, feel free to hop onto the IRC channel on
Freenode at <code class="highlighter-rouge">#scalaz</code>.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 15 Dec 2013 00:00:00 +0100</pubDate>
        <link>https://typelevel.org/blog/2013/12/15/towards-scalaz-2.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2013/12/15/towards-scalaz-2.html</guid>
      </item>
    
      <item>
        <title>Law Enforcement using Discipline</title>
        
          <dc:creator>larsrh</dc:creator>
                
        <description><![CDATA[<p>Some nine or ten months ago, <a href="http://github.com/non/spire">Spire</a>’s project structure underwent a major reorganization.
Simultaneously, the <a href="http://www.scalacheck.org/">Scalacheck</a> bindings were refactored, completely overhauling the law-checking infrastructure.</p>

<h2 id="requirements">Requirements</h2>

<p>The main goal was to make it easy to check that instances of Spire’s type classes adhere to the set of algebraic laws of the respective type classes.
<a href="https://github.com/scalaz/scalaz">Scalaz</a> also has such an infrastructure, so why not take that one?
The problem is that in Spire, the hierarchy of type classes is a little bit more complex:</p>

<p>On the one hand, there is a “generic” tower of type classes including <code class="highlighter-rouge">Semigroup</code>, <code class="highlighter-rouge">Monoid</code> and the like, where each successive type extends its predecessor.
On the other hand, this tower is replicated <em>twice</em> for their “additive” and “multiplicative” counterparts.
These classes are isomorphic, up to the semantics, and hence naming of their operations.</p>

<p>This distinction is quite useful, because now one can write:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Semiring</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">AdditiveMonoid</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">with</span> <span class="nc">MultiplicativeSemigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// ...
</span><span class="o">}</span>
</code></pre></div></div>

<p>without clashes between the additive and multiplicative binary operations.
Also, a semiring can now be quite naturally treated as an additive monoid and a multiplicative semigroup (but not as a generic semigroup, which would be ambiguous).
(One could consider this the <em>third</em> hierarchy of algebraic type classes in spire.)</p>

<p>When checking laws, we do not want to repeat the same laws over and over again.
Hence, we need some way to express that certain type classes share laws with others which are not necessarily in the same type hierarchy.</p>

<h2 id="interface">Interface</h2>

<p>The implementation fundamentally depends on Scalacheck.
To be more specific, it uses <code class="highlighter-rouge">Prop</code> as the elementary unit of testing.</p>

<p>Now, a set of named <code class="highlighter-rouge">Prop</code>s do not quite suffice as the “law” of a type class.
First, to avoid ambiguous naming, let us call the complete law of a type class (including dependencies), a “rule set”.</p>

<p>To satisfy our requirement of having dependencies from (potentially) different hierarchies, we will distinguish <em>parents</em> and <em>bases</em>.
A <em>parent</em> is a rule set of a type class in the same hierachy, whereas a <em>base</em> can come from everywhere.
This distinction is expressed with the use of path-dependent types:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Laws</span> <span class="o">{</span>

  <span class="k">trait</span> <span class="nc">RuleSet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span>
    <span class="k">def</span> <span class="n">bases</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Laws</span><span class="k">#</span><span class="kt">RuleSet</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">()</span>
    <span class="k">def</span> <span class="n">parents</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">RuleSet</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">()</span>
    <span class="k">def</span> <span class="n">props</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Prop</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">()</span>

    <span class="c1">// ...
</span>  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>As we can see, <code class="highlighter-rouge">parents</code> uses type <code class="highlighter-rouge">RuleSet</code>, which constrains parents to the same outer <code class="highlighter-rouge">Laws</code> instance.
In contrast, <code class="highlighter-rouge">bases</code> uses the type <code class="highlighter-rouge">Laws#RuleSet</code> which means that bases can come from other instances of <code class="highlighter-rouge">Laws</code>.</p>

<p>When you define type classes, the general idea is to define one instance of <code class="highlighter-rouge">Laws</code> for each <em>hierarchy</em> of type classes.
Coming back to the Spire example, that could look like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">GroupLaws</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">semigroup</span><span class="o">(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Semigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">RuleSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RuleSet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">name</span> <span class="k">=</span> <span class="s">"semigroup"</span>
    <span class="k">def</span> <span class="n">props</span> <span class="k">=</span> <span class="c1">// ...
</span>  <span class="o">}</span>

  <span class="k">def</span> <span class="n">monoid</span><span class="o">(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">RuleSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RuleSet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">name</span> <span class="k">=</span> <span class="s">"monoid"</span>
    <span class="k">def</span> <span class="n">parents</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">semigroup</span><span class="o">)</span>
    <span class="k">def</span> <span class="n">props</span> <span class="k">=</span> <span class="c1">// ...
</span>  <span class="o">}</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">AdditiveLaws</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">groupLaws</span><span class="k">:</span> <span class="kt">GroupLaws</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">semigroup</span><span class="o">(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">AdditiveSemigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">RuleSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RuleSet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">name</span> <span class="k">=</span> <span class="s">"additive semigroup"</span>

    <span class="c1">// `.additive` converts an additive X to a generic X
</span>    <span class="k">def</span> <span class="n">bases</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">"additive"</span> <span class="o">→</span> <span class="n">groupLaws</span><span class="o">.</span><span class="n">semigroup</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="n">additive</span><span class="o">))</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">monoid</span><span class="o">(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">AdditiveMonoid</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">RuleSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RuleSet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">name</span> <span class="k">=</span> <span class="s">"additive monoid"</span>

    <span class="k">def</span> <span class="n">bases</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">"additive"</span> <span class="o">→</span> <span class="n">groupLaws</span><span class="o">.</span><span class="n">monoid</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="n">additive</span><span class="o">))</span>
    <span class="k">def</span> <span class="n">parent</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">semigroup</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This now clearly expresses the intention:</p>

<ul>
  <li>A monoid is a semigroup.</li>
  <li>An additive semigroup should satisfy the laws of a semigroup.</li>
  <li>An additive monoid is an additive semigroup and should satisfy the laws of a monoid.</li>
</ul>

<p>Note that in the definitions inside <code class="highlighter-rouge">AdditiveLaws</code>, no properties have been restated.
The system will automatically take care that all the properties of the parents and the bases are being checked.</p>

<p>Obviously, this is not very interesting yet, because so far it could have been achieved by other means.
If you are interested in more complex examples, check the sources of Spire:
There are a couple of examples where the additive and multiplicative versions have extra checks which are not covered by the generic version.</p>

<h2 id="implementation">Implementation</h2>

<p>Now, the question is how to compute the set of all properties which need to be checked.
A naïve algorithm would just recursively traverse all bases and parents, and check the union of all the property sets.</p>

<p>However, this leads to unnecessary work.
Consider the rule set of an additive monoid.
There, the properties of semigroup would be included twice:
once via the semigroup base of the additive semigroup parent, and once via the semigroup parent of the monoid base.</p>

<p>While checking properties twice certainly does no damage, we still do not want to pay for that overhead.
Hence, a slightly smarter algorithm is used.
We compute the set of all properties of a certain class by taking the union of these sets:</p>

<ul>
  <li>the properties of the class itself</li>
  <li>recursively, the properties of all its parents (ignoring their bases)</li>
  <li>recursively, the set of all properties of its bases</li>
</ul>

<p>In order to present the user a more transparent output, the names of the properties are hierarchical.
When a base is pulled in as dependency, their properties are additionally prefixed with the name of the base.
This should make it very easy to see where exactly a property came from.</p>

<p>There is a slight complication, though.
Recall the definition of a semiring in spire, which is given above.
A semiring actually consists of two different semigroups of which we must check the laws separately.
At this point, it is not immediately clear what would happen with the presented algorithm.
With just a minor clarification it turns out that this is not actually a problem:
The rule set of a semiring specifies two bases (one for the additive component and one for the multiplicative component), and we only need to make sure that they have different names.
Laws pulled in via different bases are considered different, and are hence not conflated.</p>

<h2 id="usage">Usage</h2>

<p>Previously, this new law checking infrastructure was tailored to be used just in Spire.
Since it is useful outside of Spire, too, it has recently been generalized and pulled out into a separate project: <a href="https://github.com/typelevel/discipline">Discipline</a>.</p>

<p>In there, you can find a stripped-down example of the Spire use case.</p>

<p>Furthermore, there is integration with Specs2 and ScalaTest.
You just have to extend the <code class="highlighter-rouge">specs2.Discipline</code> (or <code class="highlighter-rouge">scalatest.Discipline</code>, respectively) trait, and write</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">checkAll</span><span class="o">(</span><span class="s">"Int"</span><span class="o">,</span> <span class="nc">RingLaws</span><span class="o">[</span><span class="kt">Int</span><span class="o">].</span><span class="n">ring</span> <span class="cm">/* put your own `RuleSet` here */</span><span class="o">)</span>
</code></pre></div></div>

<p>and rule sets are expanded and turned into individual tests automatically.
For a Specs2-based tests, this will result in the following output (similar for ScalaTest):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[info] ring laws must hold for Int
[info]
[info]  + ring.additive:group.base:group.associative
[info]  + ring.additive:group.base:group.identity
[info]  + ring.additive:group.base:group.inverse
[info]  + ring.multiplicative:monoid.base:monoid.associative
[info]  + ring.multiplicative:monoid.base:monoid.identity
[info]  + ring.distributive
</code></pre></div></div>

<p>Observe that the associativity law for semigroups shows up twice (additive and multiplicative), but not four times (as would have happened with the naïve algorithm).</p>

<p>In the future, we will investigate whether Scalaz can also be migrated towards Discipline, for a more unified approach to law checking.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 17 Nov 2013 00:00:00 +0100</pubDate>
        <link>https://typelevel.org/blog/2013/11/17/discipline.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2013/11/17/discipline.html</guid>
      </item>
    
      <item>
        <title>Treelog</title>
        
          <dc:creator>channingwalton</dc:creator>
                
        <description><![CDATA[<p><a href="https://twitter.com/lancewalton">Lance Walton’s</a> <a href="https://github.com/lancewalton/treelog">Treelog</a> is the result of a real problem that arose in a trading system that we were working on:</p>
<blockquote>
  <p>How can everything that happens to a trade be audited?</p>
</blockquote>

<p>The first (and tedious) answer is copius logging by writing to some kind of audit data type or simple logger.</p>

<p>There are a number of problems with this approach:</p>

<ul>
  <li>writing logging around computations often complicates the code as values must be extracted, recorded and then applied</li>
  <li>separating logic from the computation can lead to a mismatch between the log and the computation</li>
  <li>linear logs are very difficult to follow</li>
  <li>its not easy to control how much of a linear log to show a user if you do not know what is detail and what isn’t</li>
</ul>

<p>Treelog resolves these issues by making the log itself a tree, reflecting the computational tree it logs, and uses techniques described in the <a href="http://www.haskell.org/wikiupload/e/e9/Typeclassopedia.pdf">Typeclassopedia</a> to bring logging closer to the computation: the <code class="highlighter-rouge">Writer</code> Monad, a Monad Transformer, and a cunning Monoid.</p>

<p>Note that this post is a more technical description of how Treelog was written. For a quick introduction of use please refer to the [README].
I will also refer you to Eugene Yokota’s <a href="http://eed3si9n.com/learning-scalaz/">excellent Scalaz tutorial</a> to study the details of Scalaz where appropriate.</p>

<h2 id="logging-with-treelog">Logging with Treelog</h2>
<p>Here is an example which illustrates how Treelog is used (<a href="https://github.com/lancewalton/treelog#treelog-examples">more examples</a>):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">simple</span><span class="k">:</span> <span class="kt">DescribedComputation</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> 
  <span class="s">"Calculating sum"</span> <span class="o">~&lt;</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="n">x</span> <span class="k">←</span> <span class="mi">11</span> <span class="o">~&gt;</span> <span class="o">(</span><span class="s">"x = "</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
      <span class="n">y</span> <span class="k">←</span> <span class="mi">2</span> <span class="o">~&gt;</span> <span class="o">(</span><span class="s">"y = "</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
      <span class="n">sum</span> <span class="k">←</span> <span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">)</span> <span class="o">~&gt;</span> <span class="o">(</span><span class="s">"Sum is "</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="n">sum</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">DescribedComputation[Value]</code> is just a type alias for <code class="highlighter-rouge">EitherT[LogTreeWriter, String, Value]</code>. <code class="highlighter-rouge">EitherT</code>, a <a href="http://eed3si9n.com/learning-scalaz/Monad+transformers.html">Monad Transformer</a>, enables success and failure to be represented and will be covered below.</p>

<p>The log and value can be retrieved with <code class="highlighter-rouge">result.run.written</code> and <code class="highlighter-rouge">result.run.value</code> respectively. The written tree will look like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Calculating sum
  x = 11
  y = 2
  Sum is 13
</code></pre></div></div>

<p>and the value will be <code class="highlighter-rouge">\/-(13)</code>, which is Scalaz’s version of <code class="highlighter-rouge">Right</code>.</p>

<h2 id="tree-nodes">Tree Nodes</h2>

<p>The nodes of the tree contain a <code class="highlighter-rouge">LogTreeLabel</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">LogTreeLabel</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">success</span><span class="k">:</span> <span class="kt">Boolean</span>
  <span class="k">def</span> <span class="n">annotations</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="c1">// ...
</span><span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">DescribedLogTreeLabel</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">description</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">success</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">annotations</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">LogTreeLabel</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">UndescribedLogTreeLabel</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">success</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">annotations</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">LogTreeLabel</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>The node is able to represent success or failure, may have a description, and a set of annotations. Annotations allow extra information to be carried in a Node which may be useful when working with the audit later. For our trading system that was other trades that were affected by the process as a side effect of processing a trade.</p>

<p>Treelog distinguishes between tree nodes that describe a computation, a <code class="highlighter-rouge">DescribedLogTreeLabel</code>, and an <code class="highlighter-rouge">UndescribedLogTreeLabel</code> which is a Tree with no description in the root. In the example above, the root node is a <code class="highlighter-rouge">DescribedLogTreeLabel</code> containing the text <code class="highlighter-rouge">Calculating sum</code>. This is an important distinction that informs the way trees must be combined by our Treelog monoid, which the <code class="highlighter-rouge">Writer</code> needs (see below).</p>

<p>Note that originally, <code class="highlighter-rouge">LogTreeLabel</code> was a case class defined like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">LogTreeLabel</span><span class="o">(</span><span class="n">description</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">success</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">annotations</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Annotation</span><span class="o">])</span>
</code></pre></div></div>

<p>This meant that <code class="highlighter-rouge">DescribedLogTreeLabel</code> and <code class="highlighter-rouge">UndescribedLogTreeLabel</code> were not necessary because the optional <code class="highlighter-rouge">description</code> carried the equivalent information. However, we found the formulation above easier to work with.</p>

<h2 id="syntactic-sugar">Syntactic Sugar</h2>

<p>Treelog makes use of some syntactic sugar inspired by <a href="http://blog.tmorris.net/posts/the-writer-monad-using-scala-example/">Tony Morris’s post</a> on <code class="highlighter-rouge">Writer</code>. In the example above, <code class="highlighter-rouge">~&gt;</code> is a method on an implicitly constructed class which takes any value <code class="highlighter-rouge">x: T</code> and returns a <code class="highlighter-rouge">DescribedComputation[T]</code>, representing the value <code class="highlighter-rouge">x</code> and a leaf node containing the description.</p>

<p>There is special support for <code class="highlighter-rouge">Boolean</code>s, <code class="highlighter-rouge">Option</code>s, <code class="highlighter-rouge">Either</code>s and <code class="highlighter-rouge">Traversable</code>s which you can learn about from the Treelog [README].</p>

<h2 id="writer-and-monoid"><code class="highlighter-rouge">Writer</code> and Monoid</h2>

<blockquote>
  <p>Writer allows us to do computations while making sure that all the log values are combined into one log value that then gets attached to the result. – <a href="http://learnyouahaskell.com/for-a-few-monads-more">LYAH</a></p>
</blockquote>

<p><code class="highlighter-rouge">Writer</code>s allow us to write a log embedded within a computation.</p>

<p>Here is a simple example using Scalaz, see the references for more detailed examples.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">r</span><span class="k">:</span> <span class="kt">Writer</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> 
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">←</span> <span class="mf">3.</span><span class="n">set</span><span class="o">(</span><span class="s">"Got a 3."</span><span class="o">)</span>
    <span class="n">b</span> <span class="k">←</span> <span class="mf">5.</span><span class="n">set</span><span class="o">(</span><span class="s">"Got a 5."</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>

<span class="n">println</span><span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="n">written</span><span class="o">)</span> <span class="c1">// Got a 3.Got a 5.
</span><span class="n">println</span><span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="n">value</span><span class="o">)</span> <span class="c1">// 15
</span></code></pre></div></div>

<p>The <code class="highlighter-rouge">Writer</code> uses a monoid for the written value (a <code class="highlighter-rouge">String</code> in this case) to combine the logs (concatenation for <code class="highlighter-rouge">String</code>s). For <code class="highlighter-rouge">List</code>s it is <code class="highlighter-rouge">:::</code> and <code class="highlighter-rouge">Nil</code>, etc.</p>

<h2 id="treelogs-monoid">Treelog’s Monoid</h2>

<p>Treelog uses a Scalaz <a href="http://eed3si9n.com/learning-scalaz/Writer.html">Writer</a>, <a href="http://eed3si9n.com/learning-scalaz/Tree.html">Tree</a> and a custom <a href="http://eed3si9n.com/learning-scalaz/Monoid.html">Monoid</a> implementation to record logs.</p>

<p>The monoid has to provide two things: a <code class="highlighter-rouge">zero</code> value, and a binary operation that combines two trees in a meaningful way. The <code class="highlighter-rouge">zero</code> value for Treelog is just a constant used internally to the `Monoid´ implementation and never leaks out since there is always at least one value being logged.</p>

<p>Combining trees is done as follows:</p>

<ul>
  <li>a <code class="highlighter-rouge">zero</code> tree with a tree is just the tree</li>
  <li>two undescribed trees become a new undescribed tree with the children of the right tree appended to the children of the left tree</li>
  <li>an undescribed tree <code class="highlighter-rouge">T1</code>, and a described tree, <code class="highlighter-rouge">T2</code>, becomes an undescribed tree with <em><code class="highlighter-rouge">T2</code> appended to the children of <code class="highlighter-rouge">T1</code></em></li>
  <li>a described tree, <code class="highlighter-rouge">T1</code>, and an undescribed tree, <code class="highlighter-rouge">T2</code>, is an undescribed tree with <em><code class="highlighter-rouge">T1</code> prepended to the children of <code class="highlighter-rouge">T2</code></em></li>
  <li>two described trees are combined by creating an undescribed tree with the two trees as children</li>
</ul>

<p>Note that the result is always an undescribed tree since there is no meaningful way to combine descriptions of child nodes. In the example above the tree contains two leaves: “Got a 3” and “Got a 5”. Concatenating those descriptions isn’t as meaningful as “Summing a and b”, which could be done like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">r</span><span class="k">:</span> <span class="kt">Writer</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> 
  <span class="s">"Summing a and b"</span> <span class="o">~&lt;</span> <span class="k">for</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">←</span> <span class="mf">3.</span><span class="n">set</span><span class="o">(</span><span class="s">"Got a 3."</span><span class="o">)</span>
    <span class="n">b</span> <span class="k">←</span> <span class="mf">5.</span><span class="n">set</span><span class="o">(</span><span class="s">"Got a 5."</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
</code></pre></div></div>

<p>The <a href="https://github.com/lancewalton/treelog/blob/5e36e0652b575d0102f45b1c284f68a02f148b04/src/test/scala/QuadraticRootsExample.scala">quadratic roots</a> example is a good one to see this.</p>

<h2 id="success-and-failure--eithert">Success and Failure – <code class="highlighter-rouge">EitherT</code></h2>

<p>The purpose of Treelog is to audit a computation, return the log and result, and indicate whether the computation was successful or not. The Writer with the Monoid described above satisfies the first two requirements, but not the third. To add success and failure, the writer needs to be combined with <code class="highlighter-rouge">Either</code>. What we need is a Monad Transformer.</p>

<blockquote>
  <p>Monad Transformers are special types that allow us to roll two monads into a single one that shares the behaviour of both. – <a href="http://en.wikibooks.org/wiki/Haskell/Monad_transformers">Haskell Wikibook</a></p>
</blockquote>

<p><code class="highlighter-rouge">EitherT</code> is a monad transformer that combines some monad with <code class="highlighter-rouge">Either</code>, which is exactly what is needed. It is constructed with three types: <code class="highlighter-rouge">EitherT[M, A, B]</code> where <code class="highlighter-rouge">M</code> is the monad, <code class="highlighter-rouge">A</code> is the failure type and <code class="highlighter-rouge">B</code> is the success type. In Treelog, <code class="highlighter-rouge">M</code> is a <code class="highlighter-rouge">Writer</code>, <code class="highlighter-rouge">A</code> is a <code class="highlighter-rouge">String</code> and <code class="highlighter-rouge">B</code> is the type of the result.</p>

<p>Logtree includes the methods <code class="highlighter-rouge">def failure[V](description: String): DescribedComputation[V]</code> and <code class="highlighter-rouge">def success[V](value: V, description: String): DescribedComputation[V]</code> to support failure and success. They ensure that the failure case is included in the tree and that the nodes in the tree now reflect that the computation has failed.</p>

<p>Here is an example from Treelog:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">foo</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">\/</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mf">11.</span><span class="n">right</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="k">val</span> <span class="n">bar</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">\/</span> <span class="kt">Int</span> <span class="o">=</span> <span class="s">"fubar"</span><span class="o">.</span><span class="n">left</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

<span class="k">val</span> <span class="n">leftEithers</span><span class="k">:</span> <span class="kt">DescribedComputation</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> 
  <span class="s">"Calculating left either sum"</span> <span class="o">~&lt;</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">{</span>
      <span class="n">x</span> <span class="k">←</span> <span class="n">foo</span> <span class="o">~&gt;?</span> <span class="o">(</span><span class="s">"x = "</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
      <span class="n">y</span> <span class="k">←</span> <span class="n">bar</span> <span class="o">~&gt;?</span> <span class="o">(</span><span class="s">"y = "</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
      <span class="n">sum</span> <span class="k">←</span> <span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">)</span> <span class="o">~&gt;</span> <span class="o">(</span><span class="n">v</span> <span class="k">⇒</span> <span class="s">"Sum is "</span> <span class="o">+</span> <span class="n">v</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="n">sum</span>
  <span class="o">}</span>

<span class="k">val</span> <span class="n">leftEitherWriter</span><span class="k">:</span> <span class="kt">LogTreeWriter</span><span class="o">[</span><span class="kt">String</span> <span class="kt">\/</span> <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">leftEithers</span><span class="o">.</span><span class="n">run</span>
<span class="n">println</span><span class="o">(</span><span class="n">leftEithers</span><span class="o">.</span><span class="n">run</span><span class="o">.</span><span class="n">written</span><span class="o">.</span><span class="n">shows</span><span class="o">)</span>
</code></pre></div></div>

<p>To retrieve the underying value back from <code class="highlighter-rouge">EitherT</code>, we call <code class="highlighter-rouge">run</code> which returns the <code class="highlighter-rouge">Writer</code> containing Scalaz’s version of <code class="highlighter-rouge">Either</code> (which is more useful than Scala’s built-in <code class="highlighter-rouge">Either</code>).</p>

<p>The written value is:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Failed: Calculating left either sum
  x = 11
  Failed: fubar

Failure: Calculating left either sum
</code></pre></div></div>

<p>So the written log indicates that the whole computation failed, and the result is <code class="highlighter-rouge">-\/</code>, the <code class="highlighter-rouge">Left</code> for a Scalaz <code class="highlighter-rouge">Either</code>, containing “Failure: Calculating left either sum”.</p>

<h2 id="in-practice">In Practice</h2>

<p>Treelog is being used in earnest in a trading system, and the results have been a resounding success. And the level of accurate detail the system is able to show users has been invaluable in reducing support questions, which is always welcome.</p>

<h2 id="further-reading">Further Reading</h2>

<ul>
  <li><a href="http://debasishg.blogspot.co.uk/2011/07/monad-transformers-in-scala.html">Monad Transformers in Scala</a></li>
  <li><a href="http://www.slideshare.net/StackMob/monad-transformers-in-the-wild">Monad Transformers in the Wild</a></li>
</ul>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Fri, 18 Oct 2013 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2013/10/18/treelog.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2013/10/18/treelog.html</guid>
      </item>
    
      <item>
        <title>Towards Scalaz (Part 1)</title>
        
          <dc:creator>adelbertc</dc:creator>
                
        <description><![CDATA[<p>A lot of people see Scalaz as a hard fringe, ivory tower,
not suited for real-world applications library, which is
unfortunate. The goal of this blog post series is to introduce
various components of Scalaz, and hopefully through this
allow folks to gain an understanding towards the power of
Scalaz.</p>

<p>As a prerequisite, I assume knowledge of type classes as they
are implemented and used in Scala.</p>

<h2 id="part-1-learning-to-add">Part 1: Learning to Add</h2>

<p>Our motivation for the inaugural post of the series will be
summing a <code class="highlighter-rouge">List</code> of something. Lets start out with <code class="highlighter-rouge">Int</code>,
which is simple enough.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">sum</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">reduce</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
</code></pre></div></div>

<p>And this works (kind of, it fails on empty <code class="highlighter-rouge">List</code>s but we’ll get to that).
But what if we want to sum a <code class="highlighter-rouge">List[Double]</code>?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">sumDoubles</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">])</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">reduce</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
</code></pre></div></div>

<p>The code is the same, modulo the type parameter. In fact, the
code would be the same whether it is <code class="highlighter-rouge">Int</code>, <code class="highlighter-rouge">Double</code>, or <code class="highlighter-rouge">BigInt</code>.
Being the good programmers that we are, let’s make this generic
in that respect with the help of <code class="highlighter-rouge">scala.math.Numeric</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">sumNumeric</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">l</span><span class="o">.</span><span class="n">reduce</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="n">plus</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="problem">Problem</h3>
<p>Awesome. We can now sum <code class="highlighter-rouge">List[Int]</code>, <code class="highlighter-rouge">List[Double]</code>, <code class="highlighter-rouge">List[BigInt]</code>,
and many more.</p>

<p>But let’s give this a bit more thought - what if we wanted to
“sum” a <code class="highlighter-rouge">List[String]</code> - that is, we concatenate all the <code class="highlighter-rouge">String</code>s
together to create one large <code class="highlighter-rouge">String</code> ?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">sumStrings</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">reduce</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
</code></pre></div></div>

<p>This looks exactly like summing <code class="highlighter-rouge">Int</code> and <code class="highlighter-rouge">Double</code>s! This however
does not work with our <code class="highlighter-rouge">sumNumeric</code> - there is no (sane) way to define
a <code class="highlighter-rouge">Numeric[String]</code>.</p>

<p>Another way to look at this is that we only use the <code class="highlighter-rouge">plus</code> method
on <code class="highlighter-rouge">Numeric</code>, never any of the other methods that also make sense
for numeric types. So while our function works for summing a List
of numeric types, it does not work for anything else that is not
numeric but can still be “added” (<code class="highlighter-rouge">String</code> and string concatenation,
<code class="highlighter-rouge">List[A]</code> and <code class="highlighter-rouge">List#++</code>).</p>

<h3 id="making-it-generic">Making it generic</h3>
<p>So what do we want? We want a type class that only requires instances
to be able to “add” two <code class="highlighter-rouge">A</code>s to get another <code class="highlighter-rouge">A</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Addable</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And let’s define an instance of <code class="highlighter-rouge">Addable</code> for all <code class="highlighter-rouge">Numeric</code> types and <code class="highlighter-rouge">String</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Addable</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">numericIsAddable</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Addable</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Addable</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
    <span class="o">}</span>

  <span class="k">implicit</span> <span class="k">val</span> <span class="n">stringIsAddable</span><span class="k">:</span> <span class="kt">Addable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Addable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And here’s our shiny new generic summer function!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">sumGeneric</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Addable</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">l</span><span class="o">.</span><span class="n">reduce</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="n">plus</span><span class="o">)</span>
</code></pre></div></div>

<p>And now this works for <code class="highlighter-rouge">Int</code>, <code class="highlighter-rouge">Double</code>, <code class="highlighter-rouge">String</code>, and many more.</p>

<p>A good exercise at this point is to define an <code class="highlighter-rouge">Addable</code> instance for <code class="highlighter-rouge">List[A]</code>.</p>

<h3 id="making-an-exception">Making an Exception</h3>
<p>What happens when we pass in an empty <code class="highlighter-rouge">List</code> to our summer function though?
We get an exception! How do we prevent this? A common answer I get is
“Oh I know it won’t happen” – this is not ideal, we want to guarantee safety
as much as possible without having to rely on human judgement.</p>

<p>How then do we write a safer summer function? Lets turn to an alternative
way of implementing sum on <code class="highlighter-rouge">List[Int]</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Old, bad version
</span><span class="k">def</span> <span class="n">sum</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">reduce</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>

<span class="c1">// Shiny, new version
</span><span class="k">def</span> <span class="n">sum</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
</code></pre></div></div>

<p>What happens now when we pass an empty <code class="highlighter-rouge">List</code> into the sum function? We get 0,
not an exception! Note that before all we gave the program was a binary
operation (what <code class="highlighter-rouge">Addable</code> defines), where now we give a binary option <em>and</em> a
“zero” or starting value (the 0). As it stands, we cannot write this with
<code class="highlighter-rouge">Addable</code> since it has no “zero”.</p>

<p>It may be tempting to just add a <code class="highlighter-rouge">zero</code> method to <code class="highlighter-rouge">Addable</code>, but then we may run
into the same issues we had with <code class="highlighter-rouge">Numeric</code> later on – we don’t <em>always</em> need
a “zero”, sometimes a binary operation is good enough. So instead, let’s create
an <code class="highlighter-rouge">AddableWithZero</code> type class.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">AddableWithZero</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Addable</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note that while you dont see the <code class="highlighter-rouge">plus</code> method in here, the fact
it <code class="highlighter-rouge">extends Addable</code> without implementing the <code class="highlighter-rouge">plus</code> method propagates the need to
implement that method, so programmers who want to create an <code class="highlighter-rouge">AddableWithZero[A]</code> instance
need to implement both.</p>

<p>Programmers can now write functions that depend only on <code class="highlighter-rouge">Addable</code>, or perhaps if they
need a bit more power use <code class="highlighter-rouge">AddableWithZero</code>. Types that have <code class="highlighter-rouge">AddableWithZero</code> instances
also have <code class="highlighter-rouge">Addable</code> instances automatically due to subtyping.</p>

<p>Lets move our <code class="highlighter-rouge">Addable</code> instances to the <code class="highlighter-rouge">AddableWithZero</code> object.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">AddableWithZero</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">numericIsAddableZero</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">AddableWithZero</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">AddableWithZero</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
      <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">zero</span>
    <span class="o">}</span>

  <span class="k">implicit</span> <span class="k">val</span> <span class="n">stringIsAddableZero</span><span class="k">:</span> <span class="kt">AddableWithZero</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">AddableWithZero</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
      <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And finally, our shiny new generic sum function!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">sumGeneric</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">AddableWithZero</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">l</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="n">zero</span><span class="o">)(</span><span class="n">A</span><span class="o">.</span><span class="n">plus</span><span class="o">)</span>
</code></pre></div></div>

<p>Hurrah!</p>

<h3 id="plot-twist">Plot Twist</h3>
<p>It turns out that our <code class="highlighter-rouge">Addable</code> and <code class="highlighter-rouge">AddableWithZero</code> type classes is not just us being
sly and clever, but an actual thing! They are called <code class="highlighter-rouge">Semigroup</code> and
<code class="highlighter-rouge">Monoid</code> (respectively), taken from the wonderful field of abstract algebra. Abstract
algebra is a field dedicated to studying algebraic structures as opposed
to just numbers as we may be used to. The field looks into what properties
and operations various structures have in common, such as integers and
matrices. For instance, we can add two integers, as well as two matrices of the same size.
This is analogous to how we noticed the <code class="highlighter-rouge">plus</code> worked on not only <code class="highlighter-rouge">Numeric</code>
but <code class="highlighter-rouge">String</code> and <code class="highlighter-rouge">List[A]</code> as well! This is the kind of generecity we’re looking for.</p>

<p>Here’s what <code class="highlighter-rouge">sumGeneric</code> looks like in Scalaz land.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz.Monoid</span>

<span class="k">def</span> <span class="n">sumGeneric</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">l</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="n">zero</span><span class="o">)((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div></div>

<p>Thankfully we dont have to create our own versions of <code class="highlighter-rouge">Semigroup</code> and <code class="highlighter-rouge">Monoid</code> –
Scalaz has one for us! In fact, the developers of Scalaz have been kind enough to define
several <code class="highlighter-rouge">Monoid</code> instances for common types such as <code class="highlighter-rouge">Numeric</code>, <code class="highlighter-rouge">String</code>, <code class="highlighter-rouge">List[A]</code>, etc.
There are also instances for tuples – if we have a tuple, say of type <code class="highlighter-rouge">(A, B, C)</code>,
and all three types have <code class="highlighter-rouge">Monoid</code> instances themselves, then the whole tuple has an
instance where the <code class="highlighter-rouge">zero</code> is the tuple <code class="highlighter-rouge">(A.zero, B.zero, C.zero)</code> and the <code class="highlighter-rouge">plus</code> is
appending corresponding pairs between the two tuples. Look for instances that may already
be defined before defining your own on existing types.</p>

<div class="side-note">
  If you are interested in learning more about numeric programming, check out
  the <a href="https://github.com/non/spire">spire</a> library, as well as the
  accompanying post about <a href="/blog/2013/07/07/generic-numeric-programming.html">
  generic numeric programming</a>.
</div>

<h3 id="law-abiding-citizen">Law-Abiding Citizen</h3>
<p>To close this post off, I confess one thing: defining a <code class="highlighter-rouge">Monoid</code> (and <code class="highlighter-rouge">Semigroup</code>) instance
should not be done without some thought. It is not enough that you simply have a zero and
a binary operation – to truly have a <code class="highlighter-rouge">Monoid</code> or <code class="highlighter-rouge">Semigroup</code> certain laws must be obeyed.
These laws are as follows:</p>

<p>Call the <code class="highlighter-rouge">plus</code> operation $+$ and the <code class="highlighter-rouge">zero</code> value $0$. Arbitrary values of type <code class="highlighter-rouge">A</code> will be
referred to as $a$, $b$, etc.</p>

<p>The <code class="highlighter-rouge">Semigroup</code> law requires $+$ to be associative. That is:</p>

<div style="text-align:center;">
	$(a + b) + c = a + (b + c)$
</div>

<p>In addition to the <code class="highlighter-rouge">Semigroup</code> law for the binary operation, the <code class="highlighter-rouge">Monoid</code> law relates
$+$ and $0$:</p>

<div style="text-align:center;">
  $(a + 0) = (0 + a) = a$
</div>

<p>To check these laws, Scalaz provides <a href="https://github.com/scalaz/scalaz/tree/v7.0.4/scalacheck-binding">ScalaCheck</a>
bindings to help you, but that is a topic for another day.</p>

<p>Note that a particular type can have several <code class="highlighter-rouge">Semigroup</code> or <code class="highlighter-rouge">Monoid</code>s that make sense.
For instance, <code class="highlighter-rouge">Int</code> has a <code class="highlighter-rouge">Monoid</code> on $(+, 0)$ as well as on $(*, 1)$. Convince yourself
(using the above laws) that this makes sense.</p>

<p>This raises the question of how we get both $+$ and $*$ <code class="highlighter-rouge">Monoid</code>s for <code class="highlighter-rouge">Int</code> without
making <code class="highlighter-rouge">scalac</code> freak out about ambiguous implicit values. The answer is “tagged types”,
again a topic for another day.</p>

<h2 id="getting-help">Getting Help</h2>

<p>If you have any questions/comments/concerns, feel free to hop onto the IRC channel on
Freenode at <code class="highlighter-rouge">#scalaz</code>.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 13 Oct 2013 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2013/10/13/towards-scalaz-1.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2013/10/13/towards-scalaz-1.html</guid>
      </item>
    
      <item>
        <title>How to use Spire's Ops macros in your own project</title>
        
          <dc:creator>non</dc:creator>
                
        <description><![CDATA[<h2 id="what-are-spires-ops-macros">What are Spire’s Ops macros?</h2>

<p>Spire’s type classes abstract over very basic operators like <code class="highlighter-rouge">+</code> and
<code class="highlighter-rouge">*</code>.  These operations are normally very fast. This means that any
extra work that happens on a per-operation basis (like boxing or
object allocation) will cause generic code to be slower than its
direct equivalent.</p>

<p>Efficient, generic numeric programming is Spire’s raison d’être. We
have developed a set of Ops macros to avoid unnecessary object
instantiations at compile-time. This post explains how, and
illustrates how you can use these macros in your code!</p>

<h2 id="how-implicit-operators-on-type-classes-usually-work">How implicit operators on type classes usually work</h2>

<p>When using type classes in Scala, we rely on implicit conversions to
“add” operators to an otherwise generic type.</p>

<p>In this example, <code class="highlighter-rouge">A</code> is the generic type, <code class="highlighter-rouge">Ordering</code> is the type
class, and <code class="highlighter-rouge">&gt;</code> is the implicit operator. <code class="highlighter-rouge">foo1</code> is the code that the
programmer writes, and <code class="highlighter-rouge">foo4</code> is a translation of that code after
implicits are resolved, and syntactic sugar is expanded.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.math.Ordering</span>
<span class="k">import</span> <span class="nn">Ordering.Implicits._</span>

<span class="k">def</span> <span class="n">foo1</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Ordering</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span>

<span class="k">def</span> <span class="n">foo2</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span>

<span class="k">def</span> <span class="n">foo3</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">infixOrderingOps</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="o">)(</span><span class="n">ev</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">y</span>

<span class="k">def</span> <span class="n">foo4</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="k">new</span> <span class="n">ev</span><span class="o">.</span><span class="nc">Ops</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">y</span>
</code></pre></div></div>

<p>(This is actually slightly wrong. The expansion to <code class="highlighter-rouge">foo4</code> won’t happen
until runtime, when <code class="highlighter-rouge">infixOrderingOps</code> is called. But it helps
illustrate the point.)</p>

<p>Notice that we instantiate an <code class="highlighter-rouge">ev.Ops</code> instance for every call to
<code class="highlighter-rouge">&gt;</code>. This is not a big deal in many cases, but for a call that is
normally quite fast it will add up when done many (e.g. millions) of
times.</p>

<p>It is possible to work around this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">bar</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">ev</span><span class="o">.</span><span class="n">gt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">ev</code> parameter contains the method we actually want (<code class="highlighter-rouge">gt</code>), so
instead of instantiating <code class="highlighter-rouge">ev.Ops</code> this code calls <code class="highlighter-rouge">ev.gt</code> directly.
But this approach is ugly. Compare these two methods:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">qux1</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Field</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="o">((</span><span class="n">x</span> <span class="n">pow</span> <span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="n">y</span> <span class="n">pow</span> <span class="mi">2</span><span class="o">)).</span><span class="n">sqrt</span>

<span class="k">def</span> <span class="n">qux2</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Field</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">ev</span><span class="o">.</span><span class="n">sqrt</span><span class="o">(</span><span class="n">ev</span><span class="o">.</span><span class="n">plus</span><span class="o">(</span><span class="n">ev</span><span class="o">.</span><span class="n">pow</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="n">ev</span><span class="o">.</span><span class="n">pow</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="mi">2</span><span class="o">)))</span>
</code></pre></div></div>

<p>If you have trouble reading <code class="highlighter-rouge">qux2</code>, you are not alone.</p>

<p>At this point, it looks like we can either write clean, readable code
(<code class="highlighter-rouge">qux1</code>), or code defensively to avoid object allocations (<code class="highlighter-rouge">qux2</code>).
Most programmers will just choose one or the other (probably the
former) and go on with their lives.</p>

<p>However, since this issue affects Spire deeply, we spent a bit more
time looking at this problem to see what could be done.</p>

<h2 id="having-our-cake-and-eating-it-too">Having our cake and eating it too</h2>

<p>Let’s look at another example, to compare how the “nice” and “fast”
code snippets look after implicits are resolved:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">niceBefore</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Ring</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">)</span> <span class="o">*</span> <span class="n">z</span>

<span class="k">def</span> <span class="n">niceAfter</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Ring</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="k">new</span> <span class="nc">RingOps</span><span class="o">(</span><span class="k">new</span> <span class="nc">RingOps</span><span class="o">(</span><span class="n">x</span><span class="o">)(</span><span class="n">ev</span><span class="o">).+(</span><span class="n">y</span><span class="o">))(</span><span class="n">ev</span><span class="o">).*(</span><span class="n">z</span><span class="o">)</span>

<span class="k">def</span> <span class="n">fast</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Ring</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">ev</span><span class="o">.</span><span class="n">times</span><span class="o">(</span><span class="n">ev</span><span class="o">.</span><span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">),</span> <span class="n">z</span><span class="o">)</span>
</code></pre></div></div>

<p>As we can see, <code class="highlighter-rouge">niceAfter</code> and <code class="highlighter-rouge">fast</code> are actually quite similar. If
we wanted to transform <code class="highlighter-rouge">niceAfter</code> into <code class="highlighter-rouge">fast</code>, we’d just have to:</p>

<ol>
  <li>
    <p>Figure out the appropriate name for symbolic operators. In this
example, <code class="highlighter-rouge">+</code> becomes <code class="highlighter-rouge">plus</code> and <code class="highlighter-rouge">*</code> becomes <code class="highlighter-rouge">times</code>.</p>
  </li>
  <li>
    <p>Rewrite the object instantiation and method call, calling the
method on <code class="highlighter-rouge">ev</code> instead and passing <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> as arguments. In
this example, <code class="highlighter-rouge">new Ops(x)(ev).foo(y)</code> becomes <code class="highlighter-rouge">ev.foo(x, y)</code>.</p>
  </li>
</ol>

<p>In a nutshell, this transformation is what Spire’s Ops macros do.</p>

<h2 id="using-the-ops-macros">Using the Ops macros</h2>

<p>Your project must use Scala 2.10+ to be able to use macros.</p>

<p>To use Spire’s Ops macros, you’ll need to depend on the <code class="highlighter-rouge">spire-macros</code>
package. If you use SBT, you can do this by adding the following line
to <code class="highlighter-rouge">build.sbt</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">"org.spire-math"</span> <span class="o">%%</span> <span class="s">"spire-macros"</span> <span class="o">%</span> <span class="s">"0.6.1"</span>
</code></pre></div></div>

<p>You will also need to enable macros at the declaration site of your
ops classes:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.language.experimental.macros</span>
</code></pre></div></div>

<h2 id="lets-see-an-example">Let’s see an example</h2>

<p>Consider <code class="highlighter-rouge">Sized</code>, a type class that abstracts over the notion of
having a size. Type class instances for <code class="highlighter-rouge">Char</code>, <code class="highlighter-rouge">Map</code>, and <code class="highlighter-rouge">List</code> are
provided in the companion object. Of course, users can also provide
their own instances.</p>

<p>Here’s the code:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Sized</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">size</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">def</span> <span class="n">isEmpty</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="n">nonEmpty</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">!</span><span class="n">isEmpty</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">sizeCompare</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="n">compare</span> <span class="n">size</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Sized</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">charSized</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Sized</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">size</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Char</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">toInt</span>
  <span class="o">}</span>

  <span class="k">implicit</span> <span class="k">def</span> <span class="n">mapSized</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Sized</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">size</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span>
  <span class="o">}</span>

  <span class="k">implicit</span> <span class="k">def</span> <span class="n">listSized</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Sized</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">size</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">length</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">isEmpty</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">isEmpty</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">sizeCompare</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">y</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">0</span>
      <span class="k">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">-</span><span class="mi">1</span>
      <span class="k">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">1</span>
      <span class="k">case</span> <span class="o">(</span><span class="k">_</span> <span class="o">::</span> <span class="n">xt</span><span class="o">,</span> <span class="k">_</span> <span class="o">::</span> <span class="n">yt</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">sizeCompare</span><span class="o">(</span><span class="n">xt</span><span class="o">,</span> <span class="n">yt</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>(Notice that <code class="highlighter-rouge">Sized[List[A]]</code> overrides some of the “default”
implementations to be more efficient, since taking the full length of
a list is an O(n) operation.)</p>

<p>We’d like to be able to call these methods directly on a generic type
<code class="highlighter-rouge">A</code> when we have an implicit instance of <code class="highlighter-rouge">Sized[A]</code> available. So
let’s define a <code class="highlighter-rouge">SizedOps</code> class, using Spire’s Ops macros:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">spire.macrosk.Ops</span>
<span class="k">import</span> <span class="nn">scala.language.experimental.macros</span>

<span class="k">object</span> <span class="nc">Implicits</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">SizedOps</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Sized</span><span class="o">](</span><span class="n">lhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">size</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">macro</span> <span class="nc">Ops</span><span class="o">.</span><span class="n">unop</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
    <span class="k">def</span> <span class="n">isEmpty</span><span class="o">()</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">macro</span> <span class="nc">Ops</span><span class="o">.</span><span class="n">unop</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>
    <span class="k">def</span> <span class="n">nonEmpty</span><span class="o">()</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">macro</span> <span class="nc">Ops</span><span class="o">.</span><span class="n">unop</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>
    <span class="k">def</span> <span class="n">sizeCompare</span><span class="o">(</span><span class="n">rhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">macro</span> <span class="nc">Ops</span><span class="o">.</span><span class="n">binop</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Int</span><span class="o">]</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>That’s it!</p>

<p>Here’s what it would look like to use this type class:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">Implicits._</span>

<span class="k">def</span> <span class="n">findSmallest</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Sized</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">as</span><span class="o">.</span><span class="n">reduceLeft</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">x</span> <span class="n">sizeCompare</span> <span class="n">y</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="n">compact</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Sized</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">as</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">nonEmpty</span><span class="o">)</span>

<span class="k">def</span> <span class="n">totalSize</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Sized</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="n">as</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">.</span><span class="n">size</span><span class="o">)</span>
</code></pre></div></div>

<p>Not bad, eh?</p>

<h2 id="the-fine-print">The fine print</h2>

<p>Of course, there’s always some fine-print.</p>

<p>In this case, the implicit class <strong>must</strong> use the same parameter names
as above. The constructor parameter to <code class="highlighter-rouge">SizedOps</code> <strong>must</strong> be called
<code class="highlighter-rouge">lhs</code> and the method parameter (if any) <strong>must</strong> be called
<code class="highlighter-rouge">rhs</code>. Also, unary operators (methods that take no parameters, like
<code class="highlighter-rouge">size</code>) <strong>must</strong> have parenthesis.</p>

<p>How the macros handle classes with multiple constructor parameters, or
multiple method parameters? They don’t. We haven’t needed to support
these kinds of exotic classes, but it would probably be easy to extend
Spire’s Ops macros to support other shapes as well.</p>

<p>If you fail to follow these rules, or if your class has the wrong
shape, your code will fail to compile. So don’t worry. If your code
compiles, it means you got it right!</p>

<h2 id="symbolic-names">Symbolic names</h2>

<p>The previous example illustrates rewriting method calls to avoid
allocations, but what about mapping symbolic operators to method
names?</p>

<p>Here’s an example showing the mapping from <code class="highlighter-rouge">*</code> to <code class="highlighter-rouge">times</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">CanMultiply</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">times</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Implicits</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">MultiplyOps</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">CanMultiply</span><span class="o">](</span><span class="n">lhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="o">*(</span><span class="n">rhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">macro</span> <span class="nc">Ops</span><span class="o">.</span><span class="n">binop</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">]</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Example</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">Implicits._</span>

  <span class="k">def</span> <span class="n">gak</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">CanMultiply</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
    <span class="n">as</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="n">a</span><span class="o">)(</span><span class="k">_</span> <span class="o">*</span> <span class="k">_</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Currently, the Ops macros have a large (but Spire-specific)
<a href="https://github.com/non/spire/blob/9eaa5c34549b7fe85c223f207f0790873075c048/macros/src/main/scala/spire/macros/Ops.scala#L143">mapping</a>
from symbols to names. However, your project may want to use different names
(or different symbols). What then?</p>

<p>For now, you are out of luck. In Spire 0.7.0, we plan to make it
possible to use your own mapping. This should make it easier for other
libraries that make heavy use of implicit symbolic operators
(e.g. Scalaz) to use these macros as well.</p>

<h2 id="other-considerations">Other considerations</h2>

<p>You might wonder how the Ops macros interact with
specialization. Fortunately, macros are expanded before the
specialization phase. This means you don’t need to worry about it! If
your type class is specialized, and you invoke the implicit from a
specialized (or non-generic) context, the result will be a specialized
call.</p>

<p>(Of course, using Scala’s specialization is tricky, and deserves its
own blog post. The good news is that type classes are some of the
easiest structures to specialize correctly in Scala.)</p>

<p>Evaluating the macros at compile-time also means that if there are
problems with the macro, you’ll find out about those at compile-time
as well. While we expect that many projects will benefit from the Ops
macros, they were designed specifically for Spire so it’s possible
that your project will discover problems, or need new features.</p>

<p>If you do end up using these macros,
<a href="https://groups.google.com/forum/#!forum/spire-math">let us know how</a>
they work for you. If you have problems, please open an
<a href="https://github.com/non/spire/issues">issue</a>, and if you have bug
fixes (or new features) feel free to open a
<a href="https://github.com/non/spire/pulls">pull request</a>!</p>

<h2 id="conclusion">Conclusion</h2>

<p>We are used to thinking about abstractions having a cost. So we often
end up doing mental accounting: “Is it worth making this generic? Can
I afford this syntactic sugar? What will the runtime impact of this
code be?” These condition us to expect that code can either be
beautiful or fast, but not both.</p>

<p>By removing the cost of implicit object instantiation, Spire’s Ops
macros raise the abstraction ceiling. They allow us to make free use
of type classes without compromising performance. Our goal is to close
the gap between direct and generic performance, and to encourage the
widest possible use of generic types and type classes in Scala.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 13 Oct 2013 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2013/10/13/spires-ops-macros.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2013/10/13/spires-ops-macros.html</guid>
      </item>
    
      <item>
        <title>Using scalaz.Unapply</title>
        
          <dc:creator>S11001001</dc:creator>
                
        <description><![CDATA[<p>Once you’ve started really taking advantage of Scalaz’s typeclasses
for generic programming, you might have noticed a need to write
typelambdas to use some of your neat abstractions, or use syntax like
<code class="highlighter-rouge">traverse</code> or <code class="highlighter-rouge">kleisli</code> with a strangely-shaped type as an argument.
Here’s a simple generalization, a <code class="highlighter-rouge">List</code>-based <code class="highlighter-rouge">traverse</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz.Applicative</span><span class="o">,</span> <span class="n">scalaz</span><span class="o">.</span><span class="n">syntax</span><span class="o">.</span><span class="n">applicative</span><span class="o">.</span><span class="k">_</span>

<span class="k">def</span> <span class="n">sequenceList</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span>, <span class="kt">A</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">xs</span><span class="o">.</span><span class="n">foldRight</span><span class="o">(</span><span class="nc">List</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">A</span><span class="o">].</span><span class="n">point</span><span class="o">[</span><span class="kt">F</span><span class="o">])((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">^(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)(</span><span class="k">_</span> <span class="o">::</span> <span class="k">_</span><span class="o">))</span>
</code></pre></div></div>

<p>This works fine for a while.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scalaz.std.option._</span>
<span class="k">import</span> <span class="nn">scalaz.std.option._</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">sequenceList</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">some</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span><span class="n">some</span><span class="o">(</span><span class="mi">2</span><span class="o">)))</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">sequenceList</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">some</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span><span class="n">none</span><span class="o">))</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">None</span>
</code></pre></div></div>

<h2 id="the-problem">The problem</h2>

<p>The type of the input in the above example, <code class="highlighter-rouge">List[Option[Int]]</code>, can be
neatly destructured into the <code class="highlighter-rouge">F</code> and <code class="highlighter-rouge">A</code> type params needed by
<code class="highlighter-rouge">sequenceList</code>.  It has the “shape” <code class="highlighter-rouge">F[x]</code>, so <code class="highlighter-rouge">F</code> can be picked out by
Scala easily.</p>

<p>Consider something else with a convenient <code class="highlighter-rouge">Applicative</code> instance,
though.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scalaz.</span><span class="o">\/</span>
<span class="k">import</span> <span class="nn">scalaz.$bslash$div</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">sequenceList</span><span class="o">(</span><span class="nc">List</span><span class="o">(\/.</span><span class="n">right</span><span class="o">(</span><span class="mi">42</span><span class="o">),</span> <span class="o">\/.</span><span class="n">left</span><span class="o">(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="s">"oops"</span><span class="o">))))</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">23</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">no</span> <span class="k">type</span> <span class="kt">parameters</span> <span class="kt">for</span> <span class="kt">method</span> 
  <span class="n">sequenceList</span><span class="k">:</span> <span class="o">(</span><span class="kt">xs:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]])(</span><span class="k">implicit</span> <span class="n">evidence$1</span><span class="k">:</span> <span class="kt">scalaz.Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="n">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
  <span class="n">exist</span> <span class="n">so</span> <span class="n">that</span> <span class="n">it</span> <span class="n">can</span> <span class="n">be</span> <span class="n">applied</span> <span class="n">to</span> <span class="n">arguments</span>
  <span class="o">(</span><span class="nc">List</span><span class="o">[</span><span class="kt">scalaz.\/</span><span class="o">[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>,<span class="kt">Int</span><span class="o">]])</span>
 <span class="o">---</span> <span class="n">because</span> <span class="o">---</span>
<span class="n">argument</span> <span class="n">expression</span><span class="ss">'s </span><span class="k">type</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">compatible</span> <span class="kt">with</span> <span class="kt">formal</span> <span class="kt">parameter</span> <span class="k">type</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">scalaz.\/</span><span class="o">[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>,<span class="kt">Int</span><span class="o">]]</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">?F</span><span class="o">]</span>

              <span class="n">sequenceList</span><span class="o">(</span><span class="nc">List</span><span class="o">(\/.</span><span class="n">right</span><span class="o">(</span><span class="mi">42</span><span class="o">),</span> <span class="o">\/.</span><span class="n">left</span><span class="o">(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="s">"oops"</span><span class="o">))))</span>
              <span class="o">^</span>
</code></pre></div></div>

<p>Here, <code class="highlighter-rouge">?F</code> meaning it couldn’t figure out that you meant <code class="highlighter-rouge">({type λ[α]
= NonEmptyList[String] \/ α})#λ</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">sequenceList</span><span class="o">[({</span><span class="k">type</span> <span class="kt">λ</span><span class="o">[</span><span class="kt">α</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="kt">\/</span> <span class="kt">α</span><span class="o">})</span><span class="k">#</span><span class="kt">λ</span>, <span class="kt">Int</span>
                  <span class="o">](</span><span class="nc">List</span><span class="o">(\/.</span><span class="n">right</span><span class="o">(</span><span class="mi">42</span><span class="o">),</span> <span class="o">\/.</span><span class="n">left</span><span class="o">(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="s">"oops"</span><span class="o">))))</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">scalaz.\/</span><span class="err">[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span><span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span><span class="err">]</span> <span class="k">=</span>
        <span class="o">-\/(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="n">oops</span><span class="o">))</span>
</code></pre></div></div>

<p>The problem is that <code class="highlighter-rouge">NonEmptyList[String] \/ Int</code> has the shape
<code class="highlighter-rouge">F[A, B]</code>, with <code class="highlighter-rouge">F</code> of kind <code class="highlighter-rouge">* -&gt; * -&gt; *</code> after a fashion, whereas the
<code class="highlighter-rouge">F</code> it wants must have kind <code class="highlighter-rouge">* -&gt; *</code>, and Scala kinds aren’t curried
at all.</p>

<h2 id="finding-an-unapply-instance">Finding an <code class="highlighter-rouge">Unapply</code> instance</h2>

<p><code class="highlighter-rouge">Unapply</code>, though, <em>does</em> have implicit instances matching the
<code class="highlighter-rouge">F[A, B]</code> shape, <code class="highlighter-rouge">unapplyMAB1</code> and <code class="highlighter-rouge">unapplyMAB2</code>, in its companion so
effectively always visible.  What’s special about them is that their
type parameters match the “shape” you’re working with, <code class="highlighter-rouge">F[A, B]</code>.</p>

<p>You should
<a href="https://github.com/scalaz/scalaz/blob/v7.0.3/core/src/main/scala/scalaz/Unapply.scala#L210">look at their source</a>
to follow along.</p>

<p>Let’s see if one of them works.  For implicit resolution to finish,
it’s important that <em>exactly</em> one of them works.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scalaz.Unapply</span>
<span class="k">import</span> <span class="nn">scalaz.Unapply</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Unapply</span><span class="o">.</span><span class="n">unapplyMAB1</span><span class="o">[</span><span class="kt">Applicative</span>, <span class="kt">\/</span>, <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">Int</span><span class="o">]</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">23</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">could</span> <span class="kt">not</span> <span class="kt">find</span> <span class="kt">implicit</span> <span class="kt">value</span> <span class="kt">for</span> <span class="kt">parameter</span>
<span class="nc">TC0</span><span class="k">:</span> <span class="kt">scalaz.Applicative</span><span class="o">[[</span><span class="kt">α</span><span class="o">]</span><span class="kt">scalaz.\/</span><span class="o">[</span><span class="kt">α</span>,<span class="kt">Int</span><span class="o">]]</span>
              <span class="nc">Unapply</span><span class="o">.</span><span class="n">unapplyMAB1</span><span class="o">[</span><span class="kt">Applicative</span>, <span class="kt">\/</span>, <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">Int</span><span class="o">]</span>
                                 <span class="o">^</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Unapply</span><span class="o">.</span><span class="n">unapplyMAB2</span><span class="o">[</span><span class="kt">Applicative</span>, <span class="kt">\/</span>, <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">Int</span><span class="o">]</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">scalaz.Unapply</span><span class="o">[</span><span class="kt">scalaz.Applicative</span>,
                     <span class="kt">scalaz.\/</span><span class="o">[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>,<span class="kt">Int</span><span class="o">]]{</span>
        <span class="k">type</span> <span class="kt">M</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="n">scalaz</span><span class="o">.\/[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>,<span class="kt">X</span><span class="o">];</span>
        <span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="nc">Int</span>
      <span class="o">}</span> <span class="k">=</span> <span class="n">scalaz</span><span class="o">.</span><span class="nc">Unapply_0$$anon$13</span><span class="k">@</span><span class="mi">5402</span><span class="n">af61</span>
</code></pre></div></div>

<p>Here, the type <code class="highlighter-rouge">res7.M</code> represents the typelambda being passed to
<code class="highlighter-rouge">sequenceList</code>.  You can see that work.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">sequenceList</span><span class="o">[</span><span class="kt">res7.M</span>, <span class="kt">res7.A</span><span class="o">](</span>
                   <span class="nc">List</span><span class="o">(\/.</span><span class="n">right</span><span class="o">(</span><span class="mi">42</span><span class="o">),</span> <span class="o">\/.</span><span class="n">left</span><span class="o">(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="s">"oops"</span><span class="o">))))</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">res7.M</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">res7.A</span><span class="o">]]</span> <span class="k">=</span> <span class="o">-\/(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="n">oops</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res8</span> <span class="k">:</span> <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">\/</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">scalaz.\/</span><span class="err">[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span><span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span><span class="err">]</span> <span class="k">=</span>
        <span class="o">-\/(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="n">oops</span><span class="o">))</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">res8</code> conformance test shows that Scala can still reduce the
path-dependent <code class="highlighter-rouge">res7.M</code> and <code class="highlighter-rouge">res7.A</code> types at this level, outside
<code class="highlighter-rouge">sequenceList</code>.</p>

<h2 id="searching-for-the-right-shape">Searching for the right shape</h2>

<p>Implicit resolution can pick the call to <code class="highlighter-rouge">unapplyMAB2</code> partly because
it can pick all of its type parameters without weird typelambda
structures.  But in Scalaz, we use typeclasses to guide its choice.</p>

<p>Why didn’t <code class="highlighter-rouge">unapplyMAB1</code> work?  In this case, you can trust <code class="highlighter-rouge">scalac</code>
to say exactly the right thing: it looked for
<code class="highlighter-rouge">Applicative[[α]scalaz.\/[α,Int]]</code>, and didn’t find one.  Sure enough,
<code class="highlighter-rouge">\/</code> being right-biased means we don’t offer that instance.</p>

<p>Incidentally, if you were to introduce that instance, you’d break code
relying on right-biased <code class="highlighter-rouge">Unapply</code> resolution to work.</p>

<p><code class="highlighter-rouge">unapplyMAB2</code> needs evidence of <code class="highlighter-rouge">TC[({type λ[α] = M0[A0, α]})#λ]</code>.
But that’s okay, because we have that, where <code class="highlighter-rouge">TC=Applicative</code>,
<code class="highlighter-rouge">M0=\/</code>, and <code class="highlighter-rouge">A0=NonEmptyList[String]</code>!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Applicative</span><span class="o">[({</span><span class="k">type</span> <span class="kt">λ</span><span class="o">[</span><span class="kt">α</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">\/</span><span class="o">[</span><span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">α</span><span class="o">]})</span><span class="k">#</span><span class="kt">λ</span><span class="o">]</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">scalaz.Applicative</span><span class="o">[[</span><span class="kt">α</span><span class="o">]</span><span class="kt">scalaz.\/</span><span class="o">[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>,<span class="kt">α</span><span class="o">]]</span>
         <span class="k">=</span> <span class="n">scalaz</span><span class="o">.</span><span class="nc">DisjunctionInstances2$$anon$1</span><span class="k">@</span><span class="mf">2f</span><span class="mi">658816</span>
</code></pre></div></div>

<p>Scala doesn’t need to figure out any typelambda itself for this to
work; we did everything by putting the typelambda right into
<code class="highlighter-rouge">unapplyMAB2</code>’s evidence requirement, so it just has to find the
conforming implicit value.</p>

<h2 id="using-unapply-generically">Using <code class="highlighter-rouge">Unapply</code> generically</h2>

<p>Now you can write a <code class="highlighter-rouge">sequenceList</code> wrapper that works for <code class="highlighter-rouge">\/</code> and
many other shapes, including user-provided shapes in the form of new
<code class="highlighter-rouge">Unapply</code> implicit instances.  If you’re using Scala 2.9 (still?!) you
need to add <code class="highlighter-rouge">-Ydependent-method-types</code> to <code class="highlighter-rouge">scalacOptions</code> to write
this function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">sequenceListU</span><span class="o">[</span><span class="kt">FA</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">FA</span><span class="o">])</span>
                     <span class="o">(</span><span class="k">implicit</span> <span class="n">U</span><span class="k">:</span> <span class="kt">Unapply</span><span class="o">[</span><span class="kt">Applicative</span>, <span class="kt">FA</span><span class="o">]</span>
                     <span class="o">)</span><span class="k">:</span> <span class="kt">U.M</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">U.A</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">sequenceList</span><span class="o">(</span><span class="n">U</span><span class="o">.</span><span class="n">leibniz</span><span class="o">.</span><span class="n">subst</span><span class="o">(</span><span class="n">xs</span><span class="o">))(</span><span class="n">U</span><span class="o">.</span><span class="nc">TC</span><span class="o">)</span>
</code></pre></div></div>

<p>Instead of <code class="highlighter-rouge">xs</code> being <code class="highlighter-rouge">List[F[A]]</code>, it’s <code class="highlighter-rouge">List[FA]</code>, and that’s
destructured into <code class="highlighter-rouge">U.M</code> and <code class="highlighter-rouge">U.A</code>.  The latter are path-dependent
types on <code class="highlighter-rouge">U</code>, the conventional name of the <code class="highlighter-rouge">Unapply</code> parameter.  We
have also followed the convention of naming the <code class="highlighter-rouge">Unapply</code>-taking
variant function ending with a <code class="highlighter-rouge">U</code>.</p>

<p>And that works great!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">sequenceListU</span><span class="o">(</span><span class="nc">List</span><span class="o">(\/.</span><span class="n">right</span><span class="o">(</span><span class="mi">42</span><span class="o">),</span> <span class="o">\/.</span><span class="n">left</span><span class="o">(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="s">"oops"</span><span class="o">))))</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">scalaz.\/</span><span class="err">[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span><span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span><span class="err">]</span> <span class="k">=</span>
   <span class="o">-\/(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="n">oops</span><span class="o">))</span>
</code></pre></div></div>

<p>Of course, there’s that strange-looking function body to consider,
still.</p>

<h2 id="using-the-u-evidence">Using the <code class="highlighter-rouge">U</code> evidence</h2>

<p>The type equalities of the original <code class="highlighter-rouge">U.M</code> and <code class="highlighter-rouge">U.A</code> to the original
types can be seen where <code class="highlighter-rouge">res8</code> is refined to <code class="highlighter-rouge">res9</code> above.  But only
the <em>caller</em> of the function knows those equalities, because it
produced and supplied the <code class="highlighter-rouge">unapplyMAB2</code> call, which has a structural
type containing those equalities.</p>

<p>The body of <code class="highlighter-rouge">sequenceListU</code> doesn’t know those things.  In particular,
it <em>still</em> can’t pick type parameters to pass to <code class="highlighter-rouge">sequenceList</code>
without a little help.</p>

<p>The <code class="highlighter-rouge">leibniz</code> member is a reified type equality of <code class="highlighter-rouge">FA === U.M[U.A]</code>,
meaning those are the same at the type level, even though Scala can’t
see it in this context.  It represents genuine evidence that those two
types are equal, and is much more powerful than scala-library’s own
<code class="highlighter-rouge">=:=</code>.  We’re using the core Leibniz operator, <code class="highlighter-rouge">subst</code>, directly to
prove that, <em>as a consequence of that type equality</em>, <code class="highlighter-rouge">List[FA] ===
List[U.M[U.A]]</code> is <em>also</em> a type equality, and that therefore this
[constant-time] coercion is valid.  This lifting is applicable in all
contexts, not just covariant ones like <code class="highlighter-rouge">List</code>’s.  Take a look at
<a href="https://github.com/scalaz/scalaz/blob/v7.0.3/core/src/main/scala/scalaz/Leibniz.scala">the full API</a>
for more, though you’ll typically just need to come up with the right
type parameter for <code class="highlighter-rouge">subst</code>.</p>

<p>You can’t ask for an <code class="highlighter-rouge">Unapply</code> and <em>also</em> ask for an
<code class="highlighter-rouge">Applicative[U.M]</code>; Scala won’t allow it.  So, because we needed to
resolve the typeclass anyway to find the <code class="highlighter-rouge">Unapply</code> implicit to use, we
just cart it along with the <code class="highlighter-rouge">U</code> and give it to the function, which
almost always needs to use it anyway.  Because it’s not implicitly
available, you usually need to grab it, <code class="highlighter-rouge">U.TC</code>, and use it directly.</p>

<h2 id="using-in-scalazsyntax">Using in <code class="highlighter-rouge">scalaz.syntax</code></h2>

<p><code class="highlighter-rouge">map</code> comes from functor syntax; it’s not a method on <code class="highlighter-rouge">Function1</code>.  So
how come this works?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; import scalaz.std.function._
import scalaz.std.function._

scala&gt; ((_:Int) + 42) map (_ * 33)
res13: Int =&gt; Int = &lt;function1&gt;

scala&gt; res13(1)
res14: Int = 1419
</code></pre></div></div>

<p>When you import syntax, as <code class="highlighter-rouge">Functor</code> syntax was imported with
<code class="highlighter-rouge">scalaz.syntax.applicative._</code> above, you get at least two conversions:
the plain one, like <code class="highlighter-rouge">ToFunctorOps[F[_],A]</code>, which works if you have
the right shape, and the fancy one, <code class="highlighter-rouge">ToFunctorOpsUnapply[FA]</code>, which
uses an <code class="highlighter-rouge">Unapply</code> to effectively invoke <code class="highlighter-rouge">ToFunctorOps</code> as in the
above.  The latter is lower-priority, so Scala will pick the former if
the value has the <code class="highlighter-rouge">F[A]</code> shape.</p>

<p>That gives access to all the methods in <code class="highlighter-rouge">FunctorOps</code>, and other ops
classes, with only one special <code class="highlighter-rouge">U</code>-taking method.  If you have several
functions operating on the same value type, or you can make that type
similar with Leibnizian equality as implicit arguments to your
methods, I suggest grouping them in this way, too, to cut down on
boilerplate.</p>

<h2 id="provide-both-anyway">Provide both anyway</h2>

<p>We sometimes get asked “why not just provide the <code class="highlighter-rouge">Unapply</code> version of
the function or ops?”</p>

<p>We do it, and suggest it for your own code, despite the confusion,
because it’s easier to work with real type equalities than with
Leibnizian equality, which you can do in your “real” function
implementation, and as seen in <code class="highlighter-rouge">res8</code> above, the path-dependent type
resolution can leave funny artifacts in the inferred result.  Here’s
an extreme example from
<a href="https://groups.google.com/d/msg/scalaz/9zAIGETrePI/o1rBsOcWJWAJ">an earlier demonstration</a>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">itt</span> <span class="k">=</span> <span class="nc">IdentityT</span> <span class="n">lift</span> <span class="n">it</span>
<span class="n">itt</span><span class="k">:</span> <span class="kt">IdentityT</span><span class="o">[</span><span class="kt">scalaz.Unapply</span><span class="o">[</span><span class="kt">scalaz.Monad</span>,<span class="kt">IdentityT</span><span class="o">[</span><span class="kt">scalaz.Unapply</span><span class="o">[</span><span class="kt">scalaz.Monad</span>,<span class="kt">Identity</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span>
                                                       <span class="o">{</span><span class="k">type</span> <span class="kt">M</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">Identity</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span><span class="err">;</span> <span class="k">type</span> <span class="kt">A</span> <span class="kt">=</span> <span class="kt">Int</span><span class="o">}</span><span class="k">#</span><span class="kt">M</span>,
                                                     <span class="kt">Int</span><span class="o">]]</span>
                 <span class="o">{</span><span class="k">type</span> <span class="kt">M</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">IdentityT</span><span class="o">[</span><span class="kt">scalaz.Unapply</span><span class="o">[</span><span class="kt">scalaz.Monad</span>,<span class="kt">Identity</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span>
                                          <span class="o">{</span><span class="k">type</span> <span class="kt">M</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">Identity</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span><span class="err">;</span> <span class="k">type</span> <span class="kt">A</span> <span class="kt">=</span> <span class="kt">Int</span><span class="o">}</span><span class="k">#</span><span class="kt">M</span>,
                                        <span class="kt">X</span><span class="o">]</span><span class="err">;</span>
                  <span class="k">type</span> <span class="kt">A</span> <span class="kt">=</span> <span class="kt">Int</span><span class="o">}</span><span class="k">#</span><span class="kt">M</span>,
               <span class="kt">Int</span><span class="o">]</span>
  <span class="k">=</span> <span class="nc">IdentityT</span><span class="o">(</span><span class="nc">IdentityT</span><span class="o">(</span><span class="nc">Identity</span><span class="o">(</span><span class="mi">42</span><span class="o">)))</span>
</code></pre></div></div>

<h2 id="credits">Credits</h2>

<p><a href="https://twitter.com/retronym">Jason Zaugg</a> implemented Scalaz
<code class="highlighter-rouge">Unapply</code>, based on
<a href="https://issues.scala-lang.org/browse/SI-2712?focusedCommentId=55239&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-55239">ideas</a>
from <a href="https://twitter.com/milessabin">Miles Sabin</a> and
<a href="https://github.com/pchiusano">Paul Chiusano</a>.</p>

<p>Leibnizian equality was implemented for Scalaz by
<a href="https://github.com/ekmett">Edward Kmett</a>.</p>

<p><a href="https://twitter.com/larsr_h">Lars Hupel</a>’s talk
(<a href="https://speakerdeck.com/larsrh/seven-at-one-blow-new-and-polished-features-in-scalaz-7">slides</a>,
<a href="https://www.youtube.com/watch?feature=player_embedded&amp;v=KzoqOVD7mvE">video</a>)
on the features in the then-upcoming Scalaz 7 at nescala 2013,
including <code class="highlighter-rouge">Unapply</code>, gave me the missing “guided by typeclasses”
detail, inspiring me to tell more people about the whole thing at the
conference, and then, much later, write it down here.</p>

<p><em>This article was tested with Scala 2.10.2 &amp; Scalaz 7.0.3.</em></p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Wed, 11 Sep 2013 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2013/09/11/using-scalaz-Unapply.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2013/09/11/using-scalaz-Unapply.html</guid>
      </item>
    
      <item>
        <title>An Intro to Generic Numeric Programming with Spire</title>
        
          <dc:creator>tixxit</dc:creator>
                
        <description><![CDATA[<p>In this post I’d like to introduce you to what I have been calling <em>generic
numeric programming</em>.</p>

<h2 id="what-is-generic-numeric-programming">What is Generic Numeric Programming?</h2>

<p>What do we mean by generic numeric programming? Let’s take a simple example; we
want to add 2 numbers together. However, we don’t want to restrict ourselves to
a particular type, like <code class="highlighter-rouge">Int</code> or <code class="highlighter-rouge">Double</code>, instead we just want to work with
some <em>generic</em> type <code class="highlighter-rouge">A</code> that can be added. For instance:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">add</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</code></pre></div></div>

<p>Of course, this won’t compile since <code class="highlighter-rouge">A</code> has no method <code class="highlighter-rouge">+</code>. What we are really
saying is that we want <code class="highlighter-rouge">A</code> to be some type that <em>behaves like a number</em>. The
usual OO way to achieve this is by creating an interface that defines our
desired behaviour. This is less than ideal, but if we were to go this route,
our <code class="highlighter-rouge">add</code> function might look like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Addable</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> <span class="n">self</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span>
  <span class="k">def</span> <span class="o">+(</span><span class="n">that</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">add</span><span class="o">[</span><span class="kt">A</span> <span class="k">&lt;:</span> <span class="kt">Addable</span><span class="o">[</span><span class="kt">A</span><span class="o">]](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</code></pre></div></div>

<p>We’ve created an interface that defines our <code class="highlighter-rouge">+</code> method, and then bound our type
parameter <code class="highlighter-rouge">A</code> to subsume this interface. The main problem with this is that we
can’t directly use types out of our control, like those that come in the
standard library (ie. <code class="highlighter-rouge">Int</code>, <code class="highlighter-rouge">Long</code>, <code class="highlighter-rouge">Double</code>, <code class="highlighter-rouge">BigInt</code>, etc). The only option
would be to wrap these types, which means extra allocations and either explicit
or implicit conversions, neither of which are good options.</p>

<p>A better approach is to use type classes. A discussion on type classes is out
of the scope of this post, but they let us express that the type <code class="highlighter-rouge">A</code> must have
some desired behaviour, without inheritence. Using the type class pattern, we
could write something like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Addable</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// Both arguments must be provided. Addable works with the type A, but
</span>  <span class="c1">// does not extend it.
</span>  <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>

<span class="c1">// This class adds the + operator to any type A that is Addable,
// by delegating to that Addable's `plus` method.
</span><span class="k">implicit</span> <span class="k">class</span> <span class="nc">AddableOps</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">lhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Addable</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="o">+(</span><span class="n">rhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="n">plus</span><span class="o">(</span><span class="n">lhs</span><span class="o">,</span> <span class="n">rhs</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// We use a context bound to require that A has an Addable instance.
</span><span class="k">def</span> <span class="n">add</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Addable</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</code></pre></div></div>

<p>We can then easily add implementations for any numeric type, regardless if we
control it or not, or even if it is a primitive type:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">object</span> <span class="nc">IntIsAddable</span> <span class="k">extends</span> <span class="nc">Addable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="o">}</span>

<span class="n">add</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>

<p>This is, more or less, the approach Spire takes.</p>

<h2 id="why-be-generic">Why be Generic?</h2>

<p>Why be generic? The flippant answer I could give is: why not? I do hope that
after reading this, that is an acceptable answer to you, but I know that’s not
what you came here for.</p>

<p>The first reason is the obvious one; sometimes you want to run the same
algorithm, but with different number types. Euclid’s GCD algorithm is the same
whether you are using <code class="highlighter-rouge">Byte</code>, <code class="highlighter-rouge">Short</code>, <code class="highlighter-rouge">Int</code>, <code class="highlighter-rouge">Long</code>, or <code class="highlighter-rouge">BigInt</code>. Why implement
it only for 1, when you could do it for all 5? Worse; why implement it 5
times, when you need only implement it once?</p>

<p>Another reason is that you want to push certain trade-offs, such as speed vs
precision to the user of your library, rather than making the decision for
them. <code class="highlighter-rouge">Double</code> is fast, but has a fixed precision. <code class="highlighter-rouge">BigDecimal</code> is slow, but
can have much higher precision. Which one do you use? When in doubt, let
someone else figure it out!</p>

<p>A last great reason is that it let’s you write less tests and can make
testing much less hairy.</p>

<h3 id="one-algorithm-many-types">One Algorithm, Many Types</h3>

<p>So, what does a generic version of Euclid’s GCD algorithm look like? Spire
strives to make generic numeric code look more or less like what you’d write
for a direct implementation. So, let’s let you compare; first up, the direct
implementation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">euclidGcd</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span>
  <span class="k">else</span> <span class="n">euclidGcd</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="o">%</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div></div>

<p>With Spire, we can use the <code class="highlighter-rouge">spire.math.Integral</code> type class to rewrite this as:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">spire.math.Integral</span>
<span class="k">import</span> <span class="nn">spire.implicits._</span>

<span class="k">def</span> <span class="n">euclidGcd</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Integral</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span>
  <span class="k">else</span> <span class="n">euclidGcd</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="o">%</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div></div>

<p>The 2 methods are almost identical, save the <code class="highlighter-rouge">Integral</code> context bound.
<code class="highlighter-rouge">Integral</code> gives us many methods we expect integers to have, like addition,
multiplication, and euclidean division (quotient + remainder).</p>

<p>Because Spire provides default implicit instances of <code class="highlighter-rouge">Integral</code> for all of the
integral types that come in the Scala standard library, we can immediately use
<code class="highlighter-rouge">euclidGcd</code> to find the GCD of many integer types:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">euclidGcd</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="mi">96</span><span class="o">)</span>
<span class="n">euclidGcd</span><span class="o">(</span><span class="mi">42L</span><span class="o">,</span> <span class="mi">96L</span><span class="o">)</span>
<span class="n">euclidGcd</span><span class="o">(</span><span class="nc">BigInt</span><span class="o">(</span><span class="mi">42</span><span class="o">),</span> <span class="nc">BigInt</span><span class="o">(</span><span class="mi">96</span><span class="o">))</span>
</code></pre></div></div>

<p>This is much better than writing 5 different versions of the same algorithm!
With Spire, you can actually do away with <code class="highlighter-rouge">euclidGcd</code> altogether, as <code class="highlighter-rouge">gcd</code>
comes with <code class="highlighter-rouge">Integral</code> anyways:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">spire</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">gcd</span><span class="o">(</span><span class="nc">BigInt</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nc">BigInt</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
</code></pre></div></div>

<h3 id="performance-vs-precision">Performance vs Precision</h3>

<p>Another benefit of generic numeric programming, is that you can push the choice
of numeric type off to someone else. Rather than hardcode a method or data
structure using <code class="highlighter-rouge">Double</code>, you can simple require some <code class="highlighter-rouge">Fractional</code> type.</p>

<p>I actually first found a need for generic numeric programming after I had
implemented a swath of algorithms with double precision floating point
arithmetic, only to find out that the minor precision errors were causing
serious correctness issues. The obvious fix was to just to use an exact type,
like <code class="highlighter-rouge">spire.math.Rational</code>, which would’ve worked for many of my purposes.
However, many of the algorithms actually worked fine with doubles or even
integers, where as others required exact n-roots (provided by a number type
like <code class="highlighter-rouge">spire.math.Real</code>). Being more precise meant everything got slower, even
when it didn’t need to be. Being less precise meant some algorithms would
occasionally return wrong answers. Abstracting out the actual number type
used meant I didn’t have to worry about these issues. I could make the choice
later, when I knew a bit more about my data, performance and precision
requirements.</p>

<p>We can illustrate this using a simple algorithm to compute the mean of some
numbers.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">spire.math._</span>
<span class="k">import</span> <span class="nn">spire.implicits._</span>

<span class="c1">// Note: It is generally better to use an incremental mean.
</span><span class="k">def</span> <span class="n">mean</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Fractional</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">A*</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">reduceLeft</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span> <span class="o">/</span> <span class="n">xs</span><span class="o">.</span><span class="n">size</span>
</code></pre></div></div>

<p>Here, we don’t care what type <code class="highlighter-rouge">A</code> is, as long as it can be summed and divided. 
If we’re working with approximate measurements, perhaps finding the mean of a
list of <code class="highlighter-rouge">Double</code>s is good enough:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mean</span><span class="o">(</span><span class="mf">0.5</span><span class="o">,</span> <span class="mf">1.5</span><span class="o">,</span> <span class="mf">0.0</span><span class="o">)</span> 
<span class="c1">// = 0.6666666666666666
</span></code></pre></div></div>

<p>Or perhaps we’d like an exact answer back instead:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">spire.math.Rational</span>

<span class="n">mean</span><span class="o">(</span><span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
<span class="c1">// = Rational(2, 3)
</span></code></pre></div></div>

<p>The main thing here is that as a user of the <code class="highlighter-rouge">mean</code> function, I get to choose
whether I’d prefer the speed of <code class="highlighter-rouge">Double</code> or the precision or <code class="highlighter-rouge">Rational</code>. The
algorithm itself looks no different, so why not give the user the choice?</p>

<h3 id="better-testing">Better Testing</h3>

<p>One of the best things is that if you write test code that abstracts over the
number type, then you can re-use your tests for many different types. Spire
makes great use of this, to ensure instances of our type classes obey the rules
of algebra and that the number types in Spire (Rational, Complex, UInt, etc)
are fundamentally correct.</p>

<p>There is another benefit though – you can ignore the subtleties of floating
point arithmetic in your tests if you want! If your code works with any number
type, then you can test with an exact type such as <code class="highlighter-rouge">spire.math.Rational</code> or
<code class="highlighter-rouge">spire.math.Real</code>. No more epsilons and NaNs. You shouldn’t let this excuse you
from writing numerically stable code, but it may save you many false negatives
in your build system, while also making you more confident that the fundamentals
are correct.</p>

<p>This is a big topic, deserving of its own blog post (you know who you are), so
I’ll leave this here.</p>

<h2 id="what-abstractions-exist">What Abstractions Exist?</h2>

<p>We’ve already seen <code class="highlighter-rouge">Integral</code>, which can be used wherever you need something
that acts like an integer. We also saw the modulus operator, <code class="highlighter-rouge">x % y</code>, but not
integer division. Spire differentiates between <em>integer division</em> and <em>exact
division</em>. You perform integer division with <code class="highlighter-rouge">x /~ y</code>. To see it in action,
let’s use an overly complicated function to negate an integer:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">spire.math._</span>
<span class="k">import</span> <span class="nn">spire.implicits._</span>

<span class="k">def</span> <span class="n">negate</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Integral</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="o">-(</span><span class="mi">42</span> <span class="o">*</span> <span class="o">(</span><span class="n">x</span> <span class="o">/~</span> <span class="mi">42</span><span class="o">)</span> <span class="o">+</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">42</span><span class="o">)</span>
</code></pre></div></div>

<p>Instances of <code class="highlighter-rouge">Integral</code> exist for <code class="highlighter-rouge">Byte</code>, <code class="highlighter-rouge">Short</code>, <code class="highlighter-rouge">Int</code>, <code class="highlighter-rouge">Long</code> and <code class="highlighter-rouge">BigInt</code>.</p>

<p>Another type class Spire provides is <code class="highlighter-rouge">Fractional[A]</code>, which is used for things
that have “exact” division. “Exact” is in quotes, since <code class="highlighter-rouge">Double</code> or
<code class="highlighter-rouge">BigDecimal</code> division isn’t really exact, but it’s close enough that we give 
them a pass. <code class="highlighter-rouge">Fractional</code> also provides <code class="highlighter-rouge">x.sqrt</code> and <code class="highlighter-rouge">x nroot k</code> for taking the
roots of a number.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">distance</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Fractional</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">y</span> <span class="o">**</span> <span class="mi">2</span><span class="o">).</span><span class="n">sqrt</span>
</code></pre></div></div>

<p>Note that <code class="highlighter-rouge">Fractional[A] &lt;: Integral[A]</code>, so anything you can do with
<code class="highlighter-rouge">Integral</code>, you can do with <code class="highlighter-rouge">Fractional[A]</code> too. Here, we can use <code class="highlighter-rouge">distance</code>
to calculate the length of the hypotenuse with <code class="highlighter-rouge">Double</code>s, <code class="highlighter-rouge">Float</code>s,
<code class="highlighter-rouge">BigDecimal</code>s, or some of Spire’s number types like <code class="highlighter-rouge">Real</code> or <code class="highlighter-rouge">Rational</code>.</p>

<p>Lastly, you often have cases where you just don’t care if <code class="highlighter-rouge">/</code> means exact or
integer division, or whether you are taking the square root of an <code class="highlighter-rouge">Int</code> or a
<code class="highlighter-rouge">Double</code>. For this kind of catch-all work Spire provides <code class="highlighter-rouge">Numeric[A]</code>.</p>

<h2 id="why-spire">Why Spire?</h2>

<p>If you’ve already hit the types of problems solved by generic numeric
programming, then you may have seen that <code class="highlighter-rouge">scala.math</code> also provides <code class="highlighter-rouge">Numeric</code>,
<code class="highlighter-rouge">Integral</code>, and <code class="highlighter-rouge">Fractional</code>, so why use Spire? Well, we originally created
Spire largely due to the problems with the type classes as they exist in Scala.</p>

<p>To start, Scala’s versions aren’t specialized, so they only worked with boxed
versions of primitive types. The operators in Scala also required boxing, which
means you need to trade-off performance for readability. They also aren’t very
useful for a lot of numeric programming; what about nroots, trig functions,
unsigned types, etc?</p>

<p>Spire also provides many more useful (and specialized) type classes. Some are
ones you’d expect, like <code class="highlighter-rouge">Eq</code> and <code class="highlighter-rouge">Order</code>, while others define more basic
algebras than <code class="highlighter-rouge">Numeric</code> and friends, like <code class="highlighter-rouge">Ring</code>, <code class="highlighter-rouge">Semigroup</code>, <code class="highlighter-rouge">VectorSpace</code>,
etc.</p>

<p>There are many useful number types that are missing from Scala in Spire, such
as <code class="highlighter-rouge">Rational</code>, <code class="highlighter-rouge">Complex</code>, <code class="highlighter-rouge">UInt</code>, etc.</p>

<p>Spire was written by people who actually use it. I somewhat feel like Scala’s
Numeric and friends weren’t really used much after they were created, other
than for Scala’s NumericRange support (ie. <code class="highlighter-rouge">1.2 to 2.4 by 0.1</code>). They miss
many little creature comforts whose need becomes apparent after using Scala’s
type classes for a bit.</p>

<h3 id="spire-is-fast">Spire is Fast</h3>

<p>One of Spire’s goals is that the performance of generic code shouldn’t suffer.
Ideally, the generic code should be as fast as the direct implementation. Using
the GCD implementation above as an example, we can compare Spire vs. Scala vs.
a direct implementation. I’ve put the
<a href="https://gist.github.com/tixxit/5695365">benchmarking code up as a Gist</a>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcdDirect:        29.981   1.00 x gcdDirect
gcdSpire:         30.094   1.00 x gcdDirect
gcdSpireNonSpec:  36.903   1.23 x gcdDirect
gcdScala:         38.989   1.30 x gcdDirect
</code></pre></div></div>

<p>For another example, we can look at the code to
<a href="https://gist.github.com/tixxit/5695365">find the mean of an array</a>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>meanDirect:        10.592   **1.00 x gcdDirect**
meanSpire:         10.638   **1.00 x gcdDirect**
meanSpireNonSpec:  13.434   **1.26 x gcdDirect** 
meanScala:         19.388   **1.83 x gcdDirect**
</code></pre></div></div>

<p>Spire achieves these goals fairly simply. All our type classes are
<code class="highlighter-rouge">@specialized</code>, so when using primitives types you can avoid boxing. We then use macros to remove
the boxing normally required for the operators by the implicit conversions.</p>

<p>Using <code class="highlighter-rouge">@specialized</code>, both <code class="highlighter-rouge">gcdSpire</code> and <code class="highlighter-rouge">meanSpire</code> aren’t noticably slower
than the direct implementation. We can see the slow down caused by dropping
<code class="highlighter-rouge">@specialized</code> in <code class="highlighter-rouge">gcdSpireNonSpec</code> and <code class="highlighter-rouge">meanSpireNonSpec</code>. The difference
between <code class="highlighter-rouge">gcdSpireNonSpec</code> and <code class="highlighter-rouge">gcdScala</code> is because Spire doesn’t allocate an
object for the <code class="highlighter-rouge">%</code> operator (using macros to remove the allocation). The
difference is even more pronounced between <code class="highlighter-rouge">meanSpireNonSpec</code> and <code class="highlighter-rouge">meanScala</code>.</p>

<h3 id="more-than-just-numeric-integral-and-fractional">More than just <code class="highlighter-rouge">Numeric</code>, <code class="highlighter-rouge">Integral</code>, and <code class="highlighter-rouge">Fractional</code></h3>

<p>The 3 type classes highlighted in this post are just the tip of the iceberg.
Spire provides a whole slew of type classes in <code class="highlighter-rouge">spire.algebra</code>. This package
contains type classes representing a wide variety of algebraic structures,
such as <code class="highlighter-rouge">Monoid</code>, <code class="highlighter-rouge">Group</code>, <code class="highlighter-rouge">Ring</code>, <code class="highlighter-rouge">Field</code>, <code class="highlighter-rouge">VectorSpace</code>, and more. The 3 type
classes discussed above provide a good starting point, but if you use Spire in
your project, you will probably find yourself using <code class="highlighter-rouge">spire.algebra</code> more and
more often. If you’d like to learn more, you can <a href="http://www.youtube.com/watch?v=xO9AoZNSOH4">watch my talk on abstract
algebra in Scala</a>.</p>

<p>As an example of using the algebra package, <code class="highlighter-rouge">spire.math.Integral</code> is simply
defined as:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">spire.algebra.</span><span class="o">{</span> <span class="nc">EuclideanRing</span><span class="o">,</span> <span class="nc">IsReal</span> <span class="o">}</span>

<span class="k">trait</span> <span class="nc">Integral</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">EuclideanRing</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
                     <span class="k">with</span> <span class="nc">IsReal</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="c1">// Includes Order[A] with Signed[A].
</span>                     <span class="k">with</span> <span class="nc">ConvertableFrom</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
                     <span class="k">with</span> <span class="nc">ConvertableTo</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>Whereas <code class="highlighter-rouge">spire.math.Fractional</code> is just:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">spire.algebra.</span><span class="o">{</span> <span class="nc">Field</span><span class="o">,</span> <span class="nc">NRoot</span> <span class="o">}</span>

<span class="k">trait</span> <span class="nc">Fractional</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Integral</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">with</span> <span class="nc">Field</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">with</span> <span class="nc">NRoot</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<h3 id="many-new-number-types">Many New Number Types</h3>

<p>Spire also adds many new useful number types. Here’s an incomplete list:</p>

<ul>
  <li><strong>spire.math.Rational</strong> is a fast, exact number type for working with
rational numbers,</li>
  <li><strong>spire.math.Complex[A]</strong> is a parametric number type for complex numbers,</li>
  <li><strong>spire.math.Number</strong> is a boxed number type that strives for flexibility
of use,</li>
  <li><strong>spire.math.Interval</strong> is a number type for interval arithmetic,</li>
  <li><strong>spire.math.Real</strong> is a number type for exact geometric computation that
provides exact n-roots, as well as exact division,</li>
  <li><strong>spire.math.{UByte,UShort,UInt,ULong}</strong> unsigned integer types, and</li>
  <li><strong>spire.math.Natural</strong> an arbitrary precision unsigned integer type.</li>
</ul>

<h3 id="better-readability">Better Readability</h3>

<p>Spire also provides better operator integration with <code class="highlighter-rouge">Int</code> and <code class="highlighter-rouge">Double</code>. For
instance, <code class="highlighter-rouge">2 * x</code> or <code class="highlighter-rouge">x * 2</code> will just work for any <code class="highlighter-rouge">x</code> whose type has an
<code class="highlighter-rouge">Ring</code>. On the other hand, Scala requires something like
<code class="highlighter-rouge">implicitly[Numeric[A]].fromInt(2) * x</code> which is much less readable. This
also goes for working with fractions; <code class="highlighter-rouge">x * 0.5</code> will just work, if <code class="highlighter-rouge">x</code> has a
<code class="highlighter-rouge">Field</code>.</p>

<h2 id="try-it-out">Try It Out!</h2>

<p>Spire has a basic algebra that let’s us work generically with numeric types. It
does this without sacrificing readability or performance. It also provides many
more useful abstractions and concrete number types. This means you can write
less code, write less tests, and worry less about concerns like performance vs.
precision. If this appeals to you, then you should try it out!</p>

<p>There is some basic information on getting up-and-running with Spire in SBT on
<a href="https://github.com/non/spire">Spire’s project page</a>. If you have any further
questions, comments, suggestions, criticism or witticisms you can say what you
want to say on the <a href="https://groups.google.com/forum/#!forum/spire-math">Spire mailing list</a>
or on IRC on Freenode in <code class="highlighter-rouge">#spire-math</code>.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Sun, 07 Jul 2013 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2013/07/07/generic-numeric-programming.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2013/07/07/generic-numeric-programming.html</guid>
      </item>
    
      <item>
        <title>Deriving Type Class Instances</title>
        
          <dc:creator>larsrh</dc:creator>
                
        <description><![CDATA[<h2 id="motivating-example">Motivating example</h2>

<p>Assume that you have a <code class="highlighter-rouge">case class</code> representing vectors in three-dimensional space:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Vector3D</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">z</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</code></pre></div></div>

<p>Now you want to implement addition on this class.
Currently, you have to do that manually:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="o">+(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Vector3D</span><span class="o">)</span><span class="k">:</span> <span class="kt">Vector3D</span> <span class="o">=</span>
  <span class="nc">Vector3D</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">x</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">y</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">z</span><span class="o">)</span>
</code></pre></div></div>

<p>If you are writing some code involving three-dimensional vectors, chances are that you also have to deal with two-dimensional ones:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Vector2D</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="o">+(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Vector2D</span><span class="o">)</span><span class="k">:</span> <span class="kt">Vector2D</span> <span class="o">=</span>
    <span class="nc">Vector2D</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">x</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">y</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Observe that the hand-written implementation of <code class="highlighter-rouge">+</code> is quite repetitive.
We want to avoid that sort of boilerplate code as much as possible.</p>

<p>In this post, we will introduce an abstraction over the <em>addition</em> operation, namely <em>semigroups</em>,
and introduce a macro-based facility which allows you to get the implementation of <code class="highlighter-rouge">+</code> for free.
In the end, the only thing you will have to write is this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="n">vector2DSemigroup</span> <span class="k">=</span> <span class="nc">TypeClass</span><span class="o">[</span><span class="kt">Semigroup</span>, <span class="kt">Vector2D</span><span class="o">]</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">vector3DSemigroup</span> <span class="k">=</span> <span class="nc">TypeClass</span><span class="o">[</span><span class="kt">Semigroup</span>, <span class="kt">Vector3D</span><span class="o">]</span>
</code></pre></div></div>

<p>That is still a little bit of boilerplate, right? How about:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">Semigroup.auto._</span>
</code></pre></div></div>

<p>This will give you <code class="highlighter-rouge">Semigroup</code> instances for <em>all</em> of your data types – with zero boilerplate!</p>

<p>But first, let us introduce all the related concepts properly.</p>

<h2 id="abstracting-all-the-things">Abstracting all the things</h2>

<div class="side-note">
  If you are already familiar with type classes in general and algebraic structures in particular, you can safely skip this and the next section.
  Keep in mind though that we are dealing with classes for types of kind $*$ only. Type classes for $* \rightarrow *$ are different and not supported.
</div>

<p>Type classes are an incredibly useful abstraction mechanism, originally introduced in Haskell.
If you have been using some of the typelevel.scala libraries already, you probably know how type classes and their instances are represented in Scala: as traits and implicits.
In the following section, we will get started with an example type class from abstract algebra, which is implemented in <em>spire</em>.</p>

<h2 id="group-theory">Group theory</h2>

<p>Group theory is a very important field of research in mathematics and has a very broad range of applications, especially in computer science.
One of the most fundamental structures is a <em>semigroup</em>, which consists of a set of elements equipped with one operation (often called <em>append</em>, <em>mplus</em>, or similarly; in textbooks you will often find $\circ$ or $\oplus$).
Additionally, the operation has to obey the <em>law of associativity</em>, meaning that for any three values $s_1, s_2,$ and $s_3$, it does not matter if you append $s_1$ and $s_2$ first and then append $s_3$, or append $s_2$ and $s_3$ first and then append $s_1$ and the result of that.
In other words, the precise order in which the steps of a larger operation are executed does not matter.
A good analogy here is when flattening a list:
On the surface, you just do not care if it proceeds by splitting the list recursively or if the concatenation is done sequentially by folding.</p>

<div class="side-note">
  In fact, some list operations actually require associativity. From the Scaladoc of the <code>fold</code> method on <code>Seq</code>:
  <blockquote>
    Folds the elements of this collection or iterator using the specified associative binary operator.
    The order in which operations are performed on elements is unspecified and may be nondeterministic. 
  </blockquote>
  This allows a particular collection implementation to use whichever order is most efficient.
</div>

<p>Lists are already a good example for a semigroup: Any <code class="highlighter-rouge">List[T]</code> is a semigroup, with the semigroup operation being list concatenation!
A <code class="highlighter-rouge">Map[K, V]</code> is a semigroup too, given that <code class="highlighter-rouge">V</code> is a semigroup.
The operation is just “merging” two maps, and if you have two duplicate keys, you can use the semigroup operation for <code class="highlighter-rouge">V</code>.</p>

<p>Enough examples. We can represent the concept of a semigroup in Scala using a trait:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">append</span><span class="o">(</span><span class="n">s1</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">s2</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">S</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Obviously, we can also implement a semigroup for base types like <code class="highlighter-rouge">Int</code>. An instance could look like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="n">intInstance</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">append</span><span class="o">(</span><span class="n">s1</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">s2</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In other words, we just use the built-in addition function.</p>

<div class="side-note">If you want to know more about applications of abstract algebra in programming, especially in <em>spire</em>, head over to YouTube and watch <a href="http://www.youtube.com/watch?v=xO9AoZNSOH4">an introduction by Tom Switzer</a>.</div>

<h2 id="composing-instances">Composing instances</h2>

<p>Now suppose you are working with three-dimensional images.
Most likely, you will encounter a data structure for vectors (or points), which we recall from above:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Vector3D</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">z</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</code></pre></div></div>

<p>And since you know your maths, you also know that vectors can be added, and that vector addition forms a semigroup!
Hence, a semigroup instance for <code class="highlighter-rouge">Vector3D</code> is the next logical step.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="n">vectorInstance</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">Vector3D</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">append</span><span class="o">(</span><span class="n">u</span><span class="k">:</span> <span class="kt">Vector3D</span><span class="o">,</span> <span class="n">v</span><span class="k">:</span> <span class="kt">Vector3D</span><span class="o">)</span> <span class="k">=</span>
    <span class="nc">Vector3D</span><span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="o">,</span> <span class="n">u</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="o">,</span> <span class="n">u</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now, that was a bit tedious, right? We would love to have a way the compiler could write that instance for us.
(I mean, it already generates reasonable defaults for <code class="highlighter-rouge">equals</code>, <code class="highlighter-rouge">hashCode</code> and <code class="highlighter-rouge">toString</code>, so why not for that?)</p>

<p>In any case, you can see a pattern here: Each element of the case class is added separately.
Here, we could have even delegated the addition to our <code class="highlighter-rouge">intInstance</code> from above.</p>

<p>In essence, what we need is a way to combine smaller instances (e.g. for <code class="highlighter-rouge">Int</code>) into larger instances (e.g. for <code class="highlighter-rouge">Vector3D</code> consisting of three <code class="highlighter-rouge">Int</code>s).
Luckily, this is completely mechanic. As an exercise, try writing the following instance:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">tupleInstance</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Semigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">B</span><span class="k">:</span> <span class="kt">Semigroup</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Semigroup</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">append</span><span class="o">(</span><span class="n">t1</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">),</span> <span class="n">t2</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">))</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=</span> <span class="o">???</span>
  <span class="o">}</span>
</code></pre></div></div>

<h2 id="representing-data-types">Representing data types</h2>

<p>Once we know how to produce an instance for a pair, we can apply that two times and obtain an instance for a triple.
However, there are still two problems here:</p>

<ol>
  <li>We would like an instance for <code class="highlighter-rouge">Vector3D</code>, but we have an instance for <code class="highlighter-rouge">(Int, Int, Int)</code>.</li>
  <li>This is still a lie. We actually have an instance for <code class="highlighter-rouge">(Int, (Int, Int))</code>.</li>
</ol>

<p>Let us address these problems now. The following sections assume familiarity with <code class="highlighter-rouge">HList</code>s, as implemented in <em>shapeless</em>.</p>

<div class="side-note">
  If you are not familiar with <code>HList</code>s yet,
  watch Miles Sabin's <a href="http://www.youtube.com/watch?v=GDbNxL8bqkY">talk about <em>shapeless</em></a> at the Northeast Scala Symposium 2012.
  There's also a <a href="http://apocalisp.wordpress.com/2010/06/08/type-level-programming-in-scala/">blog series</a> exploring type-level programming in general by Mark Harrah.
</div>

<p>Now, we want to generate an instance for <code class="highlighter-rouge">Vector3D</code> and countless other data types.
That means that we cannot just special-case for every possible data type, but we have to abstract over them.
The trick is actually quite simple:
For the purposes of automatic instance derivation, we temporarily convert data types into a canonical <em>representation</em> using <code class="highlighter-rouge">HList</code>s, where each case class parameter corresponds to an element in the <code class="highlighter-rouge">HList</code>.</p>

<p>In our example, that representation is <code class="highlighter-rouge">Int :: Int :: Int :: HNil</code>.
Yes, that type is completely equivalent to <code class="highlighter-rouge">Vector3D</code>, and you can implement the conversion functions straightforwardly:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">to</span><span class="o">(</span><span class="n">vec</span><span class="k">:</span> <span class="kt">Vector3D</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">HNil</span> <span class="o">=</span>
  <span class="n">vec</span><span class="o">.</span><span class="n">x</span> <span class="o">::</span> <span class="n">vec</span><span class="o">.</span><span class="n">y</span> <span class="o">::</span> <span class="n">vec</span><span class="o">.</span><span class="n">z</span> <span class="o">::</span> <span class="nc">HNil</span>

<span class="k">def</span> <span class="n">from</span><span class="o">(</span><span class="n">hlist</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">)</span> <span class="k">=</span>
  <span class="o">???</span> <span class="c1">// fun exercise!
</span></code></pre></div></div>

<p>Because we are lazy, we let a macro automatically generate the <code class="highlighter-rouge">to</code> and <code class="highlighter-rouge">from</code> methods.
We will see in the second part of the series how that works.
For now, just assume that you can invoke some method, magic happens, and you get the conversions out.</p>

<h2 id="using-the-representation">Using the representation</h2>

<p>At this point, we have a canonical representation for arbitrary case classes.
We will also assume that there are <code class="highlighter-rouge">Semigroup</code> instances for each of its elements.
Now we would like to combine those base instances into an instance for the representation.
We need two implicits for that:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="n">nilInstance</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">append</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">HNil</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">HNil</span><span class="o">)</span> <span class="k">=</span> <span class="nc">HNil</span>
  <span class="o">}</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="n">consInstance</span><span class="o">[</span><span class="kt">H</span>, <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span><span class="k">implicit</span> <span class="k">val</span> <span class="n">H</span><span class="k">:</span> <span class="kt">Semigroup</span><span class="o">[</span><span class="kt">H</span><span class="o">],</span> <span class="n">T</span><span class="k">:</span> <span class="kt">Semigroup</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">H</span> <span class="kt">::</span> <span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="c1">// actual implementation doesn't matter that much
</span>    <span class="k">def</span> <span class="n">append</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">H</span> <span class="kt">::</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">H</span> <span class="kt">::</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="o">???</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>The key insight is that the compiler can come up with an instance for <code class="highlighter-rouge">Int :: Int :: Int :: HNil</code>, just because these two implicits are in scope.</p>

<p>Now we just need a way to get an instance for <code class="highlighter-rouge">Vector3D</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">subst</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">to</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">,</span> <span class="n">from</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">instance</span><span class="k">:</span> <span class="kt">Semigroup</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">append</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span>
      <span class="n">from</span><span class="o">(</span><span class="n">instance</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="n">to</span><span class="o">(</span><span class="n">a1</span><span class="o">),</span> <span class="n">to</span><span class="o">(</span><span class="n">a2</span><span class="o">))</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Easy enough, right?
To get our much-wanted <code class="highlighter-rouge">Semigroup[Vector3D]</code>, we ask the compiler to make an instance its <code class="highlighter-rouge">HList</code> representation, conjure the conversion functions and plug all that stuff into the <code class="highlighter-rouge">subst</code> machine. Voilà, done!
Add some teaspoons of macros, and we are able to write</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Semigroup</span><span class="o">.</span><span class="n">derive</span><span class="o">[</span><span class="kt">Vector3D</span><span class="o">]</span>
</code></pre></div></div>

<p>Are we done yet? No. We can go even further.</p>

<h2 id="abstracting-over-type-classes">Abstracting over type classes</h2>

<p><code class="highlighter-rouge">Semigroup</code> is not the only type class around. For example, there is a whole tower of classes from group theory for varying use cases. Then there are some type classes from <em>scalaz</em>:</p>

<ul>
  <li><code class="highlighter-rouge">Show</code> provides a way to convert a value to a <code class="highlighter-rouge">String</code></li>
  <li><code class="highlighter-rouge">Equal</code> for type-safe equality</li>
  <li><code class="highlighter-rouge">Order</code> provides total ordering on values</li>
</ul>

<p>… and many more!</p>

<p>Another key insight is that <em>all</em> of those classes are able to deal with <code class="highlighter-rouge">HLists</code> and also support the <code class="highlighter-rouge">subst</code> operation.
Hence, one could be tempted to write:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Show</span><span class="o">.</span><span class="n">derive</span><span class="o">[</span><span class="kt">Vector3D</span><span class="o">]</span>
<span class="nc">Equal</span><span class="o">.</span><span class="n">derive</span><span class="o">[</span><span class="kt">Vector3D</span><span class="o">]</span>
<span class="c1">// and more
</span></code></pre></div></div>

<p>I hate duplication, though. I do not want to implement the <code class="highlighter-rouge">derive</code> macro over and over again.
Now, if only there was a way to abstract over common functionality of types …</p>

<h2 id="a-type-class-called-typeclass">A type class called “TypeClass”</h2>

<p>“What,” I hear you saying, “the <code class="highlighter-rouge">TypeClass</code> type class? You can’t be serious!”</p>

<p>I am serious.</p>

<p>We use type classes to abstract over types.
<code class="highlighter-rouge">Semigroup</code> abstracts over types which offer some sort of addition functionality.</p>

<p>However, type classes are themselves just types in Scala.
Thus, we can use type classes to abstract over type classes.
We are defining a type class which abstracts over type classes whose instances can be combined to form larger instances.</p>

<p>So, without further ado:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">TypeClass</span><span class="o">[</span><span class="kt">C</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">nil</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">cons</span><span class="o">[</span><span class="kt">H</span>, <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span><span class="n">H</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">H</span><span class="o">],</span> <span class="n">T</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">H</span> <span class="kt">::</span> <span class="kt">T</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">subst</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">to</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">,</span> <span class="n">from</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">instance</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This should actually be not too surprising. We already know exactly how to implement <code class="highlighter-rouge">TypeClass[Semigroup]</code>.
If we put this implementation into the companion object of <code class="highlighter-rouge">Semigroup</code>, it will be available for the macro to use.</p>

<h2 id="wrapping-it-up">Wrapping it up</h2>

<p>How can this actually be used?
The work can be roughly divided between three roles:</p>

<ol>
  <li>
    <p>The macro author, who has to implement all the nitty-gritty details of the derivation process.</p>

    <p>That is already done and implemented in <em>shapeless</em>.
The upcoming 2.0.0 release will contain all the necessary bits and pieces, but requires at least Scala 2.10.2 (it will not work for 2.10.1 or earlier).
If you are brave, try the latest snapshot version which is available on Sonatype.</p>
  </li>
  <li>
    <p>The library author, who defines type classes, fundamental instances thereof, and of course the necessary <code class="highlighter-rouge">TypeClass</code> instances.</p>

    <p>These are usually contained in the libraries you use, but the last part will additionally require a bridge library.
But fear not, those bridge libraries already exist, at least for the typelevel.scala libraries, and can be readily added as dependency for your build.
Head over to the <a href="https://github.com/typelevel/shapeless-contrib#readme">GitHub project</a>, we will keep you posted for when a new version comes out.
We also plan to put a compatibility chart on this site.</p>
  </li>
  <li>
    <p>The library user, who defines data types and wants to get instances without all the boilerplate.</p>

    <p>This is the simplest task of all: All you have to do is to put</p>

    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="n">myInstance</span> <span class="k">=</span> <span class="nc">TypeClass</span><span class="o">[</span><span class="kt">Semigroup</span>, <span class="kt">Vector3D</span><span class="o">]</span>
<span class="c1">// or
</span><span class="k">import</span> <span class="nn">Semigroup.auto._</span>
</code></pre></div>    </div>

    <p>somewhere into your scope, and you are done!</p>

    <p>Providing “explicit” implicit declarations for each type class instance provides the tightest control over your implicit scope and ensures you only have the instances that you want.
Importing <code class="highlighter-rouge">auto</code> reduces the boilerplate to the absolute minimum, which is often desirable, but might result in more instances being materialized than you expect.
Which to choose is partly a matter of taste and partly a function of the size and complexity of the scopes you are importing in to:
large or complex scopes might favour explicit declarations; tighter, simpler scopes might favour <code class="highlighter-rouge">auto</code>.</p>
  </li>
</ol>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Mon, 24 Jun 2013 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2013/06/24/deriving-instances-1.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2013/06/24/deriving-instances-1.html</guid>
      </item>
    
      <item>
        <title>Inaugurating the typelevel.scala blog</title>
        
          <dc:creator>larsrh</dc:creator>
                
        <description><![CDATA[<p>This Twitter conversation happened today:</p>

<div>
  <blockquote><p>@<a href="https://twitter.com/d6">d6</a> do you have a blog on numerics, marcos, and performance?</p>&mdash; eugene yokota (@eed3si9n) <a href="https://twitter.com/eed3si9n/status/319711014620897280">April 4, 2013</a></blockquote>
  <blockquote><p>@<a href="https://twitter.com/eed3si9n">eed3si9n</a> Not currently. Maybe I should start one?</p>&mdash; Eiríkr Åsheim (@d6) <a href="https://twitter.com/d6/status/319804225607585794">April 4, 2013</a></blockquote>
  <blockquote><p>@<a href="https://twitter.com/d6">d6</a> @<a href="https://twitter.com/eed3si9n">eed3si9n</a> *cough* <a href="http://t.co/07ye9z78Qc" title="http://typelevel.org/blog/">typelevel.org/blog/</a> *cough*</p>&mdash; Tom Switzer (@tixxit) <a href="https://twitter.com/tixxit/status/319805809586495489">April 4, 2013</a></blockquote>
</div>

<p>So, here it is, the typelevel.scala blog!</p>

<h2 id="what-is-it-about">What is it about?</h2>

<p>As you might already know, typelevel.scala is a collection of libraries which provide a great amount of abstraction.
Here, we would like to show how to use them in your code, provide examples, collect learning resources, and explore implementation details.</p>

<h2 id="who-writes-here">Who writes here?</h2>

<p>Everyone who would like to! Contributions are welcome.
If you want to share something about Scalaz, Shapeless, Spire, or Scala topics in general (e.g. type classes), case studies, examples, or other related content, please do not hesitate to contact us.
This blog (and in fact, the whole web site) is built using Jekyll on GitHub pages, so you can just fork the <a href="https://github.com/typelevel/typelevel.github.com">repository</a>, add a post, and create a pull request.</p>

<h2 id="stay-tuned">Stay tuned!</h2>

<p>We hope that this blog will be filled with content soon.
To make sure that you don’t miss anything, follow <a href="https://twitter.com/typelevel">@typelevel</a> on Twitter or subscribe to the <a href="/blog/feed.rss">RSS feed</a>.</p>
<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>
]]></description>
        <pubDate>Thu, 04 Apr 2013 00:00:00 +0200</pubDate>
        <link>https://typelevel.org/blog/2013/04/04/inauguration.html</link>
        <guid isPermaLink="true">https://typelevel.org/blog/2013/04/04/inauguration.html</guid>
      </item>
    
  </channel>
</rss>

