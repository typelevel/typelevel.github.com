<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | An IO monad for cats</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>An IO monad for cats</h2>

  <p>Haskell is a pure language.  Every Haskell expression is <em>referentially transparent</em>, meaning that you can substitute that expression with its evaluated result without changing the program.  Or, put into code:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- this program</span>
<span class="n">f</span> <span class="n">expr</span> <span class="n">expr</span> <span class="c1">-- apply function f to arguments expr, expr</span>

<span class="c1">-- is equivalent to this one, which factors out `expr`</span>
<span class="kr">let</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">expr</span> <span class="c1">-- introduce a new variable `x` with the value of `expr`</span>
<span class="kr">in</span>
  <span class="n">f</span> <span class="n">x</span> <span class="n">x</span>
</code></pre></div></div>

<p>And this is true for <em>all</em> expressions <code class="highlighter-rouge">e</code>, and all functions <code class="highlighter-rouge">f</code>.  These could be complex expressions which describe ways of manipulating network channels or window buffers, or something trivial like a numeric literal.  You can <em>always</em> substitute the expression with its value.</p>

<p>This is not true in Scala, simply because Scala allows <em>unrestricted</em> side-effects.  Unlike Haskell, Scala puts no limitations on where and when we can use things like mutable state (<code class="highlighter-rouge">var</code>s) or evaluated external effects like <code class="highlighter-rouge">println</code> or <code class="highlighter-rouge">launchTheMissiles</code>.  Since there are no restrictions on where and when we can do evil, the Scala equivalent to the above just doesn‚Äôt work:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
<span class="c1">// isn't really equivalent to!
</span><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">e</span>
<span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div></div>

<p>The reason it isn‚Äôt equivalent comes from the different sorts of expressions that we could find in <code class="highlighter-rouge">e</code>.  For example, what if <code class="highlighter-rouge">e</code> is <code class="highlighter-rouge">println("hi!")</code>.  If we make that substitution, our snippet looks like the following:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"hi"</span><span class="o">),</span> <span class="n">println</span><span class="o">(</span><span class="s">"hi"</span><span class="o">))</span>
<span class="c1">// isn't really equivalent to!
</span><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">println</span><span class="o">(</span><span class="s">"hi"</span><span class="o">)</span>
<span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div></div>

<p>Clearly these are not the same two programs.  The first prints <code class="highlighter-rouge">"hi"</code> twice, while the second only prints it once.  This is a violation of referential transparency, and it‚Äôs why we sometimes say that Scala is an <em>impure</em> language.  Any expression which is not referentially transparent must contain <em>side-effects</em>, by definition.</p>

<p>Now of course, we found this problem by using a side-effecting function: namely, <code class="highlighter-rouge">println</code>.  Haskell clearly has the ability to print to standard output, so how does it avoid this issue?  If we build the same program in Haskell, can we violate referential transparency?</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="p">(</span><span class="n">putStrLn</span> <span class="s">"hi"</span><span class="p">)</span> <span class="p">(</span><span class="n">putStrLn</span> <span class="s">"hi"</span><span class="p">)</span>
<span class="c1">-- is equivalent to</span>
<span class="kr">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">putStrLn</span> <span class="s">"hi"</span> <span class="kr">in</span> <span class="n">f</span> <span class="n">x</span> <span class="n">x</span>
</code></pre></div></div>

<p>As it turns out, this is still referentially transparent!  These two programs still have the same meaning.  This is possible only because <em>neither</em> program actually prints anything!</p>

<p>In Haskell, effects are treated as first-class values.  The <code class="highlighter-rouge">putStrLn</code> function doesn‚Äôt print to standard out, it returns a value (of type <code class="highlighter-rouge">IO ()</code>) which describes <em>how</em> to print to standard out, but stops short of actually <em>doing</em> it.  These sorts of values can be composed using the monadic operators (in Scala, <code class="highlighter-rouge">flatMap</code> and <code class="highlighter-rouge">pure</code>), allowing Haskell programmers to build up expressions composed of sequences of dependent effects, all of which are merely <em>descriptions</em> of the side-effects which will eventually be performed by the runtime.  Ultimately, the description which comprises your <em>whole</em> program is the return result from the <code class="highlighter-rouge">main</code> function.  The Haskell runtime runs the <code class="highlighter-rouge">main</code> function to get this description of all your effects, and then runs the effects per your instructions.</p>

<p>This is kind of a clever trick.  It allows Haskell to simultaneously be pure <em>and</em> still have excellent support for manipulating effects and interacting with the ‚Äúreal world‚Äù.  But why is it relevant to Scala?  After all, Scala is an impure language.  We don‚Äôt <em>need</em> to go through this complex rigmarole of describing our effects and composing those descriptions; the language lets us <em>just do it!</em>  So why wouldn‚Äôt we just, you know, evaluate the effects that we need evaluated?</p>

<p>The answer is that we want to reason about <em>where</em> and <em>when</em> our effects are evaluated.  And of course, we want to be able to leverage laws and abstractions which assume equational semantics for expressions (i.e. referential transparency).  Cats is full of these sorts of abstractions, and cats-laws provides a vast set of laws which describe them.  But all of these abstractions and all of these laws break down the <em>moment</em> you introduce some sort of side-effecting expression.  Because, much like our referential transparency example from earlier, these abstractions <em>assume</em> that you can substitute expressions with their evaluated results, and that‚Äôs just not true in the presence of side-effects.</p>

<p>What we need is a data type which allows us to encapsulate Scala-style side-effects in the form of a <em>pure</em> value, on which referential transparency holds and which we can compose using other well-defined abstractions, such as <code class="highlighter-rouge">Monad</code>.  Scalaz defines two such data types which meet these criteria: <code class="highlighter-rouge">scalaz.effect.IO</code> and <code class="highlighter-rouge">scalaz.concurrent.Task</code>.  But in practice, nearly everyone uses <code class="highlighter-rouge">Task</code> instead of <code class="highlighter-rouge">IO</code> because of its support for <em>asynchronous</em> effects.</p>

<p>Cats does not define any such abstraction, and what‚Äôs worse is the cats <em>ecosystem</em> also doesn‚Äôt really provide any such abstraction.  There are two <code class="highlighter-rouge">Task</code> implementations that are relatively commonly used with cats ‚Äì namely, <code class="highlighter-rouge">monix.eval.Task</code> and <code class="highlighter-rouge">fs2.Task</code> ‚Äì but these are not part of cats per se, nor are they deeply integrated into its abstraction hierarchy.  Additionally, the proliferation of broadly equivalent options has led to confusion in the ecosystem, with middleware authors often forced to choose a solution for their end-users, and end-users uncertain as to which choice is ‚Äúright‚Äù.</p>

<h2 id="introducing-cats-effect">Introducing cats-effect</h2>

<p>The <a href="https://github.com/typelevel/cats-effect">cats-effect</a> project aims to change all of that.  The goal of cats-effect is to provide an ‚Äúeasy default‚Äù <code class="highlighter-rouge">IO</code> type for the cats ecosystem, deeply integrated with cats-core, with all of the features and performance that are required for real world production use.  Additionally, cats-effect defines a set of abstractions in the form of several typeclasses which describe what it means to <em>be</em> a pure effect type.  These abstractions are extremely useful both in enabling MTL-style program composition and to ensure that other pre-existing <code class="highlighter-rouge">Task</code> implementations remain first-class citizens of the ecosystem.  <code class="highlighter-rouge">IO</code> does not overshadow <code class="highlighter-rouge">monix.eval.Task</code> or <code class="highlighter-rouge">fs2.Task</code>; it <em>complements</em> them by providing a set of abstractions and laws which allow users to write safe, parametric code which supports each of them equally.</p>

<p>One important sidebar here: cats-effect does <em>not</em> provide any concurrency primitives.  <code class="highlighter-rouge">scalaz.concurrent.Task</code> and <code class="highlighter-rouge">monix.eval.Task</code> are both notable for providing functions such as <code class="highlighter-rouge">both</code>, which takes two <code class="highlighter-rouge">Task</code>s and runs them in parallel, returning a <code class="highlighter-rouge">Task</code> of a tuple of the results.  The <code class="highlighter-rouge">cats.effect.IO</code> type does not provide any such function, and while it would be possible to define such a function (and others like it!), we strongly encourage users to instead consider full-on streaming frameworks such as <strong>fs2</strong> or <strong>Monix</strong> for their concurrency needs, as these frameworks are able to provide a much sounder foundation for such functions.  See <a href="https://gist.github.com/djspiewak/a775b73804c581f4028fea2e98482b3c">here</a> for a rough outline of why this is.  Also note that some <code class="highlighter-rouge">Task</code> implementations, such as Monix‚Äôs, can and do provide parallelism on a sound foundation by enriching their internal algebraic structures.  Thus, <code class="highlighter-rouge">monix.eval.Task</code> is actually quite different from <code class="highlighter-rouge">cats.effect.IO</code>, despite having a similar core set of operations.</p>

<h2 id="enough-talk">Enough Talk‚Ä¶</h2>

<p>What does this look like in practice?  Well, ideally, as convenient as possible!  Let‚Äôs look at our println example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">putStrLn</span><span class="o">(</span><span class="n">line</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="n">line</span><span class="o">)</span> <span class="o">}</span>

<span class="n">f</span><span class="o">(</span><span class="n">putStrLn</span><span class="o">(</span><span class="s">"hi!"</span><span class="o">),</span> <span class="n">putStrLn</span><span class="o">(</span><span class="s">"hi!"</span><span class="o">))</span>

<span class="c1">// is equivalent to
</span>
<span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">putStrLn</span><span class="o">(</span><span class="s">"hi!"</span><span class="o">)</span>
<span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div></div>

<p>Great!  We can write Haskell fanfic in Scala.  üòõ</p>

<p>The notable element here is the use of the <code class="highlighter-rouge">IO.apply</code> constructor to wrap the <code class="highlighter-rouge">println</code> effect in a <em>pure</em> <code class="highlighter-rouge">IO</code> value.  This pattern can be applied to any side-effect.  You can think of this sort of like an FFI that converts impure code (like <code class="highlighter-rouge">println</code>) into pure code (like <code class="highlighter-rouge">putStrLn</code>).  The goal of this API was to be as simple and straightforward as possible.  If you have a curly brace block of impure side-effecting code, you can wrap it in a composable and pure abstraction by just adding two characters: <code class="highlighter-rouge">IO</code>.  You can wrap arbitrarily large or small blocks of code, potentially involving complex allocations, JNI calls, resource semantics, etc; but it is generally considered a best practice to wrap side-effects into the smallest composable units that make sense and do all of your sequentialization using <code class="highlighter-rouge">flatMap</code> and <code class="highlighter-rouge">for</code>-comprehensions.</p>

<p>For example, here‚Äôs a program that performs some simple user interaction in the shell:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="k">val</span> <span class="n">program</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Welcome to Scala!  What's your name?"</span><span class="o">)</span> <span class="o">}</span>
  <span class="n">name</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="nc">Console</span><span class="o">.</span><span class="n">readLine</span> <span class="o">}</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Well hello, $name!"</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>We could have just as easily written this program in the following way:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">program</span> <span class="k">=</span> <span class="nc">IO</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">"Welcome to Scala!  What's your name?"</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">name</span> <span class="k">=</span> <span class="nc">Console</span><span class="o">.</span><span class="n">readLine</span>
  <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Well hello, $name!"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>But this gives us less flexibility for composition.  Remember that even though <code class="highlighter-rouge">program</code> is a pure and referentially transparent value, its <em>definition</em> is not, which is to say that <code class="highlighter-rouge">IO { expr }</code> is not the same as <code class="highlighter-rouge">val x = expr; IO { x }</code>.  Anything inside the <code class="highlighter-rouge">IO {</code> ‚Ä¶ <code class="highlighter-rouge">}</code> block is not referentially transparent, and so should be treated with extreme care and suspicion.  The less of our program we have inside these blocks, the better!</p>

<p>As a sidebar that is actually kinda cool, we can implement a <code class="highlighter-rouge">readString</code> <code class="highlighter-rouge">IO</code> action that wraps <code class="highlighter-rouge">Console.readLine</code> <em>as a <code class="highlighter-rouge">val</code>!</em></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">readString</span> <span class="k">=</span> <span class="nc">IO</span> <span class="o">{</span> <span class="nc">Console</span><span class="o">.</span><span class="n">readLine</span> <span class="o">}</span>
</code></pre></div></div>

<p>This is totally valid!  We don‚Äôt need to worry about the difference between <code class="highlighter-rouge">def</code> and <code class="highlighter-rouge">val</code> anymore, because <code class="highlighter-rouge">IO</code> is referentially transparent.  So you use <code class="highlighter-rouge">def</code> when you need parameters, and you use <code class="highlighter-rouge">val</code> when you don‚Äôt, and you don‚Äôt have to think about evaluation semantics.  No more subtle bugs caused by accidentally memoizing your effects!</p>

<p>Of course, if <code class="highlighter-rouge">program</code> is referentially transparent, then clearly repeated values of <code class="highlighter-rouge">program</code> cannot possibly run the effects it represents multiple times.  For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">program</span>
<span class="n">program</span>
<span class="n">program</span>

<span class="c1">// must be the same as!
</span>
<span class="n">program</span>
</code></pre></div></div>

<p>If this weren‚Äôt the case, then we would be in trouble when trying to construct examples like the Haskell one from earlier.  But there is an implication here that is quite profound: <code class="highlighter-rouge">IO</code> cannot eagerly evaluate its effects, and similarly cannot memoize its results!  If <code class="highlighter-rouge">IO</code> were to eagerly evaluate or to memoize, then we could no longer replace references to the expression with the expression itself, since that would result in a <em>different</em> <code class="highlighter-rouge">IO</code> instance to be evaluated separately.</p>

<p>This is precisely why <code class="highlighter-rouge">scala.concurrent.Future</code> is <em>not</em> a suitable type for encapsulating effects in this way: constructing a <code class="highlighter-rouge">Future</code> that will eventually side-effect is itself a side-effect!  <code class="highlighter-rouge">Future</code> evaluates eagerly (sort of, see below) and memoizes its results, meaning that a <code class="highlighter-rouge">println</code> inside of a given <code class="highlighter-rouge">Future</code> will only evaluate <em>once</em>, even if the <code class="highlighter-rouge">Future</code> is sequenced multiple times.  This in turn means that <code class="highlighter-rouge">val x = Future(...); f(x, x)</code> is not the same program as <code class="highlighter-rouge">f(Future(...), Future(...))</code>, which is the very definition of a violation of referential transparency.</p>

<p>Coming back to <code class="highlighter-rouge">IO</code>‚Ä¶  If <code class="highlighter-rouge">program</code> does not evaluate eagerly, then clearly there must be some mechanism for asking it to evaluate.  After all, Scala is not like Haskell: we don‚Äôt return a value of type <code class="highlighter-rouge">IO[Unit]</code> from our <code class="highlighter-rouge">main</code> function.  <code class="highlighter-rouge">IO</code> provides an FFI of sorts for wrapping side-effecting code into pure <code class="highlighter-rouge">IO</code> values, so it must also provide an FFI for going in the opposite direction: taking a pure <code class="highlighter-rouge">IO</code> value and evaluating its constituent actions as side-effects.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">program</span><span class="o">.</span><span class="n">unsafeRunSync</span><span class="o">()</span>    <span class="c1">// uh oh!
</span></code></pre></div></div>

<p>This function is called <code class="highlighter-rouge">unsafeRunSync()</code>.  Given an <code class="highlighter-rouge">IO[A]</code>, the <code class="highlighter-rouge">unsafeRunSync()</code> function will give you a value of type <code class="highlighter-rouge">A</code>.  You should only call this function <em>once</em>, ideally at the very end of your program!  (i.e. in your <code class="highlighter-rouge">main</code> function)  Just as with <code class="highlighter-rouge">IO.apply</code>, any expression involving <code class="highlighter-rouge">unsafeRunSync()</code> is not referentially transparent.  For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">program</span><span class="o">.</span><span class="n">unsafeRunSync</span><span class="o">()</span>
<span class="n">program</span><span class="o">.</span><span class="n">unsafeRunSync</span><span class="o">()</span>
</code></pre></div></div>

<p>The above will run <code class="highlighter-rouge">program</code> <em>twice</em>.  So clearly, referential transparency is out the window whenever we do this, and we cannot expect the normal laws and abstractions to remain sound in the presence of this function.</p>

<h3 id="a-sidebar-on-futures-eager-evaluation">A sidebar on <code class="highlighter-rouge">Future</code>‚Äôs eager evaluation</h3>

<p>As Viktor Klang is fond of pointing out, <code class="highlighter-rouge">Future</code> doesn‚Äôt <em>need</em> to evaluate eagerly.  It is possible to define an <code class="highlighter-rouge">ExecutionContext</code> in which <code class="highlighter-rouge">Future</code> defers its evaluation until some indefinitely later point.  However, this is not the default mode of operation for 99% of all <code class="highlighter-rouge">Future</code>s ever constructed; most people just use <code class="highlighter-rouge">ExecutionContext.global</code> and leave it at that.  Additionally, if someone hands me an arbitrary <code class="highlighter-rouge">Future</code>, perhaps as a return value from a function, I really have no idea whether or not that <code class="highlighter-rouge">Future</code> is secretly running without my consent.  In other words, the referential transparency (or lack thereof) of functions that I write using <code class="highlighter-rouge">Future</code> is dependent on the runtime configuration of some other function which is hidden from me.  That‚Äôs not referential transparency anymore.  Because we cannot be <em>certain</em> that <code class="highlighter-rouge">Future</code> is deferring its evaluation, we must defensively assume that it is not.</p>

<p>This, in a nutshell, is precisely why <code class="highlighter-rouge">Future</code> is not appropriate for functional programming.  <code class="highlighter-rouge">IO</code> provides a pair of functions (<code class="highlighter-rouge">fromFuture</code> and <code class="highlighter-rouge">unsafeToFuture</code>) for interacting with <code class="highlighter-rouge">Future</code>-using APIs, but in general, you should try to stick with <code class="highlighter-rouge">IO</code> as much as possible when manipulating effects.</p>

<h2 id="asynchrony-and-the-jvm">Asynchrony and the JVM</h2>

<p>Scala runs on three platforms: the JVM, JavaScript and LLVM.  For the moment, we‚Äôll just focus on the first two.  The JVM has support for multiple threads, but those threads are <em>native</em> (i.e. kernel) threads, meaning that they are relatively expensive to create and maintain in the runtime.  They are a very limited resource, sort of like file handles or heap space, and you can‚Äôt just write programs which require an unbounded number of them.  The exact upper bound on the JVM varies from platform to platform, and varies considerably depending on your GC configuration, but a general rule of thumb is ‚Äúa few thousand‚Äù, where ‚Äúfew‚Äù is a small number.  In practice, you‚Äôre going to want <em>far</em> less threads than that if you want to avoid thrashing your GC, and most applications will divide themselves into a bounded ‚Äúmain‚Äù thread pool (usually bounded to exactly the number of CPUs) on which all CPU-bound tasks are performed and most of the program runs, as well as a set of unbounded ‚Äúblocking‚Äù thread pools on which blocking IO actions (such as anything in <code class="highlighter-rouge">java.io</code>) are run.  When you add NIO worker pools into the mix, the final number of threads in a practical production service is usually around 30-40 on an 8 CPU machine, growing roughly linearly as you add CPUs.  Clearly, this is not a very large number.</p>

<p>On JavaScript runtimes (such as <code class="highlighter-rouge">node</code> or in the browser), the situation is even worse: you have exactly one thread!  JavaScript simply doesn‚Äôt have multi-threading in any (real) form, and so it‚Äôs like the JVM situation, but 30-40x more constraining.</p>

<p>For this reason, we need to be very careful when writing Scala to treat threads as an extremely scarce resource.  <em>Blocking</em> threads (using mechanisms such as <code class="highlighter-rouge">wait</code>, <code class="highlighter-rouge">join</code> or <code class="highlighter-rouge">CountDownLatch</code>) should be considered absolutely anathema, since it selfishly wastes a very finite and very critical resource, leading to thread starvation and deadlocks.</p>

<p>This is very different from how things are in Haskell though!  The Haskell runtime is implemented around the concept of <em>green threads</em>, which is to say, <em>emulated</em> concurrency by means of a runtime dispatch lock.  Haskell basically creates a global bounded thread pool in the runtime with the same number of threads as your machine has CPUs.  On top of that pool, it runs dispatch trampolines that schedule and evict expression evaluation, effectively emulating an arbitrarily large number of ‚Äúfake‚Äù threads atop a small fixed set of ‚Äúreal‚Äù threads.  So when you write code in Haskell, you generally just assume that threads are extremely cheap and you can have as many of them as you want.  Under these circumstances, blocking a thread is not really a big deal (as long as you don‚Äôt do it in FFI native code), so there‚Äôs no reason to go out of your way to avoid it in abstractions like <code class="highlighter-rouge">IO</code>.</p>

<p>This presents a bit of a dilemma for cats-effect: we want to provide a <em>practical</em> pure abstraction for encapsulating effects, but we need to run on the JVM and on JavaScript which means we need to provide a way to avoid thread blocking.  So, the <code class="highlighter-rouge">IO</code> implementation in cats-effect is going to <em>necessarily</em> end up looking very, very different from the one in Haskell, providing a very different set of operations.</p>

<p>Specifically, <code class="highlighter-rouge">cats.effect.IO</code> provides an additional constructor, <code class="highlighter-rouge">async</code>, which allows the construction of <code class="highlighter-rouge">IO</code> instances from callback-driven APIs.  This is generally referred to as ‚Äúasynchronous‚Äù control flow, as opposed to ‚Äúsynchronous‚Äù control flow (represented by the <code class="highlighter-rouge">apply</code> constructor).  To see how this works, we‚Äôre going to need a bit of setup.</p>

<p>Consider the following somewhat-realistic NIO API (translated to Scala):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Response</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">onError</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
  <span class="k">def</span> <span class="n">onSuccess</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>
<span class="c1">// defined trait Response
</span>
<span class="k">trait</span> <span class="nc">Channel</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">sendBytes</span><span class="o">(</span><span class="n">chunk</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">],</span> <span class="n">handler</span><span class="k">:</span> <span class="kt">Response</span><span class="o">[</span><span class="kt">Unit</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span>
  <span class="k">def</span> <span class="n">receiveBytes</span><span class="o">(</span><span class="n">handler</span><span class="k">:</span> <span class="kt">Response</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>
<span class="c1">// defined trait Channel
</span></code></pre></div></div>

<p>This is an asynchronous API.  Neither of the functions <code class="highlighter-rouge">sendBytes</code> or <code class="highlighter-rouge">receiveBytes</code> attempt to block on completion.  Instead, they <em>schedule</em> their operations via some underlying mechanism.  This interface could be implemented on top of <code class="highlighter-rouge">java.io</code> (which is a synchronous API) through the use of an internal thread pool, but most NIO implementations are actually going to delegate their scheduling all the way down to the kernel layer, avoiding the consumption of a precious thread while waiting for the underlying IO ‚Äì which, in the case of network sockets, may be a very long wait indeed!</p>

<p>Wrapping this sort of API in a referentially transparent and uniform fashion is a very important feature of <code class="highlighter-rouge">IO</code>, <em>precisely</em> because of Scala‚Äôs underlying platform constraints.  Clearly, <code class="highlighter-rouge">sendBytes</code> and <code class="highlighter-rouge">receiveBytes</code> both represent side-effects, but they‚Äôre different than <code class="highlighter-rouge">println</code> and <code class="highlighter-rouge">readLine</code> in that they don‚Äôt produce their results in a sequentially returned value.  Instead, they take a callback, <code class="highlighter-rouge">Response</code>, which will eventually be notified (likely on some other thread!) when the result is available.  The <code class="highlighter-rouge">IO.async</code> constructor is designed for precisely these situations:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">send</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Channel</span><span class="o">,</span> <span class="n">chunk</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">IO</span> <span class="n">async</span> <span class="o">{</span> <span class="n">cb</span> <span class="k">=&gt;</span>
    <span class="n">c</span><span class="o">.</span><span class="n">sendBytes</span><span class="o">(</span><span class="n">chunk</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Response</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">onError</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span> <span class="k">=</span> <span class="n">cb</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">t</span><span class="o">))</span>
      <span class="k">def</span> <span class="n">onSuccess</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">Unit</span><span class="o">)</span> <span class="k">=</span> <span class="n">cb</span><span class="o">(</span><span class="nc">Right</span><span class="o">(()))</span>
    <span class="o">})</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// send: (c: Channel, chunk: Array[Byte])cats.effect.IO[Unit]
</span>
<span class="k">def</span> <span class="n">receive</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Channel</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">IO</span> <span class="n">async</span> <span class="o">{</span> <span class="n">cb</span> <span class="k">=&gt;</span>
    <span class="n">c</span><span class="o">.</span><span class="n">receiveBytes</span><span class="o">(</span><span class="k">new</span> <span class="nc">Response</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">onError</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span> <span class="k">=</span> <span class="n">cb</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">t</span><span class="o">))</span>
      <span class="k">def</span> <span class="n">onSuccess</span><span class="o">(</span><span class="n">chunk</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">])</span> <span class="k">=</span> <span class="n">cb</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">chunk</span><span class="o">))</span>
    <span class="o">})</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// receive: (c: Channel)cats.effect.IO[Array[Byte]]
</span></code></pre></div></div>

<p>Obviously, this is a little more daunting than the <code class="highlighter-rouge">println</code> examples from earlier, but that‚Äôs mostly the fault of the anonymous inner class syntactic ceremony.  The <code class="highlighter-rouge">IO</code> interaction is actually quite simple!</p>

<p>The <code class="highlighter-rouge">async</code> constructor takes a function which is handed a <em>callback</em> (represented above by <code class="highlighter-rouge">cb</code> in both cases).  This callback is <em>itself</em> a function of type <code class="highlighter-rouge">Either[Throwable, A] =&gt; Unit</code>, where <code class="highlighter-rouge">A</code> is the type produced by the <code class="highlighter-rouge">IO</code>.  So when our <code class="highlighter-rouge">Response</code> comes back as <code class="highlighter-rouge">onSuccess</code> in the <code class="highlighter-rouge">send</code> example, we invoke the callback with a <code class="highlighter-rouge">Right(())</code> since we‚Äôre trying to produce an <code class="highlighter-rouge">IO[Unit]</code>.  When the <code class="highlighter-rouge">Response</code> comes back as <code class="highlighter-rouge">onSuccess</code> in the <code class="highlighter-rouge">receive</code> example, we invoke the callback with <code class="highlighter-rouge">Right(chunk)</code>, since the <code class="highlighter-rouge">IO</code> produces an <code class="highlighter-rouge">Array[Byte]</code>.</p>

<p>Now remember, <code class="highlighter-rouge">IO</code> is still a monad, and <code class="highlighter-rouge">IO</code> values constructed with <code class="highlighter-rouge">async</code> are perfectly capable of all of the things that ‚Äúnormal‚Äù, synchronous <code class="highlighter-rouge">IO</code> values are, which means that you can use these values inside <code class="highlighter-rouge">for</code>-comprehensions and other conventional composition!  This is incredibly, unbelievably nice in practice, because it takes your complex, nested, callback-driven code and flattens it into simple, easy-to-read sequential composition.  For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">c</span><span class="k">:</span> <span class="kt">Channel</span> <span class="o">=</span> <span class="kc">null</span> <span class="c1">// pretend this is an actual channel
</span>
<span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">send</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="s">"SYN"</span><span class="o">.</span><span class="n">getBytes</span><span class="o">)</span>
  <span class="n">response</span> <span class="k">&lt;-</span> <span class="n">receive</span><span class="o">(</span><span class="n">c</span><span class="o">)</span>

  <span class="k">_</span> <span class="k">&lt;-</span> <span class="k">if</span> <span class="o">(</span><span class="n">response</span> <span class="o">==</span> <span class="s">"ACK"</span><span class="o">.</span><span class="n">getBytes</span><span class="o">)</span>   <span class="c1">// pretend == works on Array[Byte]
</span>    <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"found the guy!"</span><span class="o">)</span> <span class="o">}</span>
  <span class="k">else</span>
    <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"no idea what happened, but it wasn't good"</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>This is kind of amazing.  There‚Äôs no thread blocking at all in the above (other than the <code class="highlighter-rouge">println</code> blocking on standard output).  The <code class="highlighter-rouge">receive</code> could take quite a long time to come back to us, and our thread is free to do other things in the interim.  Everything is driven by callbacks under the surface, and asynchronous actions can be manipulated just as easily as synchronous ones.</p>

<p>Of course, this is an even bigger win on JavaScript, where nearly everything is callback-based, and gigantic, deeply nested chunks of code are not unusual.  <code class="highlighter-rouge">IO</code> allows you to flatten those deeply nested chunks of code into a nice, clean, linear and sequential formulation.</p>

<h2 id="thread-shifting">Thread Shifting</h2>

<p>Now there is a caveat here.  When our <code class="highlighter-rouge">Response</code> handler is invoked by <code class="highlighter-rouge">Channel</code>, it is very likely that the callback will be run on a thread which is part of a different thread pool than our main program.  Remember from earlier where I described how <em>most</em> well-designed Java services are organized:</p>

<ul>
  <li>A bounded thread pool set to <em>num CPUs</em> in size for any non-IO actions</li>
  <li>A set of unbounded thread pools for blocking IO</li>
  <li>Some bounded internal thread worker pools for NIO polling</li>
</ul>

<p>We definitely want to run nearly everything on that first pool (which is probably <code class="highlighter-rouge">ExecutionContext.global</code>), but we‚Äôre probably going to receive the <code class="highlighter-rouge">Response</code> callback on one of the third pools.  So how can we force the rest of our program (including those <code class="highlighter-rouge">println</code>s) back onto the main pool?</p>

<p>The answer is the <code class="highlighter-rouge">shift</code> function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent._</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">ec</span> <span class="k">=</span> <span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span>

<span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">send</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="s">"SYN"</span><span class="o">.</span><span class="n">getBytes</span><span class="o">)</span>
  <span class="n">response</span> <span class="k">&lt;-</span> <span class="n">receive</span><span class="o">(</span><span class="n">c</span><span class="o">).</span><span class="n">shift</span>    <span class="c1">// there's no place like home!
</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="k">if</span> <span class="o">(</span><span class="n">response</span> <span class="o">==</span> <span class="s">"ACK"</span><span class="o">.</span><span class="n">getBytes</span><span class="o">)</span>   <span class="c1">// pretend == works on Array[Byte]
</span>    <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"found the guy!"</span><span class="o">)</span> <span class="o">}</span>
  <span class="k">else</span>
    <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"no idea what happened, but it wasn't good"</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">shift</code>‚Äôs functionality is a little complicated, but generally speaking, you should think of it as a ‚Äúforce this <code class="highlighter-rouge">IO</code> onto this <em>other</em> thread pool‚Äù function.  Of course, when <code class="highlighter-rouge">receive</code> executes, most of its work isn‚Äôt done on any thread at all (since it is simply registering a hook with the kernel), and so that work isn‚Äôt thread shifted to any pool, main or otherwise.  But when <code class="highlighter-rouge">receive</code> gets back to us with the network response, the callback will be handled and then <em>immediately</em> thread-shifted back onto the main pool, which is passed implicitly as a parameter to <code class="highlighter-rouge">shift</code> (you can also pass this explicitly if you like).  This thread-shifting means that all of the subsequent actions within the <code class="highlighter-rouge">for</code>-comprehension ‚Äì which is to say, the <em>continuation</em> of <code class="highlighter-rouge">receive(c)</code> ‚Äì will be run on the <code class="highlighter-rouge">ec</code> thread pool, rather than whatever worker pool is used internally by <code class="highlighter-rouge">Channel</code>.  This is an <em>extremely</em> common use-case in practice, and <code class="highlighter-rouge">IO</code> attempts to make it as straightforward as possible.</p>

<p>Another possible application of thread shifting is ensuring that a blocking <code class="highlighter-rouge">IO</code> action is relocated from the main, CPU-bound thread pool onto one of the pools designated for blocking IO.  An example of this would be any interaction with <code class="highlighter-rouge">java.io</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.io.</span><span class="o">{</span><span class="nc">BufferedReader</span><span class="o">,</span> <span class="nc">FileReader</span><span class="o">}</span>
<span class="c1">// import java.io.{BufferedReader, FileReader}
</span>
<span class="k">def</span> <span class="n">readLines</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Vector</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">IO</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">reader</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">name</span><span class="o">))</span>
  <span class="k">var</span> <span class="n">back</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">.</span><span class="n">empty</span>

  <span class="k">try</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">line</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="kc">null</span>
    <span class="k">do</span> <span class="o">{</span>
      <span class="n">line</span> <span class="k">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">readLine</span><span class="o">()</span>
      <span class="n">back</span> <span class="o">:+</span> <span class="n">line</span>
    <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="n">reader</span><span class="o">.</span><span class="n">close</span><span class="o">()</span>
  <span class="o">}</span>

  <span class="n">back</span>
<span class="o">}</span>
<span class="c1">// readLines: (name: String)cats.effect.IO[Vector[String]]
</span></code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Name, pls."</span><span class="o">)</span> <span class="o">}</span>
  <span class="n">name</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="nc">Console</span><span class="o">.</span><span class="n">readLine</span> <span class="o">}</span>
  <span class="n">lines</span> <span class="k">&lt;-</span> <span class="n">readLines</span><span class="o">(</span><span class="s">"names.txt"</span><span class="o">)</span>

  <span class="k">_</span> <span class="k">&lt;-</span> <span class="k">if</span> <span class="o">(</span><span class="n">lines</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">name</span><span class="o">))</span>
    <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"You're on the list, boss."</span><span class="o">)</span> <span class="o">}</span>
  <span class="k">else</span>
    <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Get outa here!"</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>Clearly, <code class="highlighter-rouge">readLines</code> is blocking the underlying thread while it waits for the disk to return the file contents to us, and for a large file, we might be blocking the thread for quite a long time!  Now if we‚Äôre treating our thread pools with respect (as described above), then we probably have a pair of <code class="highlighter-rouge">ExecutionContext</code>(s) sitting around in our code somewhere:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">java.util.concurrent.Executors</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nc">Main</span> <span class="k">=</span> <span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">global</span>
<span class="k">val</span> <span class="nc">BlockingFileIO</span> <span class="k">=</span> <span class="nc">ExecutionContext</span><span class="o">.</span><span class="n">fromExecutor</span><span class="o">(</span><span class="nc">Executors</span><span class="o">.</span><span class="n">newCachedThreadPool</span><span class="o">())</span>
</code></pre></div></div>

<p>We want to ensure that <code class="highlighter-rouge">readLines</code> runs on the <code class="highlighter-rouge">BlockingFileIO</code> pool, while everything else in the <code class="highlighter-rouge">for</code>-comprehension runs on <code class="highlighter-rouge">Main</code>.  How can we achieve this?</p>

<p>With <code class="highlighter-rouge">shift</code>!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Name, pls."</span><span class="o">)</span> <span class="o">}</span>
  <span class="n">name</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="nc">Console</span><span class="o">.</span><span class="n">readLine</span> <span class="o">}</span>
  <span class="n">lines</span> <span class="k">&lt;-</span> <span class="n">readLines</span><span class="o">(</span><span class="s">"names.txt"</span><span class="o">).</span><span class="n">shift</span><span class="o">(</span><span class="nc">BlockingFileIO</span><span class="o">).</span><span class="n">shift</span><span class="o">(</span><span class="nc">Main</span><span class="o">)</span>

  <span class="k">_</span> <span class="k">&lt;-</span> <span class="k">if</span> <span class="o">(</span><span class="n">lines</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">name</span><span class="o">))</span>
    <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"You're on the list, boss."</span><span class="o">)</span> <span class="o">}</span>
  <span class="k">else</span>
    <span class="nc">IO</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Get outa here!"</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>Now we‚Äôre definitely in bizarro land.  <em>Two</em> calls to <code class="highlighter-rouge">shift</code>, one after the other?  Let‚Äôs break this apart:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">readLines</span><span class="o">(</span><span class="s">"names.txt"</span><span class="o">).</span><span class="n">shift</span><span class="o">(</span><span class="nc">BlockingFileIO</span><span class="o">)</span>
</code></pre></div></div>

<p>One of the functions of <code class="highlighter-rouge">shift</code> is to take the <code class="highlighter-rouge">IO</code> action it is given and relocate that action onto the given thread pool.  In the case of <code class="highlighter-rouge">receive</code>, this component of <code class="highlighter-rouge">shift</code> was meaningless since <code class="highlighter-rouge">receive</code> didn‚Äôt use a thread under the surface (it was asynchronous!).  However, <code class="highlighter-rouge">readLines</code> <em>does</em> use a thread under the surface (hint: it was constructed with <code class="highlighter-rouge">IO.apply</code> rather than <code class="highlighter-rouge">IO.async</code>), and so that work will be relocated onto the <code class="highlighter-rouge">BlockingFileIO</code> pool by the above expression.</p>

<p><em>Additionally</em>, the continuation of this work will also be relocated onto the <code class="highlighter-rouge">BlockingFileIO</code> pool, and that‚Äôs definitely not what we want.  The evaluation of the <code class="highlighter-rouge">contains</code> function is definitely CPU-bound, and should be run on the <code class="highlighter-rouge">Main</code> pool.  So we need to <code class="highlighter-rouge">shift</code> a second time, but only the <em>continuation</em> of the <code class="highlighter-rouge">readLines</code> action, not <code class="highlighter-rouge">readLines</code> itself.  As it turns out, we can achieve this just by adding the second <code class="highlighter-rouge">shift</code> call:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">readLines</span><span class="o">(</span><span class="s">"names.txt"</span><span class="o">).</span><span class="n">shift</span><span class="o">(</span><span class="nc">BlockingFileIO</span><span class="o">).</span><span class="n">shift</span><span class="o">(</span><span class="nc">Main</span><span class="o">)</span>
</code></pre></div></div>

<p>Now, <code class="highlighter-rouge">readLines</code> will be run on the <code class="highlighter-rouge">BlockingFileIO</code> pool, but the <em>continuation</em> of <code class="highlighter-rouge">readLines</code> (namely, everything that follows it in the <code class="highlighter-rouge">for</code>-comprehension) will be run on <code class="highlighter-rouge">Main</code>.  This works because <code class="highlighter-rouge">shift</code> creates an asynchronous <code class="highlighter-rouge">IO</code> that schedules the target action on the given thread pool and invokes its continuation <em>from a callback</em>.  The <a href="http://www.scala-lang.org/api/current/scala/concurrent/ExecutionContext.html#execute(runnable:Runnable):Unit">ExecutionContext#execute</a> function should give you an idea of how this works.  This means that the result of the first <code class="highlighter-rouge">shift</code> is an <code class="highlighter-rouge">IO</code> constructed with <code class="highlighter-rouge">async</code>, and cannot <em>itself</em> be thread-shifted (unlike an <code class="highlighter-rouge">IO</code> constructed with <code class="highlighter-rouge">apply</code>), but its continuation <em>can</em> be thread-shifted, which is exactly what happens.</p>

<p>This sort of double-<code class="highlighter-rouge">shift</code> idiom is very common in production service code that makes use of legacy blocking IO libraries such as <code class="highlighter-rouge">java.io</code>.</p>

<h3 id="synchronous-vs-asynchronous-execution">Synchronous vs Asynchronous Execution</h3>

<p>Speaking of asynchrony, readers who have been looking ahead in the class syllabus probably realized that the type signature of <code class="highlighter-rouge">unsafeRunSync()</code> is more than a little suspicious.  Specifically, it promises to give us an <code class="highlighter-rouge">A</code> <em>immediately</em> given an <code class="highlighter-rouge">IO[A]</code>; but if that <code class="highlighter-rouge">IO[A]</code> is an asynchronous action invoked with a callback, how can it achieve this promise?</p>

<p>The answer is that it blocks a thread.  (<em>gasp!!!</em>)  Under the surface, a <code class="highlighter-rouge">CountDownLatch</code> is used to block the calling thread whenever an <code class="highlighter-rouge">IO</code> is encountered that was constructed with <code class="highlighter-rouge">IO.async</code>.  Functionally, this is very similar to the <code class="highlighter-rouge">Await.result</code> function in <code class="highlighter-rouge">scala.concurrent</code>, and it is just as dangerous.  Additionally, it clearly cannot possibly work on JavaScript, since you only have one thread to block!  If you try to call <code class="highlighter-rouge">unsafeRunSync()</code> on JavaScript with an underlying <code class="highlighter-rouge">IO.async</code>, it will just throw an exception rather than deadlock your application.</p>

<p>This is not such a great state of affairs.  I mean, it <em>works</em> if <code class="highlighter-rouge">unsafeRunSync()</code> is being run in test code, or as the last line of your <code class="highlighter-rouge">main</code> function, but sometimes we need to interact with legacy code or with Java APIs that weren‚Äôt designed for purity.  Sometimes, we just <em>have</em> to evaluate our <code class="highlighter-rouge">IO</code> actions before ‚Äúthe end of the world‚Äù, and when we do that, we don‚Äôt want to block any of our precious threads.</p>

<p>So <code class="highlighter-rouge">IO</code> provides an additional function: <code class="highlighter-rouge">unsafeRunAsync</code>.  This function takes a callback (of type <code class="highlighter-rouge">Either[Throwable, A] =&gt; Unit</code>) which it will run when (and if) the <code class="highlighter-rouge">IO[A]</code> completes its execution.  As the name implies, this function is <em>also</em> not referentially transparent, but unlike <code class="highlighter-rouge">unsafeRunSync()</code>, it will not block a thread.</p>

<p>As a sidebar that will be important in a few paragraphs, <code class="highlighter-rouge">IO</code> also defines a <em>safe</em> function called <code class="highlighter-rouge">runAsync</code> which has a very similar signature to <code class="highlighter-rouge">unsafeRunAsync</code>, except it returns an <code class="highlighter-rouge">IO[Unit]</code>.  The <code class="highlighter-rouge">IO[Unit]</code> which is returned from this function <em>will not block</em> if you call <code class="highlighter-rouge">unsafeRunAsync()</code>.  In other words, it is always safe to call <code class="highlighter-rouge">unsafeRunSync()</code> on the results of <code class="highlighter-rouge">runAsync</code>, even on JavaScript.</p>

<p>Another way to look at this is in terms of <code class="highlighter-rouge">unsafeRunAsync</code>.  You can define <code class="highlighter-rouge">unsafeRunAsync</code> in terms of <code class="highlighter-rouge">runAsync</code> and <code class="highlighter-rouge">unsafeRunSync()</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">unsafeRunAsync</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ioa</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">cb</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">Throwable</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
  <span class="n">ioa</span><span class="o">.</span><span class="n">runAsync</span><span class="o">(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="nc">IO</span> <span class="o">{</span> <span class="n">cb</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="o">}).</span><span class="n">unsafeRunSync</span><span class="o">()</span>
<span class="c1">// unsafeRunAsync: [A](ioa: cats.effect.IO[A])(cb: Either[Throwable,A] =&gt; Unit)Unit
</span></code></pre></div></div>

<p>This isn‚Äôt the actual definition, but it would be a valid one, and it would run correctly on every platform.</p>

<h2 id="abstraction-and-lawfulness">Abstraction and Lawfulness</h2>

<p>As mentioned earlier (about 10000 words ago‚Ä¶), the cats-effect project not only provides a concrete <code class="highlighter-rouge">IO</code> type with a lot of nice features, it also provides a set of abstractions characterized by typeclasses and associated laws.  These abstractions collectively define what it means to be a type which encapsulates side-effects in a pure fashion, and they are implemented by <code class="highlighter-rouge">IO</code> as well as several other types (including <code class="highlighter-rouge">fs2.Task</code> and <code class="highlighter-rouge">monix.eval.Task</code>).  The hierarchy looks like this:</p>

<p><img src="/img/media/cats-effect-diagram.png" alt="cats-effect typeclasses" /></p>

<p><code class="highlighter-rouge">Monad</code> and <code class="highlighter-rouge">MonadError</code> are of course a part of cats-core, while everything else is in cats-effect.  <code class="highlighter-rouge">MonadError</code> is functionally equivalent to the familiar <code class="highlighter-rouge">scalaz.Catchable</code> typeclass, which was commonly used in conjunction with <code class="highlighter-rouge">scalaz.concurrent.Task</code>.  It literally means ‚Äúa monad with error-handling capabilities‚Äù.  <code class="highlighter-rouge">IO</code> certainly fits that description, as any exceptions thrown within its <code class="highlighter-rouge">apply</code> method (or within <code class="highlighter-rouge">async</code>) will be caught and may be handled in pure code by means of the <code class="highlighter-rouge">attempt</code> function.  <code class="highlighter-rouge">Sync</code>, <code class="highlighter-rouge">Async</code>, <code class="highlighter-rouge">LiftIO</code> and <code class="highlighter-rouge">Effect</code> are the new typeclasses.</p>

<p><code class="highlighter-rouge">Sync</code> simply describes the <code class="highlighter-rouge">IO.apply</code> function (in the typeclasses, this function is called <code class="highlighter-rouge">delay</code>).  Which is to say, any type constructor <code class="highlighter-rouge">F[_]</code> which has a <code class="highlighter-rouge">Sync[F]</code> has the capability to suspend <em>synchronous</em> side-effecting code.  <code class="highlighter-rouge">Async</code> is very similar to this in that it describes the <code class="highlighter-rouge">async</code> function.  So any type constructor <code class="highlighter-rouge">F[_]</code> which has an <code class="highlighter-rouge">Async[F]</code> can suspend <em>asynchronous</em> side-effecting code.  <code class="highlighter-rouge">LiftIO</code> should be familiar to Haskell veterans, and is broadly useful for defining parametric signatures and composing monad transformer stacks.</p>

<p><code class="highlighter-rouge">Effect</code> is where everything is brought together.  In addition to being able to suspend synchronous and asynchronous side-effecting code, anything that has an <code class="highlighter-rouge">Effect</code> instance may also be <em>asynchronously interpreted</em> into an <code class="highlighter-rouge">IO</code>.  The way this is specified is using the <code class="highlighter-rouge">runAsync</code> function:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.</span><span class="o">{</span><span class="nc">Async</span><span class="o">,</span> <span class="nc">LiftIO</span><span class="o">,</span> <span class="nc">Sync</span><span class="o">}</span>

<span class="k">trait</span> <span class="nc">Effect</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">with</span> <span class="nc">Async</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">with</span> <span class="nc">LiftIO</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">runAsync</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">cb</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">Throwable</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<!--    please don't remove; my editor is glitchy :-(
```
-->

<p>What this is saying is that any <code class="highlighter-rouge">Effect</code> must define the ability to evaluate as a side-effect, but of course, we don‚Äôt want to have side-effects in our pure and reasonable code.  So how are side-effects <em>purely</em> represented?  With <code class="highlighter-rouge">IO</code>!</p>

<p>From a parametric reasoning standpoint, <code class="highlighter-rouge">IO</code> means ‚Äúhere be effects‚Äù, and so any type signature which involves <code class="highlighter-rouge">IO</code> thus also involves side-effects (well, <em>effects</em> anyway), and any type signature which requires side-effects must also involve <code class="highlighter-rouge">IO</code>.  This bit of trickery allows us to reason about <code class="highlighter-rouge">Effect</code> in a way that would have been much harder if we had defined <code class="highlighter-rouge">unsafeRunAsync</code> as a member, and it ensures that downstream projects which write code abstracting over <code class="highlighter-rouge">Effect</code> types can do so without using any <code class="highlighter-rouge">unsafe</code> functions if they so choose (especially when taken together with the <code class="highlighter-rouge">liftIO</code> function).</p>

<h2 id="conclusion">Conclusion</h2>

<p>The lack of a production-ready <code class="highlighter-rouge">Task</code>-like type fully integrated into the cats ecosystem has been a sticking point for a lot of people considering adopting cats.  With the introduction of <a href="https://github.com/typelevel/cats-effect">cats-effect</a>, this should no longer be a problem!  As of right now, the only releases are snapshots with hash-based versions, the latest of which can be found in the maven badge at the top of the readme.  These snapshots are stable versions (in the repeatable-build sense), but they should not be considered stable, production-ready, future-proof software.  We are quickly moving towards a final 0.1 release, which will depend on cats-core and will represent the stable, finalized API.</p>

<p>Once cats releases a final 1.0 version, cats-effect will also release version 1.0 which will depend on the corresponding version of cats-core.  Changes to cats-effect are expected to be extremely rare, and thus the dependency should be considered quite stable for the purposes of upstream compatibility.  Nevertheless, the release and versioning cycle is decoupled from cats-core to account for the possibility that breaking changes may need to be made independent of the cats-core release cycle.</p>

<p>Check out the sources!  Check out the documentation.  Play around with the snapshots, and let us know what you think!  Now is the time to make your opinion heard.  If <code class="highlighter-rouge">IO</code> in its current form doesn‚Äôt meet your needs, we want to hear about it!</p>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
      <p>by Daniel Spiewak
    
    on May 02, 2017</p>

    
  <a href="https://twitter.com/djspiewak" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @djspiewak</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/djspiewak" aria-label="Follow @djspiewak on GitHub">Follow @djspiewak</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>



    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
